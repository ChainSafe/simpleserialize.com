{"version":3,"sources":["webpack:///webpack/bootstrap","webpack:///./node_modules/@chainsafe/ssz/lib/index.js","webpack:///./node_modules/core-js/modules/_wks.js","webpack:///./node_modules/core-js/modules/_export.js","webpack:///./node_modules/core-js/modules/_global.js","webpack:///./node_modules/core-js/modules/_descriptors.js","webpack:///./node_modules/core-js/modules/_object-dp.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/type.js","webpack:///./node_modules/core-js/modules/_fails.js","webpack:///./node_modules/core-js/modules/_hide.js","webpack:///./node_modules/core-js/modules/_to-iobject.js","webpack:///./node_modules/core-js/modules/_to-length.js","webpack:///./node_modules/core-js/modules/_to-object.js","webpack:///./node_modules/core-js/modules/_has.js","webpack:///./node_modules/core-js/modules/_an-object.js","webpack:///./node_modules/core-js/modules/_is-object.js","webpack:///./node_modules/core-js/modules/_uid.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/byteArray.js","webpack:///./node_modules/core-js/modules/_core.js","webpack:///./node_modules/core-js/modules/_property-desc.js","webpack:///./node_modules/core-js/modules/_redefine.js","webpack:///./node_modules/core-js/modules/_library.js","webpack:///./node_modules/core-js/modules/_object-keys.js","webpack:///./node_modules/core-js/modules/_to-integer.js","webpack:///./node_modules/core-js/modules/_iterators.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/basic/index.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/node.js","webpack:///./node_modules/core-js/modules/_to-absolute-index.js","webpack:///./node_modules/core-js/modules/_object-gopn.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/index.js","webpack:///./node_modules/buffer/index.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/index.js","webpack:///./node_modules/core-js/modules/_to-primitive.js","webpack:///./node_modules/core-js/modules/_shared.js","webpack:///./node_modules/core-js/modules/_ctx.js","webpack:///./node_modules/core-js/modules/_set-to-string-tag.js","webpack:///./node_modules/core-js/modules/_cof.js","webpack:///./node_modules/core-js/modules/_object-pie.js","webpack:///./node_modules/core-js/modules/_object-gopd.js","webpack:///./node_modules/core-js/modules/_strict-method.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/primitive/types.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/index.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/tree/treeValue.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/gindex.js","webpack:///./node_modules/core-js/modules/_a-function.js","webpack:///./node_modules/core-js/modules/_defined.js","webpack:///./node_modules/core-js/modules/_array-includes.js","webpack:///./node_modules/core-js/modules/_shared-key.js","webpack:///./node_modules/core-js/modules/_enum-bug-keys.js","webpack:///./node_modules/core-js/modules/_object-gops.js","webpack:///./node_modules/core-js/modules/_is-array.js","webpack:///./node_modules/core-js/modules/_object-create.js","webpack:///./node_modules/core-js/modules/_classof.js","webpack:///./node_modules/core-js/modules/es6.array.iterator.js","webpack:///./node_modules/core-js/modules/_array-methods.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/basic/abstract.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/abstract.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/index.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/tree/index.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/zeroNode.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/compat.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/hash.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/constants.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/array.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/vector.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/index.js","webpack:///./node_modules/core-js/modules/es6.symbol.js","webpack:///./node_modules/core-js/modules/_ie8-dom-define.js","webpack:///./node_modules/core-js/modules/_dom-create.js","webpack:///./node_modules/core-js/modules/_wks-ext.js","webpack:///./node_modules/core-js/modules/_object-keys-internal.js","webpack:///./node_modules/core-js/modules/_iobject.js","webpack:///./node_modules/core-js/modules/_object-dps.js","webpack:///./node_modules/core-js/modules/_html.js","webpack:///./node_modules/core-js/modules/_is-array-iter.js","webpack:///./node_modules/core-js/modules/_create-property.js","webpack:///./node_modules/core-js/modules/core.get-iterator-method.js","webpack:///./node_modules/core-js/modules/_iter-detect.js","webpack:///./node_modules/core-js/modules/_iter-define.js","webpack:///./node_modules/core-js/modules/_object-gpo.js","webpack:///./node_modules/core-js/modules/_typed.js","webpack:///./node_modules/core-js/modules/_redefine-all.js","webpack:///./node_modules/core-js/modules/_an-instance.js","webpack:///./node_modules/core-js/modules/_to-index.js","webpack:///./node_modules/core-js/modules/_array-fill.js","webpack:///./node_modules/core-js/modules/es6.array.for-each.js","webpack:///./node_modules/core-js/modules/_object-sap.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/misc.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/operations.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/validator.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/api.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/index.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/index.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/index.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/basic/boolean.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/basic/uint.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/tree.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/hash.js","webpack:///./node_modules/@chainsafe/as-sha256/lib/index.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/proof/index.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/proof/single.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/errorPath.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/list.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/byteVector.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/phase0/index.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/altair/index.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/primitive/index.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/primitive/sszTypes.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/utils/lazyVar.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/allForks/index.js","webpack:///./node_modules/core-js/modules/_function-to-string.js","webpack:///./node_modules/core-js/modules/_meta.js","webpack:///./node_modules/core-js/modules/_wks-define.js","webpack:///./node_modules/core-js/modules/_enum-keys.js","webpack:///./node_modules/core-js/modules/_object-gopn-ext.js","webpack:///./node_modules/core-js/modules/es6.array.from.js","webpack:///./node_modules/core-js/modules/_iter-call.js","webpack:///./node_modules/core-js/modules/es6.string.iterator.js","webpack:///./node_modules/core-js/modules/_string-at.js","webpack:///./node_modules/core-js/modules/_iter-create.js","webpack:///./node_modules/core-js/modules/es6.object.to-string.js","webpack:///./node_modules/core-js/modules/_add-to-unscopables.js","webpack:///./node_modules/core-js/modules/_iter-step.js","webpack:///./node_modules/core-js/modules/web.dom.iterable.js","webpack:///./node_modules/core-js/modules/es6.typed.uint8-array.js","webpack:///./node_modules/core-js/modules/_typed-array.js","webpack:///./node_modules/core-js/modules/_typed-buffer.js","webpack:///./node_modules/core-js/modules/_array-species-create.js","webpack:///./node_modules/core-js/modules/_array-species-constructor.js","webpack:///./node_modules/core-js/modules/_species-constructor.js","webpack:///./node_modules/core-js/modules/_set-species.js","webpack:///./node_modules/core-js/modules/_array-copy-within.js","webpack:///./node_modules/core-js/modules/es7.object.entries.js","webpack:///./node_modules/core-js/modules/_object-to-array.js","webpack:///./node_modules/core-js/modules/es6.array.is-array.js","webpack:///./node_modules/core-js/modules/es6.array.slice.js","webpack:///./node_modules/core-js/modules/es6.function.name.js","webpack:///./node_modules/core-js/modules/es6.array.sort.js","webpack:///./node_modules/core-js/modules/es6.object.keys.js","webpack:///./node_modules/core-js/modules/es6.array.index-of.js","webpack:///./node_modules/core-js/modules/es6.object.define-property.js","webpack:///./node_modules/core-js/modules/es6.array.filter.js","webpack:///./node_modules/core-js/modules/es6.object.get-own-property-descriptor.js","webpack:///./node_modules/core-js/modules/es7.object.get-own-property-descriptors.js","webpack:///./node_modules/core-js/modules/_own-keys.js","webpack:///./node_modules/core-js/modules/es6.object.define-properties.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/types.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/index.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/block.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/state.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/types/wire.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/phase0/sszTypes.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/constants.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/presetName.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/interface.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/ssz.js","webpack:///./node_modules/@chainsafe/ssz/lib/interface.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/basic/wellKnown.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/index.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/tree/interface.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/backedValue.js","webpack:///./node_modules/@chainsafe/ssz/lib/backings/readonlyIterate.js","webpack:///./node_modules/@chainsafe/as-sha256/lib/wasm.js","webpack:///./node_modules/@assemblyscript/loader/index.js","webpack:///(webpack)/buildin/global.js","webpack:///./node_modules/base64-js/index.js","webpack:///./node_modules/ieee754/index.js","webpack:///./node_modules/isarray/index.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/subtree.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/tree.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/proof/treeOffset.js","webpack:///./node_modules/@chainsafe/persistent-merkle-tree/lib/proof/util.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/merkleize.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/math.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/zeros.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/bitVector.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/bitList.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/root.js","webpack:///./node_modules/@chainsafe/ssz/lib/types/composite/container.js","webpack:///./node_modules/@chainsafe/ssz/lib/util/json.js","webpack:///./node_modules/case/dist/Case.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/phase0/interface.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/phase0/ssz.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/altair/interface.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/preset/altair/ssz.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/activePreset.js","webpack:///./node_modules/process/browser.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/mainnet/index.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/mainnet/phase0.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/mainnet/altair.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/minimal/index.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/minimal/phase0.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/presets/minimal/altair.js","webpack:///./node_modules/@chainsafe/lodestar-params/lib/forkName.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/types/index.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/types/sync.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/types/committee.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/types/beacon.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/types/wire.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/altair/sszTypes.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/allForks/types.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/allForks/sszTypes.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/sszTypes.js","webpack:///./node_modules/@chainsafe/lodestar-types/lib/StringType.js","webpack:///./src/util/types.ts","webpack:///./src/components/worker.tsx"],"names":["phase0","ssz","altair","allForks","primitive","forks","typeNames","types","Object","keys","sort","randomNumber","length","Math","random","randomNumberUint","byteLength","randomBigUint","BigInt","randomBoolean","randomBooleanArray","Array","from","randomByteVector","array","Uint8Array","self","crypto","getRandomValues","createRandomValue","type","isNumberUintType","isBigIntUintType","isBooleanType","isBitVectorType","isByteVectorType","isBitListType","listLength","min","floor","limit","isListType","elementType","isVectorType","isContainerType","obj","entries","fields","forEach","fieldName","fieldType","getSSZType","data","forkName","sszTypeName","createRandomValueWorker","sszType","value","serialize","serialized","input","root","hashTreeRoot"],"mappings":";QAAA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;;QAEA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;;;QAGA;QACA;;QAEA;QACA;;QAEA;QACA;QACA;QACA,0CAA0C,gCAAgC;QAC1E;QACA;;QAEA;QACA;QACA;QACA,wDAAwD,kBAAkB;QAC1E;QACA,iDAAiD,cAAc;QAC/D;;QAEA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA;QACA,yCAAyC,iCAAiC;QAC1E,gHAAgH,mBAAmB,EAAE;QACrI;QACA;;QAEA;QACA;QACA;QACA,2BAA2B,0BAA0B,EAAE;QACvD,iCAAiC,eAAe;QAChD;QACA;QACA;;QAEA;QACA,sDAAsD,+DAA+D;;QAErH;QACA;;;QAGA;QACA;;;;;;;;AClFa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,cAAc,mBAAO,CAAC,EAAe;;AAErC,iBAAiB,mBAAO,CAAC,EAAkB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,EAAa;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;ACjFA,YAAY,mBAAO,CAAC,EAAW;AAC/B,UAAU,mBAAO,CAAC,EAAQ;AAC1B,aAAa,mBAAO,CAAC,CAAW;AAChC;;AAEA;AACA;AACA;AACA;;AAEA;;;;;;;ACVA,aAAa,mBAAO,CAAC,CAAW;AAChC,WAAW,mBAAO,CAAC,EAAS;AAC5B,WAAW,mBAAO,CAAC,CAAS;AAC5B,eAAe,mBAAO,CAAC,EAAa;AACpC,UAAU,mBAAO,CAAC,EAAQ;AAC1B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,kFAAkF,uBAAuB;AACzG,iEAAiE;AACjE,+DAA+D;AAC/D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,cAAc;AACd,cAAc;AACd,cAAc;AACd,cAAc;AACd,eAAe;AACf,eAAe;AACf,eAAe;AACf,gBAAgB;AAChB;;;;;;;AC1CA;AACA;AACA;AACA;AACA;AACA,yCAAyC;;;;;;;ACLzC;AACA,kBAAkB,mBAAO,CAAC,CAAU;AACpC,iCAAiC,QAAQ,mBAAmB,UAAU,EAAE,EAAE;AAC1E,CAAC;;;;;;;ACHD,eAAe,mBAAO,CAAC,EAAc;AACrC,qBAAqB,mBAAO,CAAC,EAAmB;AAChD,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C;;AAEA,YAAY,mBAAO,CAAC,CAAgB;AACpC;AACA;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;AACA;AACA;;;;;;;;ACfa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;AACA,gC;;;;;;ACnJA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;;;;;;ACNA,SAAS,mBAAO,CAAC,CAAc;AAC/B,iBAAiB,mBAAO,CAAC,EAAkB;AAC3C,iBAAiB,mBAAO,CAAC,CAAgB;AACzC;AACA,CAAC;AACD;AACA;AACA;;;;;;;ACPA;AACA,cAAc,mBAAO,CAAC,EAAY;AAClC,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA;AACA;;;;;;;ACLA;AACA,gBAAgB,mBAAO,CAAC,EAAe;AACvC;AACA;AACA,2DAA2D;AAC3D;;;;;;;ACLA;AACA,cAAc,mBAAO,CAAC,EAAY;AAClC;AACA;AACA;;;;;;;ACJA,uBAAuB;AACvB;AACA;AACA;;;;;;;ACHA,eAAe,mBAAO,CAAC,EAAc;AACrC;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;;;;;;;ACFA;AACA;AACA;AACA;AACA;;;;;;;;ACJa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,mCAAmC,SAAS;AAC5C;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,iBAAiB,cAAc;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,qC;;;;;;ACvEA,6BAA6B;AAC7B,uCAAuC;;;;;;;ACDvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACPA,aAAa,mBAAO,CAAC,CAAW;AAChC,WAAW,mBAAO,CAAC,CAAS;AAC5B,UAAU,mBAAO,CAAC,EAAQ;AAC1B,UAAU,mBAAO,CAAC,EAAQ;AAC1B,gBAAgB,mBAAO,CAAC,GAAuB;AAC/C;AACA;;AAEA,mBAAO,CAAC,EAAS;AACjB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA,CAAC;AACD;AACA,CAAC;;;;;;;AC9BD;;;;;;;ACAA;AACA,YAAY,mBAAO,CAAC,EAAyB;AAC7C,kBAAkB,mBAAO,CAAC,EAAkB;;AAE5C;AACA;AACA;;;;;;;ACNA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACLA;;;;;;;;ACAa;;AAEb;AACA;AACA,CAAC;;AAED,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,EAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACrDa;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,EAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3FA,gBAAgB,mBAAO,CAAC,EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;;;;;;;ACNA;AACA,YAAY,mBAAO,CAAC,EAAyB;AAC7C,iBAAiB,mBAAO,CAAC,EAAkB;;AAE3C;AACA;AACA;;;;;;;;ACNa;AACb;AACA;AACA,kCAAkC,oCAAoC,aAAa,EAAE,EAAE;AACvF,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,8CAA8C,cAAc;AAC5D,aAAa,mBAAO,CAAC,EAAU;AAC/B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAY;AACjC,aAAa,mBAAO,CAAC,GAAW;AAChC,aAAa,mBAAO,CAAC,GAAQ;AAC7B,aAAa,mBAAO,CAAC,EAAS;;;;;;;;AClB9B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEY;;AAEZ,aAAa,mBAAO,CAAC,GAAW;AAChC,cAAc,mBAAO,CAAC,GAAS;AAC/B,cAAc,mBAAO,CAAC,GAAS;;AAE/B;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,mDAAmD;AACxE;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,mBAAmB,UAAU;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0BAA0B;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,uCAAuC,SAAS;AAChD;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;AACA,aAAa,iBAAiB;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,gDAAgD,EAAE;AAClD;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,iBAAiB,SAAS;AAC1B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,yCAAyC;AACzC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,wBAAwB,eAAe;AACvC;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,wBAAwB,QAAQ;AAChC;AACA,qBAAqB,eAAe;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,SAAS;AACT;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,kBAAkB;AACnC;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA,mBAAmB,cAAc;AACjC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA,uDAAuD,OAAO;AAC9D;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,kBAAkB;AAClB;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,qBAAqB,QAAQ;AAC7B;AACA;AACA,GAAG;AACH;AACA,eAAe,SAAS;AACxB;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA,eAAe,iBAAiB;AAChC;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,iBAAiB,YAAY;AAC7B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,iBAAiB,gBAAgB;AACjC;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,iBAAiB,gBAAgB;AACjC;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,iBAAiB,YAAY;AAC7B;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;;;;;;;;AC5vDa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,GAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,mCAAmC,mBAAO,CAAC,GAAY;;AAEvD;;AAEA,kBAAkB,mBAAO,CAAC,GAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,qCAAqC,gDAAgD,2BAA2B,yCAAyC,cAAc,GAAG,cAAc;;AAExL,uCAAuC,6BAA6B,YAAY,EAAE,4EAA4E,SAAS,gBAAgB,EAAE,wCAAwC,+BAA+B,uBAAuB,EAAE,iBAAiB,sFAAsF,uBAAuB,sDAAsD,qFAAqF,sCAAsC,0CAA0C,EAAE,OAAO,wBAAwB,EAAE,EAAE,EAAE,sBAAsB,aAAa,wBAAwB,EAAE,eAAe;AACruB,iC;;;;;;AC7CA;AACA,eAAe,mBAAO,CAAC,EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACXA,WAAW,mBAAO,CAAC,EAAS;AAC5B,aAAa,mBAAO,CAAC,CAAW;AAChC;AACA,kDAAkD;;AAElD;AACA,qEAAqE;AACrE,CAAC;AACD;AACA,QAAQ,mBAAO,CAAC,EAAY;AAC5B;AACA,CAAC;;;;;;;ACXD;AACA,gBAAgB,mBAAO,CAAC,EAAe;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACnBA,UAAU,mBAAO,CAAC,CAAc;AAChC,UAAU,mBAAO,CAAC,EAAQ;AAC1B,UAAU,mBAAO,CAAC,CAAQ;;AAE1B;AACA,oEAAoE,iCAAiC;AACrG;;;;;;;ACNA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;ACJA,cAAc;;;;;;;ACAd,UAAU,mBAAO,CAAC,EAAe;AACjC,iBAAiB,mBAAO,CAAC,EAAkB;AAC3C,gBAAgB,mBAAO,CAAC,CAAe;AACvC,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,UAAU,mBAAO,CAAC,EAAQ;AAC1B,qBAAqB,mBAAO,CAAC,EAAmB;AAChD;;AAEA,YAAY,mBAAO,CAAC,CAAgB;AACpC;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;AACA;;;;;;;;ACfa;AACb,YAAY,mBAAO,CAAC,CAAU;;AAE9B;AACA;AACA;AACA,yCAAyC,cAAc;AACvD,GAAG;AACH;;;;;;;;ACRa;AACb,iC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,kCAAkC,mBAAO,CAAC,GAAS;;AAEnD;;AAEA,mCAAmC,mBAAO,CAAC,GAAY;;AAEvD;;AAEA,qCAAqC,gDAAgD,2BAA2B,yCAAyC,cAAc,GAAG,cAAc;;AAExL,uCAAuC,6BAA6B,YAAY,EAAE,4EAA4E,SAAS,gBAAgB,EAAE,wCAAwC,+BAA+B,uBAAuB,EAAE,iBAAiB,sFAAsF,uBAAuB,sDAAsD,qFAAqF,sCAAsC,0CAA0C,EAAE,OAAO,wBAAwB,EAAE,EAAE,EAAE,sBAAsB,aAAa,wBAAwB,EAAE,eAAe;AACruB,iC;;;;;;;AClBa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAa;;AAElC,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,YAAY,mBAAO,CAAC,EAAiB;;AAErC;;AAEA,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,8CAA8C;;AAE9C;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qC;;;;;;;ACvaa;AACb,8CAA8C,cAAc;AAC5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC;AAChC;AACA;AACA,gCAAgC;AAChC;AACA,iBAAiB;AACjB;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oBAAoB;AACpB;AACA;AACA;AACA,gBAAgB;AAChB;AACA;AACA;AACA,oBAAoB;AACpB,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;ACpHA;AACA;AACA;AACA;;;;;;;ACHA;AACA;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA,gBAAgB,mBAAO,CAAC,CAAe;AACvC,eAAe,mBAAO,CAAC,EAAc;AACrC,sBAAsB,mBAAO,CAAC,EAAsB;AACpD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK,YAAY,eAAe;AAChC;AACA,KAAK;AACL;AACA;;;;;;;ACtBA,aAAa,mBAAO,CAAC,EAAW;AAChC,UAAU,mBAAO,CAAC,EAAQ;AAC1B;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA;;;;;;;ACHA;;;;;;;ACAA;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B;AACA;AACA;;;;;;;ACJA;AACA,eAAe,mBAAO,CAAC,EAAc;AACrC,UAAU,mBAAO,CAAC,EAAe;AACjC,kBAAkB,mBAAO,CAAC,EAAkB;AAC5C,eAAe,mBAAO,CAAC,EAAe;AACtC,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA,eAAe,mBAAO,CAAC,EAAe;AACtC;AACA;AACA;AACA;AACA;AACA,EAAE,mBAAO,CAAC,EAAS;AACnB,6BAA6B;AAC7B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;;;;;;ACxCA;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B,UAAU,mBAAO,CAAC,CAAQ;AAC1B;AACA,2BAA2B,kBAAkB,EAAE;;AAE/C;AACA;AACA;AACA;AACA,GAAG,YAAY;AACf;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtBa;AACb,uBAAuB,mBAAO,CAAC,GAAuB;AACtD,WAAW,mBAAO,CAAC,GAAc;AACjC,gBAAgB,mBAAO,CAAC,EAAc;AACtC,gBAAgB,mBAAO,CAAC,CAAe;;AAEvC;AACA;AACA;AACA;AACA,iBAAiB,mBAAO,CAAC,EAAgB;AACzC,gCAAgC;AAChC,cAAc;AACd,iBAAiB;AACjB;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;;AAED;AACA;;AAEA;AACA;AACA;;;;;;;ACjCA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B,cAAc,mBAAO,CAAC,EAAY;AAClC,eAAe,mBAAO,CAAC,EAAc;AACrC,eAAe,mBAAO,CAAC,EAAc;AACrC,UAAU,mBAAO,CAAC,GAAyB;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,UAAU,eAAe;AACzB;AACA;AACA;AACA,wCAAwC;AACxC;AACA,8BAA8B;AAC9B,6BAA6B;AAC7B,+BAA+B;AAC/B,mCAAmC;AACnC,SAAS,iCAAiC;AAC1C;AACA;AACA;AACA;AACA;;;;;;;;AC3Ca;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,CAAS;;AAE7B;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA,oC;;;;;;;ACzFa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,gBAAgB,mBAAO,CAAC,EAAgB;;AAExC,YAAY,mBAAO,CAAC,CAAS;;AAE7B,4BAA4B,mBAAO,CAAC,EAAmC;;AAEvE,cAAc,mBAAO,CAAC,EAAmB;;AAEzC,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,GAAG;;AAEH;AACA;AACA;;;AAGA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;;;AAGA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,oC;;;;;;;ACjaa;;AAEb;AACA;AACA,CAAC;;AAED,YAAY,mBAAO,CAAC,EAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,mBAAmB,mBAAO,CAAC,GAAe;;AAE1C;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,uBAAuB,mBAAO,CAAC,GAAmB;;AAElD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACzCa;;AAEb;AACA;AACA,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;AC7Ba;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,EAAQ;AAC/B;AACA;AACA;AACA,mCAAmC,YAAY;AAC/C;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACbA,8CAAa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAQ;;AAE7B,kBAAkB,mBAAO,CAAC,GAAa;;AAEvC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;;AC1BA,8CAAa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,oCAAoC,mBAAO,CAAC,EAAsB;;AAElE,sCAAsC,uCAAuC,gBAAgB;;AAE7F;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,gC;;;;;;;;ACnBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;;AAEA;AACA,2BAA2B;;AAE3B;;AAEA;AACA;AACA;AACA,qC;;;;;;;AClBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC,iBAAiB,mBAAO,CAAC,GAAsB;;AAE/C,4BAA4B,mBAAO,CAAC,EAAmC;;AAEvE,iBAAiB,mBAAO,CAAC,EAA+B;;AAExD,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,4CAA4C;;AAE5C,wFAAwF;AACxF;;AAEA,mCAAmC,eAAe;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA,yHAAyH;;AAEzH;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA,0BAA0B,aAAa;AACvC;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8EAA8E;;AAE9E;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,wCAAwC,gBAAgB;AACxD;AACA;;AAEA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,kCAAkC;AACvD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA,mBAAmB,kCAAkC;AACrD;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,mCAAmC;AACtD;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,kCAAkC;AACrD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,uBAAuB;AACvB;;AAEA;AACA,oBAAoB;;AAEpB;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,YAAY;AACjC;AACA,oEAAoE;;AAEpE;AACA;;AAEA;AACA,KAAK;AACL;;AAEA,qBAAqB,YAAY;AACjC;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,YAAY;AAC/B;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA,qBAAqB,iCAAiC;AACtD;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA,yBAAyB;AACzB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;;;AAGP,+EAA+E,gBAAgB;AAC/F;AACA;AACA,KAAK;AACL,kDAAkD,gBAAgB;AAClE;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,iC;;;;;;;ACzqBa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAS;;AAE9B,aAAa,mBAAO,CAAC,EAAU;;AAE/B,YAAY,mBAAO,CAAC,CAAS;;AAE7B,4BAA4B,mBAAO,CAAC,EAAmC;;AAEvE,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M,iDAAiD;;AAEjD;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;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6CAA6C,oCAAoC;AACjF,KAAK,4BAA4B,oCAAoC;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gBAAgB,mBAAmB;AACnC;AACA;AACA,kCAAkC,2BAA2B;AAC7D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;;;;;;ACpEA;AACA,UAAU,mBAAO,CAAC,EAAQ;AAC1B,eAAe,mBAAO,CAAC,EAAc;AACrC,eAAe,mBAAO,CAAC,EAAe;AACtC;;AAEA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACZA,aAAa,mBAAO,CAAC,CAAW;AAChC,WAAW,mBAAO,CAAC,CAAS;AAC5B,UAAU,mBAAO,CAAC,EAAQ;AAC1B;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;;;;;;;AC3BA,eAAe,mBAAO,CAAC,EAAa;AACpC;AACA;AACA;AACA;;;;;;;ACJA;AACA;AACA;AACA,GAAG;AACH;;;;;;;ACJA;AACA,gBAAgB,mBAAO,CAAC,EAAe;AACvC,eAAe,mBAAO,CAAC,EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACTA;AACa;AACb,eAAe,mBAAO,CAAC,EAAc;AACrC,sBAAsB,mBAAO,CAAC,EAAsB;AACpD,eAAe,mBAAO,CAAC,EAAc;AACrC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACda;AACb,cAAc,mBAAO,CAAC,CAAW;AACjC,eAAe,mBAAO,CAAC,EAAkB;AACzC,aAAa,mBAAO,CAAC,EAAkB;;AAEvC;AACA;AACA;AACA;AACA;AACA,CAAC;;;;;;;ACVD;AACA,cAAc,mBAAO,CAAC,CAAW;AACjC,WAAW,mBAAO,CAAC,EAAS;AAC5B,YAAY,mBAAO,CAAC,CAAU;AAC9B;AACA,6BAA6B;AAC7B;AACA;AACA,qDAAqD,OAAO,EAAE;AAC9D;;;;;;;;ACTa;AACb,gC;;;;;;;ACDa;AACb,sC;;;;;;;ACDa;AACb,qC;;;;;;;ACDa;AACb,+B;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,cAAc,mBAAO,CAAC,EAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,oBAAoB,mBAAO,CAAC,GAAgB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,gBAAgB,mBAAO,CAAC,GAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACzDa;;AAEb;AACA;AACA,CAAC;;AAED,kBAAkB,mBAAO,CAAC,GAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,WAAW,mBAAO,CAAC,GAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,GAAU;;AAE/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,cAAc,mBAAO,CAAC,GAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACtEa;;AAEb;AACA;AACA,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,CAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACzCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,CAAS;;AAE7B,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mC;;;;;;;ACtEa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;;AAEA,YAAY,mBAAO,CAAC,CAAS;;AAE7B,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,0BAA0B,8BAA8B;AACxD;AACA;AACA,KAAK;AACL;AACA;;AAEA,qBAAqB,qBAAqB;AAC1C;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA,sCAAsC;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA,mBAAmB,qBAAqB;AACxC;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;;;AAGT;AACA;AACA,SAAS;AACT;AACA;;AAEA;AACA;AACA;AACA,KAAK;;;AAGL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;;AAEA;AACA,gC;;;;;;;ACrQa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA,gC;;;;;;;ACVa;AACb,8CAA8C,cAAc;AAC5D;AACA,oBAAoB,mBAAO,CAAC,EAAsB;AAClD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACba;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,qBAAqB,iBAAiB;AACtC;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,oC;;;;;;;ACzEa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,EAAU;AACnC,qBAAqB,mBAAO,CAAC,GAAc;AAC3C;AACA;AACA;AACA;AACA,CAAC,0DAA0D;AAC3D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACvFa;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,EAAS;AAChC,iBAAiB,mBAAO,CAAC,EAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACzCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;;AAGA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,qC;;;;;;;ACxDa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,aAAa,mBAAO,CAAC,EAAS;;AAE9B,aAAa,mBAAO,CAAC,EAAU;;AAE/B,YAAY,mBAAO,CAAC,CAAS;;AAE7B,cAAc,mBAAO,CAAC,EAAmB;;AAEzC,4BAA4B,mBAAO,CAAC,EAAmC;;AAEvE,iBAAiB,mBAAO,CAAC,EAA+B;;AAExD,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6CAA6C;;AAE7C;;AAEA;AACA;AACA,CAAC;;;AAGD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;;AAGH;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8DAA8D;;AAE9D;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAE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B;AACrD,kBAAkB,mBAAO,CAAC,EAAc;AACxC,oBAAoB,mBAAO,CAAC,EAAgB;AAC5C,mBAAmB,mBAAO,CAAC,GAAgB;AAC3C,kBAAkB,mBAAO,CAAC,EAAe;AACzC,wBAAwB,mBAAO,CAAC,GAAsB;AACtD,YAAY,mBAAO,CAAC,CAAc;AAClC,cAAc,mBAAO,CAAC,EAAgB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,GAAG;;AAEH;AACA;AACA;AACA,GAAG;;AAEH;AACA,4BAA4B;AAC5B,GAAG;;AAEH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,iBAAiB,mBAAmB,0BAA0B,EAAE,EAAE;AAClE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,yDAAyD,gCAAgC;AACzF;AACA,OAAO;AACP;AACA;AACA,6EAA6E,YAAY;AACzF;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yDAAyD,6CAA6C,EAAE;;AAExG;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,mDAAmD;AACnD;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,oCAAoC;AACpC;AACA,KAAK;AACL,wEAAwE;AACxE;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL,8DAA8D;AAC9D;AACA,KAAK;AACL,wEAAwE;AACxE;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;;AAEH,yBAAyB,sBAAsB,EAAE,EAAE;AACnD;AACA;AACA;AACA;;AAEA,4CAA4C;AAC5C;AACA;AACA;AACA;AACA;AACA,8BAA8B,aAAa;AAC3C;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,sBAAsB,0BAA0B;AAChD,GAAG;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;AACA,KAAK;AACL,yBAAyB;AACzB,KAAK;AACL,uBAAuB;AACvB,2BAA2B;AAC3B,0BAA0B;AAC1B,2BAA2B;AAC3B,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,0BAA0B,aAAa;AACvC,OAAO;AACP;;AAEA;;AAEA;;AAEA;AACA;AACA,KAAK;;AAEL,uDAAuD,6BAA6B,EAAE;AACtF;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;;AAEA,uDAAuD,YAAY;;AAEnE;;AAEA;;AAEA;AACA;AACA,KAAK,UAAU,gBAAgB;;AAE/B;AACA;AACA,KAAK;AACL;AACA,KAAK,WAAW,kCAAkC;;AAElD;AACA;AACA;AACA,CAAC,oCAAoC;;;;;;;;AC/dxB;AACb,aAAa,mBAAO,CAAC,CAAW;AAChC,kBAAkB,mBAAO,CAAC,CAAgB;AAC1C,cAAc,mBAAO,CAAC,EAAY;AAClC,aAAa,mBAAO,CAAC,EAAU;AAC/B,WAAW,mBAAO,CAAC,CAAS;AAC5B,kBAAkB,mBAAO,CAAC,EAAiB;AAC3C,YAAY,mBAAO,CAAC,CAAU;AAC9B,iBAAiB,mBAAO,CAAC,EAAgB;AACzC,gBAAgB,mBAAO,CAAC,EAAe;AACvC,eAAe,mBAAO,CAAC,EAAc;AACrC,cAAc,mBAAO,CAAC,EAAa;AACnC,WAAW,mBAAO,CAAC,EAAgB;AACnC,SAAS,mBAAO,CAAC,CAAc;AAC/B,gBAAgB,mBAAO,CAAC,EAAe;AACvC,qBAAqB,mBAAO,CAAC,EAAsB;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA,QAAQ,UAAU;AAClB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA;AACA,QAAQ,WAAW;AACnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA,GAAG;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,yBAAyB,mBAAmB,uBAAuB,EAAE,EAAE;AACvE;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,iBAAiB,WAAW;AAC5B;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA,GAAG;AACH,yBAAyB;AACzB,GAAG;AACH,uBAAuB;AACvB,0BAA0B;AAC1B,0BAA0B;AAC1B;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA,iDAAiD,iBAAiB;AAClE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA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CA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,WAAW,mBAAO,CAAC,EAAO;;AAE1B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAuB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;AC7Ga;AACb,iC;;;;;;;ACDa;AACb,iC;;;;;;;ACDa;AACb,gC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sBAAsB,mBAAO,CAAC,EAA4B;;AAE1D,WAAW,mBAAO,CAAC,CAAgB;;AAEnC,iBAAiB,mBAAO,CAAC,GAAc;;AAEvC,eAAe,mBAAO,CAAC,GAAkB;;AAEzC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;;AAEnB,6CAA6C;AAC7C;;AAEA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA,CAAC;AACD,oC;;;;;;;AC3da;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;;AAE3C;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA,4DAA4D;;AAE5D;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oEAAoE;;AAEpE;AACA;AACA;AACA;AACA;AACA,iCAAiC;;AAEjC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,sCAAsC;;AAEtC;AACA,oGAAoG;;AAEpG;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,oCAAoC;;AAEpC;AACA;AACA;AACA;AACA;AACA,mCAAmC;AACnC;;AAEA;AACA,0CAA0C;;AAE1C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qC;;;;;;;AC5Ha;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,qDAAqD;AACtD,sC;;;;;;;ACba;AACb,qC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,WAAW,mBAAO,CAAC,CAAgB;;AAEnC,aAAa,mBAAO,CAAC,GAAU;;AAE/B,cAAc,mBAAO,CAAC,GAAU;;AAEhC,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA,wCAAwC;AACxC,CAAC;AACD;AACA,+B;;;;;;;ACvBa;AACb,qC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,EAAQ;;AAE5B,eAAe,mBAAO,CAAC,EAAW;;AAElC;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,qC;;;;;;;ACrBa;;AAEb;AACA;AACA,CAAC;;AAED,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAS;;AAE9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,cAAc,mBAAO,CAAC,EAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,eAAe,mBAAO,CAAC,GAAW;;AAElC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,kBAAkB,mBAAO,CAAC,GAAc;;AAExC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;ACjHa;AACb,qC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,YAAY,mBAAO,CAAC,EAAQ;;AAE5B;AACA;AACA;AACA,uC;;;;;;;ACZa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,EAAQ;;AAE5B;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA,2C;;;;;;;ACzBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,qCAAqC,mBAAO,CAAC,GAAwB;;AAErE,cAAc,mBAAO,CAAC,EAAQ;;AAE9B,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA,wuDAAwuD,m/FAAm/F,4nCAA4nC;;AAEv1L;;AAEA;AACA;AACA,C;;;;;;;ACpBa;;AAEb;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,8CAA8C;AAC9C;AACA,mDAAmD;AACnD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mDAAmD;;AAEnD;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA,6DAA6D;AAC7D;;AAEA;AACA;AACA;AACA;AACA;AACA,kCAAkC,YAAY;AAC9C;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB,YAAY;AACjC,KAAK;AACL;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA,mBAAmB,SAAS;AAC5B;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,2CAA2C;AAC3C;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB,6CAA6C;AACrE;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gDAAgD,UAAU,oCAAoC,EAAE;AAChG;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,6BAA6B,2BAA2B,EAAE;AAC1D,kCAAkC,2BAA2B,EAAE;AAC/D;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA;AACA,WAAW;AACX,SAAS,OAAO;AAChB,2CAA2C;AAC3C;AACA;AACA,WAAW;AACX;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA,WAAW;AACX;AACA,OAAO;AACP;AACA;AACA;AACA,SAAS;AACT,OAAO;AACP;AACA;AACA;AACA;AACA;AACA;;AAEA;;;;;;;AChaA;;AAEA;AACA;AACA;AACA,CAAC;;AAED;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA,4CAA4C;;AAE5C;;;;;;;;ACnBY;;AAEZ;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA,kCAAkC,SAAS;AAC3C;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;;AAEA;AACA;AACA;AACA;;AAEA;AACA,aAAa,SAAS;AACtB;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,qBAAqB,SAAS;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA,0CAA0C,UAAU;AACpD;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;;;;;;ACrJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA;AACA,QAAQ,WAAW;;AAEnB;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA,QAAQ,WAAW;;AAEnB;AACA;AACA,QAAQ,UAAU;;AAElB;AACA;;;;;;;ACpFA,iBAAiB;;AAEjB;AACA;AACA;;;;;;;;ACJa;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,EAAQ;AAC/B,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC/Da;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,EAAU;AACnC,eAAe,mBAAO,CAAC,EAAQ;AAC/B,gBAAgB,mBAAO,CAAC,EAAS;AACjC,iBAAiB,mBAAO,CAAC,EAAgB;AACzC,mBAAmB,mBAAO,CAAC,EAAY;AACvC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;AC1Ma;AACb,8CAA8C,cAAc;AAC5D;AACA,eAAe,mBAAO,CAAC,EAAS;AAChC,eAAe,mBAAO,CAAC,GAAQ;AAC/B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,mBAAmB,oBAAoB;AACvC;AACA;AACA;AACA;AACA,mBAAmB,mBAAmB;AACtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,gCAAgC,wBAAwB;AACxD;AACA;AACA,+BAA+B,oBAAoB;AACnD;AACA;AACA;;;;;;;;ACrHa;AACb,8CAA8C,cAAc;AAC5D;AACA,iBAAiB,mBAAO,CAAC,EAAW;AACpC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,YAAY;AACZ;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,0BAA0B,6BAA6B;AACvD;AACA,2BAA2B,6BAA6B;AACxD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,eAAe,eAAe;AAC9B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;;;;;;;ACtGA,8CAAa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,EAAQ;;AAE5B,YAAY,mBAAO,CAAC,GAAQ;;AAE5B,aAAa,mBAAO,CAAC,GAAS;;AAE9B;;AAEA;AACA;AACA;;AAEA;AACA;AACA,GAAG;AACH;;;AAGA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA,mBAAmB,mBAAmB;AACtC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA,qC;;;;;;;;ACvDa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;;AAGA;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA,gC;;;;;;;AC/BA,8CAAa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,iBAAiB,mBAAO,CAAC,EAAa;;AAEtC,YAAY,mBAAO,CAAC,EAAQ;;AAE5B;AACA;AACA;AACA;;AAEA,eAAe,QAAQ;AACvB;AACA;AACA;AACA,iC;;;;;;;;ACpBa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,cAAc,mBAAO,CAAC,EAAU;;AAEhC,aAAa,mBAAO,CAAC,EAAU;;AAE/B,YAAY,mBAAO,CAAC,CAAS;;AAE7B,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA,GAAG;;;AAGH;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,oBAAoB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,mCAAmC;AACnC;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,qC;;;;;;;ACpOa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,YAAY,mBAAO,CAAC,GAAQ;;AAE5B,aAAa,mBAAO,CAAC,EAAU;;AAE/B,YAAY,mBAAO,CAAC,CAAS;;AAE7B,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;AACA;;AAEA;AACA;AACA;AACA;;AAEA,8BAA8B,oBAAoB;AAClD;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA,uBAAuB,aAAa;AACpC;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA,mBAAmB,gBAAgB;AACnC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;;;AAGL;AACA,qFAAqF;;AAErF;AACA;AACA,iDAAiD;;AAEjD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,oCAAoC;;AAEpC;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA,qBAAqB,uBAAuB;AAC5C;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,KAAK;AACL;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,mC;;;;;;;AC3Ra;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,kBAAkB,mBAAO,CAAC,GAAc;;AAExC,YAAY,mBAAO,CAAC,CAAS;;AAE7B,gBAAgB,mBAAO,CAAC,EAAgB;;AAExC,iBAAiB,mBAAO,CAAC,EAAsB;;AAE/C,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA,GAAG;AACH;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,KAAK;;AAEL;;AAEA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,gC;;;;;;;ACrEa;;AAEb;AACA;AACA,CAAC;AACD;AACA;;AAEA,gBAAgB,mBAAO,CAAC,EAAY;;AAEpC,YAAY,mBAAO,CAAC,CAAS;;AAE7B,4BAA4B,mBAAO,CAAC,EAAmC;;AAEvE,iBAAiB,mBAAO,CAAC,GAAsB;;AAE/C,YAAY,mBAAO,CAAC,GAAiB;;AAErC,iBAAiB,mBAAO,CAAC,EAA+B;;AAExD,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;;AAEA,kCAAkC;;AAElC;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;AACA;;AAEA,2JAA2J;;AAE3J;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA,wBAAwB;;AAExB;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,KAAK;AACL;;AAEA;AACA;AACA;;AAEA;AACA;AACA,uBAAuB;AACvB;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,OAAO;AACP;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA,yCAAyC;;AAEzC;AACA;AACA,OAAO;AACP;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA;AACA,wBAAwB;;AAExB;AACA,OAAO;AACP;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA;AACA,KAAK;AACL;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,OAAO;;AAEP;AACA;AACA,OAAO;AACP;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA,OAAO;AACP;AACA;AACA;AACA;;AAEA;AACA,SAAS;AACT;AACA;AACA;AACA;;AAEA;AACA;;AAEA;;AAEA;AACA,qC;;;;;;;AChjBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,mCAAmC,mBAAO,CAAC,GAAM;;AAEjD,sCAAsC,uCAAuC,gBAAgB;;AAE7F;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA,gC;;;;;;ACvBA;AACA,kCAAkC;AAClC;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA,wCAAwC;AACxC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,0CAA0C,KAAK;AAC/C,mEAAmE,mBAAmB;AACtF;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb,SAAS;AACT;AACA;AACA;AACA,aAAa;AACb;AACA;AACA;AACA,iBAAiB;AACjB;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB,iBAAiB;AACjB;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA,WAAW,KAA0B;;AAErC,CAAC;;;;;;;;AC1KY;AACb,qC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,WAAW,mBAAO,CAAC,CAAgB;;AAEnC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+B;;;;;;;AC7Da;AACb,qC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,WAAW,mBAAO,CAAC,CAAgB;;AAEnC;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA,+B;;;;;;;AC1BA,+CAAa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,cAAc,mBAAO,CAAC,EAAU;;AAEhC,eAAe,mBAAO,CAAC,GAAmB;;AAE1C,eAAe,mBAAO,CAAC,GAAmB;;AAE1C;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,wC;;;;;;;AC7GA;AACA;;AAEA;AACA;AACA;AACA;;AAEA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,SAAS;AACT;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;;;AAGA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,SAAS;AACT;AACA;AACA;AACA;AACA;;;;AAIA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,uBAAuB,sBAAsB;AAC7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,qBAAqB;AACrB;;AAEA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA,qCAAqC;;AAErC;AACA;AACA;;AAEA,2BAA2B;AAC3B;AACA;AACA;AACA,4BAA4B,UAAU;;;;;;;;ACvLzB;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,aAAa,mBAAO,CAAC,GAAU;;AAE/B,cAAc,mBAAO,CAAC,GAAU;;AAEhC,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA,6CAA6C;;AAE7C;AACA,iC;;;;;;;ACvBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AC3Fa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AChBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,aAAa,mBAAO,CAAC,GAAU;;AAE/B,cAAc,mBAAO,CAAC,GAAU;;AAEhC,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;;AAEA,6CAA6C;;AAE7C;AACA,iC;;;;;;;ACvBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;ACnGa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,kC;;;;;;;AChBa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;AACA,CAAC,+CAA+C;AAChD,oC;;;;;;;ACjBa;;AAEb;AACA;AACA,CAAC;;AAED,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,GAAa;;AAEtC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,cAAc,mBAAO,CAAC,GAAU;;AAEhC;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAuB;;AAE5C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,EAAyB;;AAE7C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,kBAAkB,mBAAO,CAAC,EAA+B;;AAEzD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,iBAAiB,mBAAO,CAAC,EAA8B;;AAEvD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,YAAY,mBAAO,CAAC,GAAQ;;AAE5B;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,WAAW,mBAAO,CAAC,EAAwB;;AAE3C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;AACD,iC;;;;;;;AC1Ha;AACb,gC;;;;;;;ACDa;AACb,qC;;;;;;;ACDa;AACb,kC;;;;;;;ACDa;AACb,gC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,sBAAsB,mBAAO,CAAC,EAA4B;;AAE1D,WAAW,mBAAO,CAAC,CAAgB;;AAEnC,aAAa,mBAAO,CAAC,EAAW;;AAEhC,iBAAiB,mBAAO,CAAC,GAAc;;AAEvC,eAAe,mBAAO,CAAC,GAAkB;;AAEzC,0CAA0C,gCAAgC,oCAAoC,oDAAoD,8DAA8D,gEAAgE,EAAE,EAAE,gCAAgC,EAAE,aAAa;;AAEnV,gCAAgC,gBAAgB,sBAAsB,OAAO,uDAAuD,aAAa,uDAAuD,2CAA2C,EAAE,EAAE,EAAE,6CAA6C,2EAA2E,EAAE,OAAO,iDAAiD,kFAAkF,EAAE,EAAE,EAAE,EAAE,eAAe;;AAEphB,2CAA2C,kBAAkB,kCAAkC,qEAAqE,EAAE,EAAE,OAAO,kBAAkB,EAAE,YAAY;;AAE/M;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,kBAAkB;;AAEnB;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA,GAAG;AACH;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA,wCAAwC,wCAAwC;AAChF;AACA,GAAG;AACH,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA,CAAC,EAAE;AACH;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,OAAO;AACP;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA;AACA;AACA,KAAK;AACL;AACA;AACA,KAAK;AACL;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA,KAAK;AACL;AACA,CAAC,EAAE;;AAEH;AACA;AACA;AACA;AACA,CAAC;AACD,oC;;;;;;;ACvRa;AACb,iC;;;;;;;ACDa;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,aAAa,mBAAO,CAAC,EAAW;;AAEhC,cAAc,mBAAO,CAAC,EAAW;;AAEjC;;AAEA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,oC;;;;;;;AClCa;;AAEb;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;AACA;AACA;AACA;AACA;AACA,CAAC;AACD;;AAEA,gBAAgB,mBAAO,CAAC,GAAsB;;AAE9C;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA,GAAG;AACH,CAAC;;AAED,aAAa,mBAAO,CAAC,EAAU;;AAE/B,cAAc,mBAAO,CAAC,EAAU;;AAEhC,gBAAgB,mBAAO,CAAC,GAAY;;AAEpC;AACA;AACA,oC;;;;;;;AC9Ca;;AAEb;AACA;AACA,CAAC;AACD;;AAEA,WAAW,mBAAO,CAAC,CAAgB;;AAEnC;AACA;AACA;AACA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;AACA;AACA;;AAEA;;AAEA;AACA,sC;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;AC9CA;;AAEA,IAAOA,MAAP,GAAiDC,UAAjD,CAAOD,MAAP;AAAA,IAAeE,MAAf,GAAiDD,UAAjD,CAAeC,MAAf;AAAA,IAAuBC,QAAvB,GAAiDF,UAAjD,CAAuBE,QAAvB;AAAA,IAAoCC,SAApC,4BAAiDH,UAAjD;;AAEO,IAAMI,KAAK,GAAG;AACnBL,QAAM,kCAAMA,MAAN,GAAiBI,SAAjB,CADa;AAEnBF,QAAM,gDAAMF,MAAN,GAAiBE,MAAjB,GAA4BE,SAA5B;AAFa,CAAd;AAOA,SAASE,SAAT,CAAsBC,KAAtB,EAAgE;AACrE,SAAOC,MAAM,CAACC,IAAP,CAAYF,KAAZ,EAAmBG,IAAnB,EAAP;AACD,C;;;;;;;;;;;;;;;;;;;;;;;;;;;;;ACdD;AACA;;AAeA,SAASC,YAAT,CAAsBC,MAAtB,EAA8C;AAC5C,SAAOC,IAAI,CAACC,MAAL,KAAgBF,MAAhB,GAAyB,CAAhC;AACD;;AAED,SAASG,gBAAT,CAA0BC,UAA1B,EAAsD;AACpD,SAAOL,YAAY,CAACK,UAAD,CAAnB;AACD;;AAED,SAASC,aAAT,CAAuBD,UAAvB,EAAmD;AACjD,SAAOE,MAAM,CAACP,YAAY,CAACK,UAAD,CAAb,CAAb;AACD;;AAED,SAASG,aAAT,GAAkC;AAChC,SAAON,IAAI,CAACC,MAAL,KAAgB,GAAvB;AACD;;AAED,SAASM,kBAAT,CAA4BR,MAA5B,EAA4D;AAC1D,SAAOS,KAAK,CAACC,IAAN,CAAW;AAACV,UAAM,EAANA;AAAD,GAAX,EAAqB;AAAA,WAAMO,aAAa,EAAnB;AAAA,GAArB,CAAP;AACD;;AAED,SAASI,gBAAT,CAA0BX,MAA1B,EAAsD;AACpD,MAAMY,KAAK,GAAG,IAAIC,UAAJ,CAAeb,MAAf,CAAd;AACAc,MAAI,CAACC,MAAL,CAAYC,eAAZ,CAA4BJ,KAA5B;AACA,SAAOA,KAAP;AACD;;AAED,SAASK,iBAAT,CAA2BC,IAA3B,EAC6E;AAC3E,MAAGC,mCAAgB,CAACD,IAAD,CAAnB,EAA2B;AACzB,WAAOf,gBAAgB,CAACe,IAAI,CAACd,UAAN,CAAvB;AACD,GAFD,MAGK,IAAGgB,mCAAgB,CAACF,IAAD,CAAnB,EAA2B;AAC9B,WAAOb,aAAa,CAACa,IAAI,CAACd,UAAN,CAApB;AACD,GAFI,MAGA,IAAGiB,gCAAa,CAACH,IAAD,CAAhB,EAAwB;AAC3B,WAAOX,aAAa,EAApB;AACD,GAFI,MAGA,IAAGe,kCAAe,CAACJ,IAAD,CAAlB,EAA0B;AAC7B,WAAOV,kBAAkB,CAACU,IAAI,CAAClB,MAAN,CAAzB;AACD,GAFI,MAGA,IAAGuB,mCAAgB,CAACL,IAAD,CAAnB,EAA2B;AAC9B,WAAOP,gBAAgB,CAACO,IAAI,CAAClB,MAAN,CAAvB;AACD,GAFI,MAGA,IAAGwB,gCAAa,CAACN,IAAD,CAAhB,EAAwB;AAC3B,QAAMO,UAAU,GAAGxB,IAAI,CAACyB,GAAL,CAASzB,IAAI,CAAC0B,KAAL,CAAW1B,IAAI,CAACC,MAAL,KAAgB,EAA3B,CAAT,EAAyCgB,IAAI,CAACU,KAA9C,CAAnB;AACA,WAAOpB,kBAAkB,CAACiB,UAAD,CAAzB;AACD,GAHI,MAIA,IAAGI,6BAAU,CAACX,IAAD,CAAb,EAAqB;AACxB,QAAMO,WAAU,GAAGxB,IAAI,CAACyB,GAAL,CAASzB,IAAI,CAAC0B,KAAL,CAAW1B,IAAI,CAACC,MAAL,KAAgB,EAA3B,CAAT,EAAyCgB,IAAI,CAACU,KAA9C,CAAnB;;AACA,WAAOnB,KAAK,CAACC,IAAN,CAAW;AAACV,YAAM,EAAEyB;AAAT,KAAX,EAAiC;AAAA,aAAMR,iBAAiB,CAACC,IAAI,CAACY,WAAN,CAAvB;AAAA,KAAjC,CAAP;AACD,GAHI,MAIA,IAAGC,+BAAY,CAACb,IAAD,CAAf,EAAuB;AAC1B,WAAOT,KAAK,CAACC,IAAN,CAAW;AAACV,YAAM,EAAEkB,IAAI,CAAClB;AAAd,KAAX,EAAkC;AAAA,aAAMiB,iBAAiB,CAACC,IAAI,CAACY,WAAN,CAAvB;AAAA,KAAlC,CAAP;AACD,GAFI,MAGA,IAAGE,kCAAe,CAACd,IAAD,CAAlB,EAA0B;AAC7B,QAAMe,GAAG,GAAG,EAAZ;AACArC,UAAM,CAACsC,OAAP,CAAehB,IAAI,CAACiB,MAApB,EAA4BC,OAA5B,CAAoC,gBAA4B;AAAA;AAAA,UAA1BC,SAA0B;AAAA,UAAfC,SAAe;;AAC9DL,SAAG,CAACI,SAAD,CAAH,GAAiBpB,iBAAiB,CAACqB,SAAD,CAAlC;AACD,KAFD;AAGA,WAAOL,GAAP;AACD;AACF;;AAED,SAASM,UAAT,CAAoBC,IAApB,EAC2C;AACzC,SAAO/C,KAAK,CAAC+C,IAAI,CAACC,QAAN,CAAL,CAAqBD,IAAI,CAACE,WAA1B,CAAP;AACD;;AAEM,SAASC,uBAAT,CAAiCH,IAAjC,EACsE;AAC3E,MAAMI,OAAO,GAAGL,UAAU,CAACC,IAAD,CAA1B;AACA,MAAMK,KAAK,GAAG5B,iBAAiB,CAAC2B,OAAD,CAA/B;AACA,SAAOC,KAAP;AACD;AAEM,SAASC,SAAT,CAAmBN,IAAnB,EAAyF;AAC9F,MAAMtB,IAAI,GAAGqB,UAAU,CAACC,IAAD,CAAvB;AACA,MAAMO,UAAU,GAAG7B,IAAI,CAAC4B,SAAL,CAAeN,IAAI,CAACQ,KAApB,CAAnB;AACA,MAAMC,IAAI,GAAG/B,IAAI,CAACgC,YAAL,CAAkBV,IAAI,CAACQ,KAAvB,CAAb;AACA,SAAO;AAACD,cAAU,EAAVA,UAAD;AAAaE,QAAI,EAAJA;AAAb,GAAP;AACD","file":"4549562a0e97dff0d8f4.worker.js","sourcesContent":[" \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 203);\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  hash: true\n};\nObject.defineProperty(exports, \"hash\", {\n  enumerable: true,\n  get: function get() {\n    return _compat.hash;\n  }\n});\n\nvar _interface = require(\"./interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _interface[key];\n    }\n  });\n});\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _types[key];\n    }\n  });\n});\n\nvar _backings = require(\"./backings\");\n\nObject.keys(_backings).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _backings[key];\n    }\n  });\n});\n\nvar _compat = require(\"./util/compat\");\n\nvar _byteArray = require(\"./util/byteArray\");\n\nObject.keys(_byteArray).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _byteArray[key];\n    }\n  });\n});\n\nvar _tree = require(\"./util/tree\");\n\nObject.keys(_tree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _tree[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","var store = require('./_shared')('wks');\nvar uid = require('./_uid');\nvar Symbol = require('./_global').Symbol;\nvar USE_SYMBOL = typeof Symbol == 'function';\n\nvar $exports = module.exports = function (name) {\n  return store[name] || (store[name] =\n    USE_SYMBOL && Symbol[name] || (USE_SYMBOL ? Symbol : uid)('Symbol.' + name));\n};\n\n$exports.store = store;\n","var global = require('./_global');\nvar core = require('./_core');\nvar hide = require('./_hide');\nvar redefine = require('./_redefine');\nvar ctx = require('./_ctx');\nvar PROTOTYPE = 'prototype';\n\nvar $export = function (type, name, source) {\n  var IS_FORCED = type & $export.F;\n  var IS_GLOBAL = type & $export.G;\n  var IS_STATIC = type & $export.S;\n  var IS_PROTO = type & $export.P;\n  var IS_BIND = type & $export.B;\n  var target = IS_GLOBAL ? global : IS_STATIC ? global[name] || (global[name] = {}) : (global[name] || {})[PROTOTYPE];\n  var exports = IS_GLOBAL ? core : core[name] || (core[name] = {});\n  var expProto = exports[PROTOTYPE] || (exports[PROTOTYPE] = {});\n  var key, own, out, exp;\n  if (IS_GLOBAL) source = name;\n  for (key in source) {\n    // contains in native\n    own = !IS_FORCED && target && target[key] !== undefined;\n    // export native or passed\n    out = (own ? target : source)[key];\n    // bind timers to global for call from export context\n    exp = IS_BIND && own ? ctx(out, global) : IS_PROTO && typeof out == 'function' ? ctx(Function.call, out) : out;\n    // extend global\n    if (target) redefine(target, key, out, type & $export.U);\n    // export\n    if (exports[key] != out) hide(exports, key, exp);\n    if (IS_PROTO && expProto[key] != out) expProto[key] = out;\n  }\n};\nglobal.core = core;\n// type bitmap\n$export.F = 1;   // forced\n$export.G = 2;   // global\n$export.S = 4;   // static\n$export.P = 8;   // proto\n$export.B = 16;  // bind\n$export.W = 32;  // wrap\n$export.U = 64;  // safe\n$export.R = 128; // real proto method for `library`\nmodule.exports = $export;\n","// https://github.com/zloirock/core-js/issues/86#issuecomment-115759028\nvar global = module.exports = typeof window != 'undefined' && window.Math == Math\n  ? window : typeof self != 'undefined' && self.Math == Math ? self\n  // eslint-disable-next-line no-new-func\n  : Function('return this')();\nif (typeof __g == 'number') __g = global; // eslint-disable-line no-undef\n","// Thank's IE8 for his funny defineProperty\nmodule.exports = !require('./_fails')(function () {\n  return Object.defineProperty({}, 'a', { get: function () { return 7; } }).a != 7;\n});\n","var anObject = require('./_an-object');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar toPrimitive = require('./_to-primitive');\nvar dP = Object.defineProperty;\n\nexports.f = require('./_descriptors') ? Object.defineProperty : function defineProperty(O, P, Attributes) {\n  anObject(O);\n  P = toPrimitive(P, true);\n  anObject(Attributes);\n  if (IE8_DOM_DEFINE) try {\n    return dP(O, P, Attributes);\n  } catch (e) { /* empty */ }\n  if ('get' in Attributes || 'set' in Attributes) throw TypeError('Accessors not supported!');\n  if ('value' in Attributes) O[P] = Attributes.value;\n  return O;\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTypeOf = isTypeOf;\nexports.Type = void 0;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/* eslint-disable @typescript-eslint/camelcase */\n\n/**\n * Check if `type` is an instance of `typeSymbol` type\n *\n * Used by various isFooType functions\n */\nfunction isTypeOf(type, typeSymbol) {\n  return type._typeSymbols.has(typeSymbol);\n}\n/**\n * A Type is either a BasicType of a CompositeType\n */\n\n\nclass Type {\n  /**\n   * Symbols used to track the identity of a type\n   *\n   * Used by various isFooType functions\n   */\n  constructor() {\n    _defineProperty(this, \"_typeSymbols\", void 0);\n\n    this._typeSymbols = new Set();\n  }\n\n  /**\n   * Valid value assertion\n   */\n  assertValidValue(value) {\n    return this.struct_assertValidValue(value);\n  }\n  /**\n   * Default constructor\n   */\n\n\n  defaultValue() {\n    return this.struct_defaultValue();\n  }\n  /**\n   * Clone / copy\n   */\n\n\n  clone(value) {\n    return this.struct_clone(value);\n  }\n  /**\n   * Equality\n   */\n\n\n  equals(value1, value2) {\n    return this.struct_equals(value1, value2);\n  } // Serialization / Deserialization\n\n  /**\n   * Check if type has a variable number of elements (or subelements)\n   *\n   * For basic types, this is always false\n   */\n\n\n  /**\n   * Serialized byte length\n   */\n  size(value) {\n    return this.struct_getSerializedLength(value);\n  }\n  /**\n   * Low-level deserialization\n   */\n\n\n  fromBytes(data, start, end) {\n    return this.struct_deserializeFromBytes(data, start, end);\n  }\n  /**\n   * Deserialization\n   */\n\n\n  deserialize(data) {\n    return this.fromBytes(data, 0, data.length);\n  }\n  /**\n   * Low-level serialization\n   *\n   * Serializes to a pre-allocated Uint8Array\n   */\n\n\n  toBytes(value, output, offset) {\n    return this.struct_serializeToBytes(value, output, offset);\n  }\n  /**\n   * Serialization\n   */\n\n\n  serialize(value) {\n    const output = new Uint8Array(this.size(value));\n    this.toBytes(value, output, 0);\n    return output;\n  }\n  /**\n   * Merkleization\n   */\n\n\n  hashTreeRoot(value) {\n    return this.struct_hashTreeRoot(value);\n  }\n  /**\n   * Convert from JSON-serializable object\n   */\n\n\n  fromJson(data, options) {\n    return this.struct_convertFromJson(data, options);\n  }\n  /**\n   * Convert to JSON-serializable object\n   */\n\n\n  toJson(value, options) {\n    return this.struct_convertToJson(value, options);\n  }\n\n}\n\nexports.Type = Type;\n//# sourceMappingURL=type.js.map","module.exports = function (exec) {\n  try {\n    return !!exec();\n  } catch (e) {\n    return true;\n  }\n};\n","var dP = require('./_object-dp');\nvar createDesc = require('./_property-desc');\nmodule.exports = require('./_descriptors') ? function (object, key, value) {\n  return dP.f(object, key, createDesc(1, value));\n} : function (object, key, value) {\n  object[key] = value;\n  return object;\n};\n","// to indexed object, toObject with fallback for non-array-like ES3 strings\nvar IObject = require('./_iobject');\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return IObject(defined(it));\n};\n","// 7.1.15 ToLength\nvar toInteger = require('./_to-integer');\nvar min = Math.min;\nmodule.exports = function (it) {\n  return it > 0 ? min(toInteger(it), 0x1fffffffffffff) : 0; // pow(2, 53) - 1 == 9007199254740991\n};\n","// 7.1.13 ToObject(argument)\nvar defined = require('./_defined');\nmodule.exports = function (it) {\n  return Object(defined(it));\n};\n","var hasOwnProperty = {}.hasOwnProperty;\nmodule.exports = function (it, key) {\n  return hasOwnProperty.call(it, key);\n};\n","var isObject = require('./_is-object');\nmodule.exports = function (it) {\n  if (!isObject(it)) throw TypeError(it + ' is not an object!');\n  return it;\n};\n","module.exports = function (it) {\n  return typeof it === 'object' ? it !== null : typeof it === 'function';\n};\n","var id = 0;\nvar px = Math.random();\nmodule.exports = function (key) {\n  return 'Symbol('.concat(key === undefined ? '' : key, ')_', (++id + px).toString(36));\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toHexString = toHexString;\nexports.fromHexString = fromHexString;\nexports.byteArrayEquals = byteArrayEquals;\nexports.getByteBits = getByteBits;\n// Caching this info costs about ~1000 bytes and speeds up toHexString() by x6\nconst hexByByte = [];\n\nfunction toHexString(bytes) {\n  let hex = \"0x\";\n\n  for (const byte of bytes) {\n    if (!hexByByte[byte]) {\n      hexByByte[byte] = byte < 16 ? \"0\" + byte.toString(16) : byte.toString(16);\n    }\n\n    hex += hexByByte[byte];\n  }\n\n  return hex;\n}\n\nfunction fromHexString(hex) {\n  if (typeof hex !== \"string\") {\n    throw new Error(\"Expected hex string to be a string\");\n  }\n\n  if (hex.startsWith(\"0x\")) {\n    hex = hex.slice(2);\n  }\n\n  if (hex.length % 2 !== 0) {\n    throw new Error(\"Expected an even number of characters\");\n  }\n\n  const bytes = [];\n\n  for (let i = 0, len = hex.length; i < len; i += 2) {\n    const byte = parseInt(hex.slice(i, i + 2), 16);\n    bytes.push(byte);\n  }\n\n  return new Uint8Array(bytes);\n}\n\nfunction byteArrayEquals(a, b) {\n  if (a.length !== b.length) {\n    return false;\n  }\n\n  for (let i = 0; i < a.length; i++) {\n    if (a[i] !== b[i]) return false;\n  }\n\n  return true;\n}\n\nfunction getByteBits(target, offset) {\n  const byte = target[offset];\n\n  if (!byte) {\n    return [false, false, false, false, false, false, false, false];\n  }\n\n  const bits = Array.prototype.map.call(byte.toString(2).padStart(8, \"0\"), c => c === \"1\" ? true : false).reverse();\n  return bits;\n}\n//# sourceMappingURL=byteArray.js.map","var core = module.exports = { version: '2.6.12' };\nif (typeof __e == 'number') __e = core; // eslint-disable-line no-undef\n","module.exports = function (bitmap, value) {\n  return {\n    enumerable: !(bitmap & 1),\n    configurable: !(bitmap & 2),\n    writable: !(bitmap & 4),\n    value: value\n  };\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar has = require('./_has');\nvar SRC = require('./_uid')('src');\nvar $toString = require('./_function-to-string');\nvar TO_STRING = 'toString';\nvar TPL = ('' + $toString).split(TO_STRING);\n\nrequire('./_core').inspectSource = function (it) {\n  return $toString.call(it);\n};\n\n(module.exports = function (O, key, val, safe) {\n  var isFunction = typeof val == 'function';\n  if (isFunction) has(val, 'name') || hide(val, 'name', key);\n  if (O[key] === val) return;\n  if (isFunction) has(val, SRC) || hide(val, SRC, O[key] ? '' + O[key] : TPL.join(String(key)));\n  if (O === global) {\n    O[key] = val;\n  } else if (!safe) {\n    delete O[key];\n    hide(O, key, val);\n  } else if (O[key]) {\n    O[key] = val;\n  } else {\n    hide(O, key, val);\n  }\n// add fake Function#toString for correct work wrapped methods / constructors with methods like LoDash isNative\n})(Function.prototype, TO_STRING, function toString() {\n  return typeof this == 'function' && this[SRC] || $toString.call(this);\n});\n","module.exports = false;\n","// 19.1.2.14 / 15.2.3.14 Object.keys(O)\nvar $keys = require('./_object-keys-internal');\nvar enumBugKeys = require('./_enum-bug-keys');\n\nmodule.exports = Object.keys || function keys(O) {\n  return $keys(O, enumBugKeys);\n};\n","// 7.1.4 ToInteger\nvar ceil = Math.ceil;\nvar floor = Math.floor;\nmodule.exports = function (it) {\n  return isNaN(it = +it) ? 0 : (it > 0 ? floor : ceil)(it);\n};\n","module.exports = {};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _abstract = require(\"./abstract\");\n\nObject.keys(_abstract).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _abstract[key];\n    }\n  });\n});\n\nvar _boolean = require(\"./boolean\");\n\nObject.keys(_boolean).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _boolean[key];\n    }\n  });\n});\n\nvar _uint = require(\"./uint\");\n\nObject.keys(_uint).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _uint[key];\n    }\n  });\n});\n\nvar _wellKnown = require(\"./wellKnown\");\n\nObject.keys(_wellKnown).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _wellKnown[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.compose = exports.identity = exports.LeafNode = exports.BranchNode = exports.Node = void 0;\nconst hash_1 = require(\"./hash\");\nconst ERR_INVALID_TREE = \"Invalid tree\";\nconst ERR_NOT_IMPLEMENTED = \"Not implemented\";\nclass Node {\n    get root() {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n    isLeaf() {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n    get left() {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n    get right() {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    rebindLeft(left) {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n    // eslint-disable-next-line @typescript-eslint/no-unused-vars\n    rebindRight(right) {\n        throw new Error(ERR_NOT_IMPLEMENTED);\n    }\n}\nexports.Node = Node;\nclass BranchNode extends Node {\n    constructor(_left, _right) {\n        super();\n        this._left = _left;\n        this._right = _right;\n        this._root = null;\n        if (!_left || !_right)\n            throw new Error(ERR_INVALID_TREE);\n    }\n    get root() {\n        if (!this._root) {\n            this._root = hash_1.hash(this.left.root, this.right.root);\n        }\n        return this._root;\n    }\n    isLeaf() {\n        return false;\n    }\n    get left() {\n        return this._left;\n    }\n    set left(n) {\n        this._left = n;\n    }\n    get right() {\n        return this._right;\n    }\n    set right(n) {\n        this._right = n;\n    }\n    rebindLeft(left) {\n        return new BranchNode(left, this.right);\n    }\n    rebindRight(right) {\n        return new BranchNode(this.left, right);\n    }\n}\nexports.BranchNode = BranchNode;\nclass LeafNode extends Node {\n    constructor(_root) {\n        super();\n        this._root = _root;\n        if (_root.length !== 32)\n            throw new Error(ERR_INVALID_TREE);\n    }\n    get root() {\n        return this._root;\n    }\n    isLeaf() {\n        return true;\n    }\n}\nexports.LeafNode = LeafNode;\nfunction identity(n) {\n    return n;\n}\nexports.identity = identity;\nfunction compose(inner, outer) {\n    return function (n) {\n        return outer(inner(n));\n    };\n}\nexports.compose = compose;\n","var toInteger = require('./_to-integer');\nvar max = Math.max;\nvar min = Math.min;\nmodule.exports = function (index, length) {\n  index = toInteger(index);\n  return index < 0 ? max(index + length, 0) : min(index, length);\n};\n","// 19.1.2.7 / 15.2.3.4 Object.getOwnPropertyNames(O)\nvar $keys = require('./_object-keys-internal');\nvar hiddenKeys = require('./_enum-bug-keys').concat('length', 'prototype');\n\nexports.f = Object.getOwnPropertyNames || function getOwnPropertyNames(O) {\n  return $keys(O, hiddenKeys);\n};\n","\"use strict\";\nvar __createBinding = (this && this.__createBinding) || (Object.create ? (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    Object.defineProperty(o, k2, { enumerable: true, get: function() { return m[k]; } });\n}) : (function(o, m, k, k2) {\n    if (k2 === undefined) k2 = k;\n    o[k2] = m[k];\n}));\nvar __exportStar = (this && this.__exportStar) || function(m, exports) {\n    for (var p in m) if (p !== \"default\" && !Object.prototype.hasOwnProperty.call(exports, p)) __createBinding(exports, m, p);\n};\nObject.defineProperty(exports, \"__esModule\", { value: true });\n__exportStar(require(\"./gindex\"), exports);\n__exportStar(require(\"./hash\"), exports);\n__exportStar(require(\"./node\"), exports);\n__exportStar(require(\"./zeroNode\"), exports);\n__exportStar(require(\"./subtree\"), exports);\n__exportStar(require(\"./tree\"), exports);\n__exportStar(require(\"./proof\"), exports);\n","/*!\n * The buffer module from node.js, for the browser.\n *\n * @author   Feross Aboukhadijeh <http://feross.org>\n * @license  MIT\n */\n/* eslint-disable no-proto */\n\n'use strict'\n\nvar base64 = require('base64-js')\nvar ieee754 = require('ieee754')\nvar isArray = require('isarray')\n\nexports.Buffer = Buffer\nexports.SlowBuffer = SlowBuffer\nexports.INSPECT_MAX_BYTES = 50\n\n/**\n * If `Buffer.TYPED_ARRAY_SUPPORT`:\n *   === true    Use Uint8Array implementation (fastest)\n *   === false   Use Object implementation (most compatible, even IE6)\n *\n * Browsers that support typed arrays are IE 10+, Firefox 4+, Chrome 7+, Safari 5.1+,\n * Opera 11.6+, iOS 4.2+.\n *\n * Due to various browser bugs, sometimes the Object implementation will be used even\n * when the browser supports typed arrays.\n *\n * Note:\n *\n *   - Firefox 4-29 lacks support for adding new properties to `Uint8Array` instances,\n *     See: https://bugzilla.mozilla.org/show_bug.cgi?id=695438.\n *\n *   - Chrome 9-10 is missing the `TypedArray.prototype.subarray` function.\n *\n *   - IE10 has a broken `TypedArray.prototype.subarray` function which returns arrays of\n *     incorrect length in some situations.\n\n * We detect these buggy browsers and set `Buffer.TYPED_ARRAY_SUPPORT` to `false` so they\n * get the Object implementation, which is slower but behaves correctly.\n */\nBuffer.TYPED_ARRAY_SUPPORT = global.TYPED_ARRAY_SUPPORT !== undefined\n  ? global.TYPED_ARRAY_SUPPORT\n  : typedArraySupport()\n\n/*\n * Export kMaxLength after typed array support is determined.\n */\nexports.kMaxLength = kMaxLength()\n\nfunction typedArraySupport () {\n  try {\n    var arr = new Uint8Array(1)\n    arr.__proto__ = {__proto__: Uint8Array.prototype, foo: function () { return 42 }}\n    return arr.foo() === 42 && // typed array instances can be augmented\n        typeof arr.subarray === 'function' && // chrome 9-10 lack `subarray`\n        arr.subarray(1, 1).byteLength === 0 // ie10 has broken `subarray`\n  } catch (e) {\n    return false\n  }\n}\n\nfunction kMaxLength () {\n  return Buffer.TYPED_ARRAY_SUPPORT\n    ? 0x7fffffff\n    : 0x3fffffff\n}\n\nfunction createBuffer (that, length) {\n  if (kMaxLength() < length) {\n    throw new RangeError('Invalid typed array length')\n  }\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = new Uint8Array(length)\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    if (that === null) {\n      that = new Buffer(length)\n    }\n    that.length = length\n  }\n\n  return that\n}\n\n/**\n * The Buffer constructor returns instances of `Uint8Array` that have their\n * prototype changed to `Buffer.prototype`. Furthermore, `Buffer` is a subclass of\n * `Uint8Array`, so the returned instances will have all the node `Buffer` methods\n * and the `Uint8Array` methods. Square bracket notation works as expected -- it\n * returns a single octet.\n *\n * The `Uint8Array` prototype remains unmodified.\n */\n\nfunction Buffer (arg, encodingOrOffset, length) {\n  if (!Buffer.TYPED_ARRAY_SUPPORT && !(this instanceof Buffer)) {\n    return new Buffer(arg, encodingOrOffset, length)\n  }\n\n  // Common case.\n  if (typeof arg === 'number') {\n    if (typeof encodingOrOffset === 'string') {\n      throw new Error(\n        'If encoding is specified then the first argument must be a string'\n      )\n    }\n    return allocUnsafe(this, arg)\n  }\n  return from(this, arg, encodingOrOffset, length)\n}\n\nBuffer.poolSize = 8192 // not used by this implementation\n\n// TODO: Legacy, not needed anymore. Remove in next major version.\nBuffer._augment = function (arr) {\n  arr.__proto__ = Buffer.prototype\n  return arr\n}\n\nfunction from (that, value, encodingOrOffset, length) {\n  if (typeof value === 'number') {\n    throw new TypeError('\"value\" argument must not be a number')\n  }\n\n  if (typeof ArrayBuffer !== 'undefined' && value instanceof ArrayBuffer) {\n    return fromArrayBuffer(that, value, encodingOrOffset, length)\n  }\n\n  if (typeof value === 'string') {\n    return fromString(that, value, encodingOrOffset)\n  }\n\n  return fromObject(that, value)\n}\n\n/**\n * Functionally equivalent to Buffer(arg, encoding) but throws a TypeError\n * if value is a number.\n * Buffer.from(str[, encoding])\n * Buffer.from(array)\n * Buffer.from(buffer)\n * Buffer.from(arrayBuffer[, byteOffset[, length]])\n **/\nBuffer.from = function (value, encodingOrOffset, length) {\n  return from(null, value, encodingOrOffset, length)\n}\n\nif (Buffer.TYPED_ARRAY_SUPPORT) {\n  Buffer.prototype.__proto__ = Uint8Array.prototype\n  Buffer.__proto__ = Uint8Array\n  if (typeof Symbol !== 'undefined' && Symbol.species &&\n      Buffer[Symbol.species] === Buffer) {\n    // Fix subarray() in ES2016. See: https://github.com/feross/buffer/pull/97\n    Object.defineProperty(Buffer, Symbol.species, {\n      value: null,\n      configurable: true\n    })\n  }\n}\n\nfunction assertSize (size) {\n  if (typeof size !== 'number') {\n    throw new TypeError('\"size\" argument must be a number')\n  } else if (size < 0) {\n    throw new RangeError('\"size\" argument must not be negative')\n  }\n}\n\nfunction alloc (that, size, fill, encoding) {\n  assertSize(size)\n  if (size <= 0) {\n    return createBuffer(that, size)\n  }\n  if (fill !== undefined) {\n    // Only pay attention to encoding if it's a string. This\n    // prevents accidentally sending in a number that would\n    // be interpretted as a start offset.\n    return typeof encoding === 'string'\n      ? createBuffer(that, size).fill(fill, encoding)\n      : createBuffer(that, size).fill(fill)\n  }\n  return createBuffer(that, size)\n}\n\n/**\n * Creates a new filled Buffer instance.\n * alloc(size[, fill[, encoding]])\n **/\nBuffer.alloc = function (size, fill, encoding) {\n  return alloc(null, size, fill, encoding)\n}\n\nfunction allocUnsafe (that, size) {\n  assertSize(size)\n  that = createBuffer(that, size < 0 ? 0 : checked(size) | 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) {\n    for (var i = 0; i < size; ++i) {\n      that[i] = 0\n    }\n  }\n  return that\n}\n\n/**\n * Equivalent to Buffer(num), by default creates a non-zero-filled Buffer instance.\n * */\nBuffer.allocUnsafe = function (size) {\n  return allocUnsafe(null, size)\n}\n/**\n * Equivalent to SlowBuffer(num), by default creates a non-zero-filled Buffer instance.\n */\nBuffer.allocUnsafeSlow = function (size) {\n  return allocUnsafe(null, size)\n}\n\nfunction fromString (that, string, encoding) {\n  if (typeof encoding !== 'string' || encoding === '') {\n    encoding = 'utf8'\n  }\n\n  if (!Buffer.isEncoding(encoding)) {\n    throw new TypeError('\"encoding\" must be a valid string encoding')\n  }\n\n  var length = byteLength(string, encoding) | 0\n  that = createBuffer(that, length)\n\n  var actual = that.write(string, encoding)\n\n  if (actual !== length) {\n    // Writing a hex string, for example, that contains invalid characters will\n    // cause everything after the first invalid character to be ignored. (e.g.\n    // 'abxxcd' will be treated as 'ab')\n    that = that.slice(0, actual)\n  }\n\n  return that\n}\n\nfunction fromArrayLike (that, array) {\n  var length = array.length < 0 ? 0 : checked(array.length) | 0\n  that = createBuffer(that, length)\n  for (var i = 0; i < length; i += 1) {\n    that[i] = array[i] & 255\n  }\n  return that\n}\n\nfunction fromArrayBuffer (that, array, byteOffset, length) {\n  array.byteLength // this throws if `array` is not a valid ArrayBuffer\n\n  if (byteOffset < 0 || array.byteLength < byteOffset) {\n    throw new RangeError('\\'offset\\' is out of bounds')\n  }\n\n  if (array.byteLength < byteOffset + (length || 0)) {\n    throw new RangeError('\\'length\\' is out of bounds')\n  }\n\n  if (byteOffset === undefined && length === undefined) {\n    array = new Uint8Array(array)\n  } else if (length === undefined) {\n    array = new Uint8Array(array, byteOffset)\n  } else {\n    array = new Uint8Array(array, byteOffset, length)\n  }\n\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    // Return an augmented `Uint8Array` instance, for best performance\n    that = array\n    that.__proto__ = Buffer.prototype\n  } else {\n    // Fallback: Return an object instance of the Buffer class\n    that = fromArrayLike(that, array)\n  }\n  return that\n}\n\nfunction fromObject (that, obj) {\n  if (Buffer.isBuffer(obj)) {\n    var len = checked(obj.length) | 0\n    that = createBuffer(that, len)\n\n    if (that.length === 0) {\n      return that\n    }\n\n    obj.copy(that, 0, 0, len)\n    return that\n  }\n\n  if (obj) {\n    if ((typeof ArrayBuffer !== 'undefined' &&\n        obj.buffer instanceof ArrayBuffer) || 'length' in obj) {\n      if (typeof obj.length !== 'number' || isnan(obj.length)) {\n        return createBuffer(that, 0)\n      }\n      return fromArrayLike(that, obj)\n    }\n\n    if (obj.type === 'Buffer' && isArray(obj.data)) {\n      return fromArrayLike(that, obj.data)\n    }\n  }\n\n  throw new TypeError('First argument must be a string, Buffer, ArrayBuffer, Array, or array-like object.')\n}\n\nfunction checked (length) {\n  // Note: cannot use `length < kMaxLength()` here because that fails when\n  // length is NaN (which is otherwise coerced to zero.)\n  if (length >= kMaxLength()) {\n    throw new RangeError('Attempt to allocate Buffer larger than maximum ' +\n                         'size: 0x' + kMaxLength().toString(16) + ' bytes')\n  }\n  return length | 0\n}\n\nfunction SlowBuffer (length) {\n  if (+length != length) { // eslint-disable-line eqeqeq\n    length = 0\n  }\n  return Buffer.alloc(+length)\n}\n\nBuffer.isBuffer = function isBuffer (b) {\n  return !!(b != null && b._isBuffer)\n}\n\nBuffer.compare = function compare (a, b) {\n  if (!Buffer.isBuffer(a) || !Buffer.isBuffer(b)) {\n    throw new TypeError('Arguments must be Buffers')\n  }\n\n  if (a === b) return 0\n\n  var x = a.length\n  var y = b.length\n\n  for (var i = 0, len = Math.min(x, y); i < len; ++i) {\n    if (a[i] !== b[i]) {\n      x = a[i]\n      y = b[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\nBuffer.isEncoding = function isEncoding (encoding) {\n  switch (String(encoding).toLowerCase()) {\n    case 'hex':\n    case 'utf8':\n    case 'utf-8':\n    case 'ascii':\n    case 'latin1':\n    case 'binary':\n    case 'base64':\n    case 'ucs2':\n    case 'ucs-2':\n    case 'utf16le':\n    case 'utf-16le':\n      return true\n    default:\n      return false\n  }\n}\n\nBuffer.concat = function concat (list, length) {\n  if (!isArray(list)) {\n    throw new TypeError('\"list\" argument must be an Array of Buffers')\n  }\n\n  if (list.length === 0) {\n    return Buffer.alloc(0)\n  }\n\n  var i\n  if (length === undefined) {\n    length = 0\n    for (i = 0; i < list.length; ++i) {\n      length += list[i].length\n    }\n  }\n\n  var buffer = Buffer.allocUnsafe(length)\n  var pos = 0\n  for (i = 0; i < list.length; ++i) {\n    var buf = list[i]\n    if (!Buffer.isBuffer(buf)) {\n      throw new TypeError('\"list\" argument must be an Array of Buffers')\n    }\n    buf.copy(buffer, pos)\n    pos += buf.length\n  }\n  return buffer\n}\n\nfunction byteLength (string, encoding) {\n  if (Buffer.isBuffer(string)) {\n    return string.length\n  }\n  if (typeof ArrayBuffer !== 'undefined' && typeof ArrayBuffer.isView === 'function' &&\n      (ArrayBuffer.isView(string) || string instanceof ArrayBuffer)) {\n    return string.byteLength\n  }\n  if (typeof string !== 'string') {\n    string = '' + string\n  }\n\n  var len = string.length\n  if (len === 0) return 0\n\n  // Use a for loop to avoid recursion\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'ascii':\n      case 'latin1':\n      case 'binary':\n        return len\n      case 'utf8':\n      case 'utf-8':\n      case undefined:\n        return utf8ToBytes(string).length\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return len * 2\n      case 'hex':\n        return len >>> 1\n      case 'base64':\n        return base64ToBytes(string).length\n      default:\n        if (loweredCase) return utf8ToBytes(string).length // assume utf8\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\nBuffer.byteLength = byteLength\n\nfunction slowToString (encoding, start, end) {\n  var loweredCase = false\n\n  // No need to verify that \"this.length <= MAX_UINT32\" since it's a read-only\n  // property of a typed array.\n\n  // This behaves neither like String nor Uint8Array in that we set start/end\n  // to their upper/lower bounds if the value passed is out of range.\n  // undefined is handled specially as per ECMA-262 6th Edition,\n  // Section 13.3.3.7 Runtime Semantics: KeyedBindingInitialization.\n  if (start === undefined || start < 0) {\n    start = 0\n  }\n  // Return early if start > this.length. Done here to prevent potential uint32\n  // coercion fail below.\n  if (start > this.length) {\n    return ''\n  }\n\n  if (end === undefined || end > this.length) {\n    end = this.length\n  }\n\n  if (end <= 0) {\n    return ''\n  }\n\n  // Force coersion to uint32. This will also coerce falsey/NaN values to 0.\n  end >>>= 0\n  start >>>= 0\n\n  if (end <= start) {\n    return ''\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  while (true) {\n    switch (encoding) {\n      case 'hex':\n        return hexSlice(this, start, end)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Slice(this, start, end)\n\n      case 'ascii':\n        return asciiSlice(this, start, end)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Slice(this, start, end)\n\n      case 'base64':\n        return base64Slice(this, start, end)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return utf16leSlice(this, start, end)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = (encoding + '').toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\n// The property is used by `Buffer.isBuffer` and `is-buffer` (in Safari 5-7) to detect\n// Buffer instances.\nBuffer.prototype._isBuffer = true\n\nfunction swap (b, n, m) {\n  var i = b[n]\n  b[n] = b[m]\n  b[m] = i\n}\n\nBuffer.prototype.swap16 = function swap16 () {\n  var len = this.length\n  if (len % 2 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 16-bits')\n  }\n  for (var i = 0; i < len; i += 2) {\n    swap(this, i, i + 1)\n  }\n  return this\n}\n\nBuffer.prototype.swap32 = function swap32 () {\n  var len = this.length\n  if (len % 4 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 32-bits')\n  }\n  for (var i = 0; i < len; i += 4) {\n    swap(this, i, i + 3)\n    swap(this, i + 1, i + 2)\n  }\n  return this\n}\n\nBuffer.prototype.swap64 = function swap64 () {\n  var len = this.length\n  if (len % 8 !== 0) {\n    throw new RangeError('Buffer size must be a multiple of 64-bits')\n  }\n  for (var i = 0; i < len; i += 8) {\n    swap(this, i, i + 7)\n    swap(this, i + 1, i + 6)\n    swap(this, i + 2, i + 5)\n    swap(this, i + 3, i + 4)\n  }\n  return this\n}\n\nBuffer.prototype.toString = function toString () {\n  var length = this.length | 0\n  if (length === 0) return ''\n  if (arguments.length === 0) return utf8Slice(this, 0, length)\n  return slowToString.apply(this, arguments)\n}\n\nBuffer.prototype.equals = function equals (b) {\n  if (!Buffer.isBuffer(b)) throw new TypeError('Argument must be a Buffer')\n  if (this === b) return true\n  return Buffer.compare(this, b) === 0\n}\n\nBuffer.prototype.inspect = function inspect () {\n  var str = ''\n  var max = exports.INSPECT_MAX_BYTES\n  if (this.length > 0) {\n    str = this.toString('hex', 0, max).match(/.{2}/g).join(' ')\n    if (this.length > max) str += ' ... '\n  }\n  return '<Buffer ' + str + '>'\n}\n\nBuffer.prototype.compare = function compare (target, start, end, thisStart, thisEnd) {\n  if (!Buffer.isBuffer(target)) {\n    throw new TypeError('Argument must be a Buffer')\n  }\n\n  if (start === undefined) {\n    start = 0\n  }\n  if (end === undefined) {\n    end = target ? target.length : 0\n  }\n  if (thisStart === undefined) {\n    thisStart = 0\n  }\n  if (thisEnd === undefined) {\n    thisEnd = this.length\n  }\n\n  if (start < 0 || end > target.length || thisStart < 0 || thisEnd > this.length) {\n    throw new RangeError('out of range index')\n  }\n\n  if (thisStart >= thisEnd && start >= end) {\n    return 0\n  }\n  if (thisStart >= thisEnd) {\n    return -1\n  }\n  if (start >= end) {\n    return 1\n  }\n\n  start >>>= 0\n  end >>>= 0\n  thisStart >>>= 0\n  thisEnd >>>= 0\n\n  if (this === target) return 0\n\n  var x = thisEnd - thisStart\n  var y = end - start\n  var len = Math.min(x, y)\n\n  var thisCopy = this.slice(thisStart, thisEnd)\n  var targetCopy = target.slice(start, end)\n\n  for (var i = 0; i < len; ++i) {\n    if (thisCopy[i] !== targetCopy[i]) {\n      x = thisCopy[i]\n      y = targetCopy[i]\n      break\n    }\n  }\n\n  if (x < y) return -1\n  if (y < x) return 1\n  return 0\n}\n\n// Finds either the first index of `val` in `buffer` at offset >= `byteOffset`,\n// OR the last index of `val` in `buffer` at offset <= `byteOffset`.\n//\n// Arguments:\n// - buffer - a Buffer to search\n// - val - a string, Buffer, or number\n// - byteOffset - an index into `buffer`; will be clamped to an int32\n// - encoding - an optional encoding, relevant is val is a string\n// - dir - true for indexOf, false for lastIndexOf\nfunction bidirectionalIndexOf (buffer, val, byteOffset, encoding, dir) {\n  // Empty buffer means no match\n  if (buffer.length === 0) return -1\n\n  // Normalize byteOffset\n  if (typeof byteOffset === 'string') {\n    encoding = byteOffset\n    byteOffset = 0\n  } else if (byteOffset > 0x7fffffff) {\n    byteOffset = 0x7fffffff\n  } else if (byteOffset < -0x80000000) {\n    byteOffset = -0x80000000\n  }\n  byteOffset = +byteOffset  // Coerce to Number.\n  if (isNaN(byteOffset)) {\n    // byteOffset: it it's undefined, null, NaN, \"foo\", etc, search whole buffer\n    byteOffset = dir ? 0 : (buffer.length - 1)\n  }\n\n  // Normalize byteOffset: negative offsets start from the end of the buffer\n  if (byteOffset < 0) byteOffset = buffer.length + byteOffset\n  if (byteOffset >= buffer.length) {\n    if (dir) return -1\n    else byteOffset = buffer.length - 1\n  } else if (byteOffset < 0) {\n    if (dir) byteOffset = 0\n    else return -1\n  }\n\n  // Normalize val\n  if (typeof val === 'string') {\n    val = Buffer.from(val, encoding)\n  }\n\n  // Finally, search either indexOf (if dir is true) or lastIndexOf\n  if (Buffer.isBuffer(val)) {\n    // Special case: looking for empty string/buffer always fails\n    if (val.length === 0) {\n      return -1\n    }\n    return arrayIndexOf(buffer, val, byteOffset, encoding, dir)\n  } else if (typeof val === 'number') {\n    val = val & 0xFF // Search for a byte value [0-255]\n    if (Buffer.TYPED_ARRAY_SUPPORT &&\n        typeof Uint8Array.prototype.indexOf === 'function') {\n      if (dir) {\n        return Uint8Array.prototype.indexOf.call(buffer, val, byteOffset)\n      } else {\n        return Uint8Array.prototype.lastIndexOf.call(buffer, val, byteOffset)\n      }\n    }\n    return arrayIndexOf(buffer, [ val ], byteOffset, encoding, dir)\n  }\n\n  throw new TypeError('val must be string, number or Buffer')\n}\n\nfunction arrayIndexOf (arr, val, byteOffset, encoding, dir) {\n  var indexSize = 1\n  var arrLength = arr.length\n  var valLength = val.length\n\n  if (encoding !== undefined) {\n    encoding = String(encoding).toLowerCase()\n    if (encoding === 'ucs2' || encoding === 'ucs-2' ||\n        encoding === 'utf16le' || encoding === 'utf-16le') {\n      if (arr.length < 2 || val.length < 2) {\n        return -1\n      }\n      indexSize = 2\n      arrLength /= 2\n      valLength /= 2\n      byteOffset /= 2\n    }\n  }\n\n  function read (buf, i) {\n    if (indexSize === 1) {\n      return buf[i]\n    } else {\n      return buf.readUInt16BE(i * indexSize)\n    }\n  }\n\n  var i\n  if (dir) {\n    var foundIndex = -1\n    for (i = byteOffset; i < arrLength; i++) {\n      if (read(arr, i) === read(val, foundIndex === -1 ? 0 : i - foundIndex)) {\n        if (foundIndex === -1) foundIndex = i\n        if (i - foundIndex + 1 === valLength) return foundIndex * indexSize\n      } else {\n        if (foundIndex !== -1) i -= i - foundIndex\n        foundIndex = -1\n      }\n    }\n  } else {\n    if (byteOffset + valLength > arrLength) byteOffset = arrLength - valLength\n    for (i = byteOffset; i >= 0; i--) {\n      var found = true\n      for (var j = 0; j < valLength; j++) {\n        if (read(arr, i + j) !== read(val, j)) {\n          found = false\n          break\n        }\n      }\n      if (found) return i\n    }\n  }\n\n  return -1\n}\n\nBuffer.prototype.includes = function includes (val, byteOffset, encoding) {\n  return this.indexOf(val, byteOffset, encoding) !== -1\n}\n\nBuffer.prototype.indexOf = function indexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, true)\n}\n\nBuffer.prototype.lastIndexOf = function lastIndexOf (val, byteOffset, encoding) {\n  return bidirectionalIndexOf(this, val, byteOffset, encoding, false)\n}\n\nfunction hexWrite (buf, string, offset, length) {\n  offset = Number(offset) || 0\n  var remaining = buf.length - offset\n  if (!length) {\n    length = remaining\n  } else {\n    length = Number(length)\n    if (length > remaining) {\n      length = remaining\n    }\n  }\n\n  // must be an even number of digits\n  var strLen = string.length\n  if (strLen % 2 !== 0) throw new TypeError('Invalid hex string')\n\n  if (length > strLen / 2) {\n    length = strLen / 2\n  }\n  for (var i = 0; i < length; ++i) {\n    var parsed = parseInt(string.substr(i * 2, 2), 16)\n    if (isNaN(parsed)) return i\n    buf[offset + i] = parsed\n  }\n  return i\n}\n\nfunction utf8Write (buf, string, offset, length) {\n  return blitBuffer(utf8ToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nfunction asciiWrite (buf, string, offset, length) {\n  return blitBuffer(asciiToBytes(string), buf, offset, length)\n}\n\nfunction latin1Write (buf, string, offset, length) {\n  return asciiWrite(buf, string, offset, length)\n}\n\nfunction base64Write (buf, string, offset, length) {\n  return blitBuffer(base64ToBytes(string), buf, offset, length)\n}\n\nfunction ucs2Write (buf, string, offset, length) {\n  return blitBuffer(utf16leToBytes(string, buf.length - offset), buf, offset, length)\n}\n\nBuffer.prototype.write = function write (string, offset, length, encoding) {\n  // Buffer#write(string)\n  if (offset === undefined) {\n    encoding = 'utf8'\n    length = this.length\n    offset = 0\n  // Buffer#write(string, encoding)\n  } else if (length === undefined && typeof offset === 'string') {\n    encoding = offset\n    length = this.length\n    offset = 0\n  // Buffer#write(string, offset[, length][, encoding])\n  } else if (isFinite(offset)) {\n    offset = offset | 0\n    if (isFinite(length)) {\n      length = length | 0\n      if (encoding === undefined) encoding = 'utf8'\n    } else {\n      encoding = length\n      length = undefined\n    }\n  // legacy write(string, encoding, offset, length) - remove in v0.13\n  } else {\n    throw new Error(\n      'Buffer.write(string, encoding, offset[, length]) is no longer supported'\n    )\n  }\n\n  var remaining = this.length - offset\n  if (length === undefined || length > remaining) length = remaining\n\n  if ((string.length > 0 && (length < 0 || offset < 0)) || offset > this.length) {\n    throw new RangeError('Attempt to write outside buffer bounds')\n  }\n\n  if (!encoding) encoding = 'utf8'\n\n  var loweredCase = false\n  for (;;) {\n    switch (encoding) {\n      case 'hex':\n        return hexWrite(this, string, offset, length)\n\n      case 'utf8':\n      case 'utf-8':\n        return utf8Write(this, string, offset, length)\n\n      case 'ascii':\n        return asciiWrite(this, string, offset, length)\n\n      case 'latin1':\n      case 'binary':\n        return latin1Write(this, string, offset, length)\n\n      case 'base64':\n        // Warning: maxLength not taken into account in base64Write\n        return base64Write(this, string, offset, length)\n\n      case 'ucs2':\n      case 'ucs-2':\n      case 'utf16le':\n      case 'utf-16le':\n        return ucs2Write(this, string, offset, length)\n\n      default:\n        if (loweredCase) throw new TypeError('Unknown encoding: ' + encoding)\n        encoding = ('' + encoding).toLowerCase()\n        loweredCase = true\n    }\n  }\n}\n\nBuffer.prototype.toJSON = function toJSON () {\n  return {\n    type: 'Buffer',\n    data: Array.prototype.slice.call(this._arr || this, 0)\n  }\n}\n\nfunction base64Slice (buf, start, end) {\n  if (start === 0 && end === buf.length) {\n    return base64.fromByteArray(buf)\n  } else {\n    return base64.fromByteArray(buf.slice(start, end))\n  }\n}\n\nfunction utf8Slice (buf, start, end) {\n  end = Math.min(buf.length, end)\n  var res = []\n\n  var i = start\n  while (i < end) {\n    var firstByte = buf[i]\n    var codePoint = null\n    var bytesPerSequence = (firstByte > 0xEF) ? 4\n      : (firstByte > 0xDF) ? 3\n      : (firstByte > 0xBF) ? 2\n      : 1\n\n    if (i + bytesPerSequence <= end) {\n      var secondByte, thirdByte, fourthByte, tempCodePoint\n\n      switch (bytesPerSequence) {\n        case 1:\n          if (firstByte < 0x80) {\n            codePoint = firstByte\n          }\n          break\n        case 2:\n          secondByte = buf[i + 1]\n          if ((secondByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0x1F) << 0x6 | (secondByte & 0x3F)\n            if (tempCodePoint > 0x7F) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 3:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0xC | (secondByte & 0x3F) << 0x6 | (thirdByte & 0x3F)\n            if (tempCodePoint > 0x7FF && (tempCodePoint < 0xD800 || tempCodePoint > 0xDFFF)) {\n              codePoint = tempCodePoint\n            }\n          }\n          break\n        case 4:\n          secondByte = buf[i + 1]\n          thirdByte = buf[i + 2]\n          fourthByte = buf[i + 3]\n          if ((secondByte & 0xC0) === 0x80 && (thirdByte & 0xC0) === 0x80 && (fourthByte & 0xC0) === 0x80) {\n            tempCodePoint = (firstByte & 0xF) << 0x12 | (secondByte & 0x3F) << 0xC | (thirdByte & 0x3F) << 0x6 | (fourthByte & 0x3F)\n            if (tempCodePoint > 0xFFFF && tempCodePoint < 0x110000) {\n              codePoint = tempCodePoint\n            }\n          }\n      }\n    }\n\n    if (codePoint === null) {\n      // we did not generate a valid codePoint so insert a\n      // replacement char (U+FFFD) and advance only 1 byte\n      codePoint = 0xFFFD\n      bytesPerSequence = 1\n    } else if (codePoint > 0xFFFF) {\n      // encode to utf16 (surrogate pair dance)\n      codePoint -= 0x10000\n      res.push(codePoint >>> 10 & 0x3FF | 0xD800)\n      codePoint = 0xDC00 | codePoint & 0x3FF\n    }\n\n    res.push(codePoint)\n    i += bytesPerSequence\n  }\n\n  return decodeCodePointsArray(res)\n}\n\n// Based on http://stackoverflow.com/a/22747272/680742, the browser with\n// the lowest limit is Chrome, with 0x10000 args.\n// We go 1 magnitude less, for safety\nvar MAX_ARGUMENTS_LENGTH = 0x1000\n\nfunction decodeCodePointsArray (codePoints) {\n  var len = codePoints.length\n  if (len <= MAX_ARGUMENTS_LENGTH) {\n    return String.fromCharCode.apply(String, codePoints) // avoid extra slice()\n  }\n\n  // Decode in chunks to avoid \"call stack size exceeded\".\n  var res = ''\n  var i = 0\n  while (i < len) {\n    res += String.fromCharCode.apply(\n      String,\n      codePoints.slice(i, i += MAX_ARGUMENTS_LENGTH)\n    )\n  }\n  return res\n}\n\nfunction asciiSlice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i] & 0x7F)\n  }\n  return ret\n}\n\nfunction latin1Slice (buf, start, end) {\n  var ret = ''\n  end = Math.min(buf.length, end)\n\n  for (var i = start; i < end; ++i) {\n    ret += String.fromCharCode(buf[i])\n  }\n  return ret\n}\n\nfunction hexSlice (buf, start, end) {\n  var len = buf.length\n\n  if (!start || start < 0) start = 0\n  if (!end || end < 0 || end > len) end = len\n\n  var out = ''\n  for (var i = start; i < end; ++i) {\n    out += toHex(buf[i])\n  }\n  return out\n}\n\nfunction utf16leSlice (buf, start, end) {\n  var bytes = buf.slice(start, end)\n  var res = ''\n  for (var i = 0; i < bytes.length; i += 2) {\n    res += String.fromCharCode(bytes[i] + bytes[i + 1] * 256)\n  }\n  return res\n}\n\nBuffer.prototype.slice = function slice (start, end) {\n  var len = this.length\n  start = ~~start\n  end = end === undefined ? len : ~~end\n\n  if (start < 0) {\n    start += len\n    if (start < 0) start = 0\n  } else if (start > len) {\n    start = len\n  }\n\n  if (end < 0) {\n    end += len\n    if (end < 0) end = 0\n  } else if (end > len) {\n    end = len\n  }\n\n  if (end < start) end = start\n\n  var newBuf\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    newBuf = this.subarray(start, end)\n    newBuf.__proto__ = Buffer.prototype\n  } else {\n    var sliceLen = end - start\n    newBuf = new Buffer(sliceLen, undefined)\n    for (var i = 0; i < sliceLen; ++i) {\n      newBuf[i] = this[i + start]\n    }\n  }\n\n  return newBuf\n}\n\n/*\n * Need to make sure that buffer isn't trying to write out of bounds.\n */\nfunction checkOffset (offset, ext, length) {\n  if ((offset % 1) !== 0 || offset < 0) throw new RangeError('offset is not uint')\n  if (offset + ext > length) throw new RangeError('Trying to access beyond buffer length')\n}\n\nBuffer.prototype.readUIntLE = function readUIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUIntBE = function readUIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    checkOffset(offset, byteLength, this.length)\n  }\n\n  var val = this[offset + --byteLength]\n  var mul = 1\n  while (byteLength > 0 && (mul *= 0x100)) {\n    val += this[offset + --byteLength] * mul\n  }\n\n  return val\n}\n\nBuffer.prototype.readUInt8 = function readUInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  return this[offset]\n}\n\nBuffer.prototype.readUInt16LE = function readUInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return this[offset] | (this[offset + 1] << 8)\n}\n\nBuffer.prototype.readUInt16BE = function readUInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  return (this[offset] << 8) | this[offset + 1]\n}\n\nBuffer.prototype.readUInt32LE = function readUInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return ((this[offset]) |\n      (this[offset + 1] << 8) |\n      (this[offset + 2] << 16)) +\n      (this[offset + 3] * 0x1000000)\n}\n\nBuffer.prototype.readUInt32BE = function readUInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] * 0x1000000) +\n    ((this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    this[offset + 3])\n}\n\nBuffer.prototype.readIntLE = function readIntLE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var val = this[offset]\n  var mul = 1\n  var i = 0\n  while (++i < byteLength && (mul *= 0x100)) {\n    val += this[offset + i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readIntBE = function readIntBE (offset, byteLength, noAssert) {\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) checkOffset(offset, byteLength, this.length)\n\n  var i = byteLength\n  var mul = 1\n  var val = this[offset + --i]\n  while (i > 0 && (mul *= 0x100)) {\n    val += this[offset + --i] * mul\n  }\n  mul *= 0x80\n\n  if (val >= mul) val -= Math.pow(2, 8 * byteLength)\n\n  return val\n}\n\nBuffer.prototype.readInt8 = function readInt8 (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 1, this.length)\n  if (!(this[offset] & 0x80)) return (this[offset])\n  return ((0xff - this[offset] + 1) * -1)\n}\n\nBuffer.prototype.readInt16LE = function readInt16LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset] | (this[offset + 1] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt16BE = function readInt16BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 2, this.length)\n  var val = this[offset + 1] | (this[offset] << 8)\n  return (val & 0x8000) ? val | 0xFFFF0000 : val\n}\n\nBuffer.prototype.readInt32LE = function readInt32LE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset]) |\n    (this[offset + 1] << 8) |\n    (this[offset + 2] << 16) |\n    (this[offset + 3] << 24)\n}\n\nBuffer.prototype.readInt32BE = function readInt32BE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n\n  return (this[offset] << 24) |\n    (this[offset + 1] << 16) |\n    (this[offset + 2] << 8) |\n    (this[offset + 3])\n}\n\nBuffer.prototype.readFloatLE = function readFloatLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, true, 23, 4)\n}\n\nBuffer.prototype.readFloatBE = function readFloatBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 4, this.length)\n  return ieee754.read(this, offset, false, 23, 4)\n}\n\nBuffer.prototype.readDoubleLE = function readDoubleLE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, true, 52, 8)\n}\n\nBuffer.prototype.readDoubleBE = function readDoubleBE (offset, noAssert) {\n  if (!noAssert) checkOffset(offset, 8, this.length)\n  return ieee754.read(this, offset, false, 52, 8)\n}\n\nfunction checkInt (buf, value, offset, ext, max, min) {\n  if (!Buffer.isBuffer(buf)) throw new TypeError('\"buffer\" argument must be a Buffer instance')\n  if (value > max || value < min) throw new RangeError('\"value\" argument is out of bounds')\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n}\n\nBuffer.prototype.writeUIntLE = function writeUIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var mul = 1\n  var i = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUIntBE = function writeUIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  byteLength = byteLength | 0\n  if (!noAssert) {\n    var maxBytes = Math.pow(2, 8 * byteLength) - 1\n    checkInt(this, value, offset, byteLength, maxBytes, 0)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    this[offset + i] = (value / mul) & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeUInt8 = function writeUInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0xff, 0)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nfunction objectWriteUInt16 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 2); i < j; ++i) {\n    buf[offset + i] = (value & (0xff << (8 * (littleEndian ? i : 1 - i)))) >>>\n      (littleEndian ? i : 1 - i) * 8\n  }\n}\n\nBuffer.prototype.writeUInt16LE = function writeUInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeUInt16BE = function writeUInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0xffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nfunction objectWriteUInt32 (buf, value, offset, littleEndian) {\n  if (value < 0) value = 0xffffffff + value + 1\n  for (var i = 0, j = Math.min(buf.length - offset, 4); i < j; ++i) {\n    buf[offset + i] = (value >>> (littleEndian ? i : 3 - i) * 8) & 0xff\n  }\n}\n\nBuffer.prototype.writeUInt32LE = function writeUInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset + 3] = (value >>> 24)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 1] = (value >>> 8)\n    this[offset] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeUInt32BE = function writeUInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0xffffffff, 0)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeIntLE = function writeIntLE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = 0\n  var mul = 1\n  var sub = 0\n  this[offset] = value & 0xFF\n  while (++i < byteLength && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i - 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeIntBE = function writeIntBE (value, offset, byteLength, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) {\n    var limit = Math.pow(2, 8 * byteLength - 1)\n\n    checkInt(this, value, offset, byteLength, limit - 1, -limit)\n  }\n\n  var i = byteLength - 1\n  var mul = 1\n  var sub = 0\n  this[offset + i] = value & 0xFF\n  while (--i >= 0 && (mul *= 0x100)) {\n    if (value < 0 && sub === 0 && this[offset + i + 1] !== 0) {\n      sub = 1\n    }\n    this[offset + i] = ((value / mul) >> 0) - sub & 0xFF\n  }\n\n  return offset + byteLength\n}\n\nBuffer.prototype.writeInt8 = function writeInt8 (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 1, 0x7f, -0x80)\n  if (!Buffer.TYPED_ARRAY_SUPPORT) value = Math.floor(value)\n  if (value < 0) value = 0xff + value + 1\n  this[offset] = (value & 0xff)\n  return offset + 1\n}\n\nBuffer.prototype.writeInt16LE = function writeInt16LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n  } else {\n    objectWriteUInt16(this, value, offset, true)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt16BE = function writeInt16BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 2, 0x7fff, -0x8000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 8)\n    this[offset + 1] = (value & 0xff)\n  } else {\n    objectWriteUInt16(this, value, offset, false)\n  }\n  return offset + 2\n}\n\nBuffer.prototype.writeInt32LE = function writeInt32LE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value & 0xff)\n    this[offset + 1] = (value >>> 8)\n    this[offset + 2] = (value >>> 16)\n    this[offset + 3] = (value >>> 24)\n  } else {\n    objectWriteUInt32(this, value, offset, true)\n  }\n  return offset + 4\n}\n\nBuffer.prototype.writeInt32BE = function writeInt32BE (value, offset, noAssert) {\n  value = +value\n  offset = offset | 0\n  if (!noAssert) checkInt(this, value, offset, 4, 0x7fffffff, -0x80000000)\n  if (value < 0) value = 0xffffffff + value + 1\n  if (Buffer.TYPED_ARRAY_SUPPORT) {\n    this[offset] = (value >>> 24)\n    this[offset + 1] = (value >>> 16)\n    this[offset + 2] = (value >>> 8)\n    this[offset + 3] = (value & 0xff)\n  } else {\n    objectWriteUInt32(this, value, offset, false)\n  }\n  return offset + 4\n}\n\nfunction checkIEEE754 (buf, value, offset, ext, max, min) {\n  if (offset + ext > buf.length) throw new RangeError('Index out of range')\n  if (offset < 0) throw new RangeError('Index out of range')\n}\n\nfunction writeFloat (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 4, 3.4028234663852886e+38, -3.4028234663852886e+38)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 23, 4)\n  return offset + 4\n}\n\nBuffer.prototype.writeFloatLE = function writeFloatLE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeFloatBE = function writeFloatBE (value, offset, noAssert) {\n  return writeFloat(this, value, offset, false, noAssert)\n}\n\nfunction writeDouble (buf, value, offset, littleEndian, noAssert) {\n  if (!noAssert) {\n    checkIEEE754(buf, value, offset, 8, 1.7976931348623157E+308, -1.7976931348623157E+308)\n  }\n  ieee754.write(buf, value, offset, littleEndian, 52, 8)\n  return offset + 8\n}\n\nBuffer.prototype.writeDoubleLE = function writeDoubleLE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, true, noAssert)\n}\n\nBuffer.prototype.writeDoubleBE = function writeDoubleBE (value, offset, noAssert) {\n  return writeDouble(this, value, offset, false, noAssert)\n}\n\n// copy(targetBuffer, targetStart=0, sourceStart=0, sourceEnd=buffer.length)\nBuffer.prototype.copy = function copy (target, targetStart, start, end) {\n  if (!start) start = 0\n  if (!end && end !== 0) end = this.length\n  if (targetStart >= target.length) targetStart = target.length\n  if (!targetStart) targetStart = 0\n  if (end > 0 && end < start) end = start\n\n  // Copy 0 bytes; we're done\n  if (end === start) return 0\n  if (target.length === 0 || this.length === 0) return 0\n\n  // Fatal error conditions\n  if (targetStart < 0) {\n    throw new RangeError('targetStart out of bounds')\n  }\n  if (start < 0 || start >= this.length) throw new RangeError('sourceStart out of bounds')\n  if (end < 0) throw new RangeError('sourceEnd out of bounds')\n\n  // Are we oob?\n  if (end > this.length) end = this.length\n  if (target.length - targetStart < end - start) {\n    end = target.length - targetStart + start\n  }\n\n  var len = end - start\n  var i\n\n  if (this === target && start < targetStart && targetStart < end) {\n    // descending copy from end\n    for (i = len - 1; i >= 0; --i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else if (len < 1000 || !Buffer.TYPED_ARRAY_SUPPORT) {\n    // ascending copy from start\n    for (i = 0; i < len; ++i) {\n      target[i + targetStart] = this[i + start]\n    }\n  } else {\n    Uint8Array.prototype.set.call(\n      target,\n      this.subarray(start, start + len),\n      targetStart\n    )\n  }\n\n  return len\n}\n\n// Usage:\n//    buffer.fill(number[, offset[, end]])\n//    buffer.fill(buffer[, offset[, end]])\n//    buffer.fill(string[, offset[, end]][, encoding])\nBuffer.prototype.fill = function fill (val, start, end, encoding) {\n  // Handle string cases:\n  if (typeof val === 'string') {\n    if (typeof start === 'string') {\n      encoding = start\n      start = 0\n      end = this.length\n    } else if (typeof end === 'string') {\n      encoding = end\n      end = this.length\n    }\n    if (val.length === 1) {\n      var code = val.charCodeAt(0)\n      if (code < 256) {\n        val = code\n      }\n    }\n    if (encoding !== undefined && typeof encoding !== 'string') {\n      throw new TypeError('encoding must be a string')\n    }\n    if (typeof encoding === 'string' && !Buffer.isEncoding(encoding)) {\n      throw new TypeError('Unknown encoding: ' + encoding)\n    }\n  } else if (typeof val === 'number') {\n    val = val & 255\n  }\n\n  // Invalid ranges are not set to a default, so can range check early.\n  if (start < 0 || this.length < start || this.length < end) {\n    throw new RangeError('Out of range index')\n  }\n\n  if (end <= start) {\n    return this\n  }\n\n  start = start >>> 0\n  end = end === undefined ? this.length : end >>> 0\n\n  if (!val) val = 0\n\n  var i\n  if (typeof val === 'number') {\n    for (i = start; i < end; ++i) {\n      this[i] = val\n    }\n  } else {\n    var bytes = Buffer.isBuffer(val)\n      ? val\n      : utf8ToBytes(new Buffer(val, encoding).toString())\n    var len = bytes.length\n    for (i = 0; i < end - start; ++i) {\n      this[i + start] = bytes[i % len]\n    }\n  }\n\n  return this\n}\n\n// HELPER FUNCTIONS\n// ================\n\nvar INVALID_BASE64_RE = /[^+\\/0-9A-Za-z-_]/g\n\nfunction base64clean (str) {\n  // Node strips out invalid characters like \\n and \\t from the string, base64-js does not\n  str = stringtrim(str).replace(INVALID_BASE64_RE, '')\n  // Node converts strings with length < 2 to ''\n  if (str.length < 2) return ''\n  // Node allows for non-padded base64 strings (missing trailing ===), base64-js does not\n  while (str.length % 4 !== 0) {\n    str = str + '='\n  }\n  return str\n}\n\nfunction stringtrim (str) {\n  if (str.trim) return str.trim()\n  return str.replace(/^\\s+|\\s+$/g, '')\n}\n\nfunction toHex (n) {\n  if (n < 16) return '0' + n.toString(16)\n  return n.toString(16)\n}\n\nfunction utf8ToBytes (string, units) {\n  units = units || Infinity\n  var codePoint\n  var length = string.length\n  var leadSurrogate = null\n  var bytes = []\n\n  for (var i = 0; i < length; ++i) {\n    codePoint = string.charCodeAt(i)\n\n    // is surrogate component\n    if (codePoint > 0xD7FF && codePoint < 0xE000) {\n      // last char was a lead\n      if (!leadSurrogate) {\n        // no lead yet\n        if (codePoint > 0xDBFF) {\n          // unexpected trail\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        } else if (i + 1 === length) {\n          // unpaired lead\n          if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n          continue\n        }\n\n        // valid lead\n        leadSurrogate = codePoint\n\n        continue\n      }\n\n      // 2 leads in a row\n      if (codePoint < 0xDC00) {\n        if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n        leadSurrogate = codePoint\n        continue\n      }\n\n      // valid surrogate pair\n      codePoint = (leadSurrogate - 0xD800 << 10 | codePoint - 0xDC00) + 0x10000\n    } else if (leadSurrogate) {\n      // valid bmp char, but last char was a lead\n      if ((units -= 3) > -1) bytes.push(0xEF, 0xBF, 0xBD)\n    }\n\n    leadSurrogate = null\n\n    // encode utf8\n    if (codePoint < 0x80) {\n      if ((units -= 1) < 0) break\n      bytes.push(codePoint)\n    } else if (codePoint < 0x800) {\n      if ((units -= 2) < 0) break\n      bytes.push(\n        codePoint >> 0x6 | 0xC0,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x10000) {\n      if ((units -= 3) < 0) break\n      bytes.push(\n        codePoint >> 0xC | 0xE0,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else if (codePoint < 0x110000) {\n      if ((units -= 4) < 0) break\n      bytes.push(\n        codePoint >> 0x12 | 0xF0,\n        codePoint >> 0xC & 0x3F | 0x80,\n        codePoint >> 0x6 & 0x3F | 0x80,\n        codePoint & 0x3F | 0x80\n      )\n    } else {\n      throw new Error('Invalid code point')\n    }\n  }\n\n  return bytes\n}\n\nfunction asciiToBytes (str) {\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    // Node's code seems to be doing this and not & 0x7F..\n    byteArray.push(str.charCodeAt(i) & 0xFF)\n  }\n  return byteArray\n}\n\nfunction utf16leToBytes (str, units) {\n  var c, hi, lo\n  var byteArray = []\n  for (var i = 0; i < str.length; ++i) {\n    if ((units -= 2) < 0) break\n\n    c = str.charCodeAt(i)\n    hi = c >> 8\n    lo = c % 256\n    byteArray.push(lo)\n    byteArray.push(hi)\n  }\n\n  return byteArray\n}\n\nfunction base64ToBytes (str) {\n  return base64.toByteArray(base64clean(str))\n}\n\nfunction blitBuffer (src, dst, offset, length) {\n  for (var i = 0; i < length; ++i) {\n    if ((i + offset >= dst.length) || (i >= src.length)) break\n    dst[i + offset] = src[i]\n  }\n  return i\n}\n\nfunction isnan (val) {\n  return val !== val // eslint-disable-line no-self-compare\n}\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  ssz: true\n};\nexports.ssz = void 0;\n\nvar _types = require(\"./types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n\nvar _ssz = _interopRequireWildcard(require(\"./sszTypes\"));\n\nexports.ssz = _ssz;\n\nvar _StringType = require(\"./StringType\");\n\nObject.keys(_StringType).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _StringType[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _StringType[key];\n    }\n  });\n});\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n//# sourceMappingURL=index.js.map","// 7.1.1 ToPrimitive(input [, PreferredType])\nvar isObject = require('./_is-object');\n// instead of the ES6 spec version, we didn't implement @@toPrimitive case\n// and the second argument - flag - preferred type is a string\nmodule.exports = function (it, S) {\n  if (!isObject(it)) return it;\n  var fn, val;\n  if (S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (typeof (fn = it.valueOf) == 'function' && !isObject(val = fn.call(it))) return val;\n  if (!S && typeof (fn = it.toString) == 'function' && !isObject(val = fn.call(it))) return val;\n  throw TypeError(\"Can't convert object to primitive value\");\n};\n","var core = require('./_core');\nvar global = require('./_global');\nvar SHARED = '__core-js_shared__';\nvar store = global[SHARED] || (global[SHARED] = {});\n\n(module.exports = function (key, value) {\n  return store[key] || (store[key] = value !== undefined ? value : {});\n})('versions', []).push({\n  version: core.version,\n  mode: require('./_library') ? 'pure' : 'global',\n  copyright: '© 2020 Denis Pushkarev (zloirock.ru)'\n});\n","// optional / simple context binding\nvar aFunction = require('./_a-function');\nmodule.exports = function (fn, that, length) {\n  aFunction(fn);\n  if (that === undefined) return fn;\n  switch (length) {\n    case 1: return function (a) {\n      return fn.call(that, a);\n    };\n    case 2: return function (a, b) {\n      return fn.call(that, a, b);\n    };\n    case 3: return function (a, b, c) {\n      return fn.call(that, a, b, c);\n    };\n  }\n  return function (/* ...args */) {\n    return fn.apply(that, arguments);\n  };\n};\n","var def = require('./_object-dp').f;\nvar has = require('./_has');\nvar TAG = require('./_wks')('toStringTag');\n\nmodule.exports = function (it, tag, stat) {\n  if (it && !has(it = stat ? it : it.prototype, TAG)) def(it, TAG, { configurable: true, value: tag });\n};\n","var toString = {}.toString;\n\nmodule.exports = function (it) {\n  return toString.call(it).slice(8, -1);\n};\n","exports.f = {}.propertyIsEnumerable;\n","var pIE = require('./_object-pie');\nvar createDesc = require('./_property-desc');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar has = require('./_has');\nvar IE8_DOM_DEFINE = require('./_ie8-dom-define');\nvar gOPD = Object.getOwnPropertyDescriptor;\n\nexports.f = require('./_descriptors') ? gOPD : function getOwnPropertyDescriptor(O, P) {\n  O = toIObject(O);\n  P = toPrimitive(P, true);\n  if (IE8_DOM_DEFINE) try {\n    return gOPD(O, P);\n  } catch (e) { /* empty */ }\n  if (has(O, P)) return createDesc(!pIE.f.call(O, P), O[P]);\n};\n","'use strict';\nvar fails = require('./_fails');\n\nmodule.exports = function (method, arg) {\n  return !!method && fails(function () {\n    // eslint-disable-next-line no-useless-call\n    arg ? method.call(null, function () { /* empty */ }, 1) : method.call(null);\n  });\n};\n","\"use strict\";\n//# sourceMappingURL=types.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ssz = exports.ts = void 0;\n\nvar _ts = _interopRequireWildcard(require(\"./types\"));\n\nexports.ts = _ts;\n\nvar _ssz = _interopRequireWildcard(require(\"./sszTypes\"));\n\nexports.ssz = _ssz;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTreeBacked = isTreeBacked;\nexports.createTreeBacked = createTreeBacked;\nexports.getTreeValueClass = getTreeValueClass;\nexports.proxyWrapTreeValue = proxyWrapTreeValue;\nexports.ContainerTreeValue = exports.CompositeListTreeValue = exports.BasicListTreeValue = exports.CompositeArrayTreeValue = exports.BasicArrayTreeValue = exports.TreeValue = exports.TreeProxyHandler = void 0;\n\nvar _types = require(\"../../types\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nvar _tree = require(\"../../util/tree\");\n\nlet _Symbol$iterator;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nfunction isTreeBacked(value) {\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  return value && value.type && value.tree && (0, _tree.isTree)(value.tree);\n}\n/**\n * Return an ES6 Proxy-wrapped tree value (ergonomic getter/setter/iteration)\n */\n\n\nfunction createTreeBacked(type, tree) {\n  const TreeValueClass = getTreeValueClass(type);\n  return proxyWrapTreeValue(new TreeValueClass(type, tree));\n}\n\nfunction getTreeValueClass(type) {\n  if ((0, _types.isListType)(type)) {\n    if ((0, _types.isBasicType)(type.elementType)) {\n      return BasicListTreeValue;\n    } else {\n      return CompositeListTreeValue;\n    }\n  } else if ((0, _types.isVectorType)(type)) {\n    if ((0, _types.isBasicType)(type.elementType)) {\n      return BasicArrayTreeValue;\n    } else {\n      return CompositeArrayTreeValue;\n    }\n  } else if ((0, _types.isContainerType)(type)) {\n    return ContainerTreeValue;\n  }\n}\n/**\n * Wrap a TreeValue in a Proxy that adds ergonomic getter/setter\n */\n\n\nfunction proxyWrapTreeValue(value) {\n  return new Proxy(value, TreeProxyHandler);\n}\n/**\n * Proxy handler that adds ergonomic get/set and exposes TreeValue methods\n */\n\n\nconst TreeProxyHandler = {\n  get(target, property) {\n    if (property in target) {\n      return target[property];\n    } else {\n      return target.getProperty(property);\n    }\n  },\n\n  set(target, property, value) {\n    return target.setProperty(property, value);\n  },\n\n  ownKeys(target) {\n    return target.getPropertyNames();\n  },\n\n  getOwnPropertyDescriptor(target, property) {\n    if (target.type.getPropertyType(property)) {\n      return {\n        configurable: true,\n        enumerable: true,\n        writable: true\n      };\n    } else {\n      return undefined;\n    }\n  }\n\n};\n/**\n * Convenience wrapper around a type and tree\n */\n\nexports.TreeProxyHandler = TreeProxyHandler;\n_Symbol$iterator = Symbol.iterator;\n\nclass TreeValue {\n  constructor(type, tree) {\n    _defineProperty(this, \"type\", void 0);\n\n    _defineProperty(this, \"tree\", void 0);\n\n    this.type = type;\n    this.tree = tree;\n  }\n\n  clone() {\n    const TreeValueClass = Object.getPrototypeOf(this).constructor;\n    return proxyWrapTreeValue(new TreeValueClass(this.type, this.tree.clone()));\n  }\n\n  valueOf() {\n    return this.type.tree_convertToStruct(this.tree);\n  }\n\n  equals(other) {\n    if (isTreeBacked(other)) {\n      return (0, _byteArray.byteArrayEquals)(this.hashTreeRoot(), other.hashTreeRoot());\n    } else {\n      return this.type.struct_equals(this, other);\n    }\n  }\n\n  size() {\n    return this.type.tree_getSerializedLength(this.tree);\n  }\n\n  toStruct() {\n    return this.type.tree_convertToStruct(this.tree);\n  }\n\n  toBytes(output, offset) {\n    return this.type.tree_serializeToBytes(this.tree, output, offset);\n  }\n\n  serialize() {\n    const output = new Uint8Array(this.type.tree_getSerializedLength(this.tree));\n    this.toBytes(output, 0);\n    return output;\n  }\n\n  hashTreeRoot() {\n    return this.tree.root;\n  }\n\n  createProof(paths) {\n    return this.type.tree_createProof(this.tree, paths);\n  }\n\n  getPropertyNames() {\n    return this.type.tree_getPropertyNames(this.tree);\n  }\n\n  [_Symbol$iterator]() {\n    return this.values();\n  }\n\n}\n\nexports.TreeValue = TreeValue;\n\nclass BasicArrayTreeValue extends TreeValue {\n  constructor(type, tree) {\n    super(type, tree);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  getProperty(property) {\n    return this.type.tree_getProperty(this.tree, property);\n  }\n\n  setProperty(property, value) {\n    return this.type.tree_setProperty(this.tree, property, value);\n  }\n\n  *keys() {\n    const propNames = this.getPropertyNames(); // pop off \"length\"\n\n    propNames.pop();\n    yield* propNames.map(String);\n  }\n\n  values() {\n    return this.type.tree_iterateValues(this.tree);\n  }\n\n  *entries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.values()) {\n      yield [String(keys[i]), value];\n      i++;\n    }\n  }\n\n  readonlyValues() {\n    return this.type.tree_readonlyIterateValues(this.tree);\n  }\n\n  *readonlyEntries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.readonlyValues()) {\n      yield [String(keys[i]), value];\n      i++;\n    }\n  }\n\n}\n\nexports.BasicArrayTreeValue = BasicArrayTreeValue;\n\nclass CompositeArrayTreeValue extends TreeValue {\n  constructor(type, tree) {\n    super(type, tree);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  getProperty(property) {\n    if (property === \"length\") {\n      return this.type.tree_getProperty(this.tree, property);\n    }\n\n    return createTreeBacked(this.type.elementType, this.type.tree_getProperty(this.tree, property));\n  }\n\n  setProperty(property, value) {\n    return this.type.tree_setProperty(this.tree, property, isTreeBacked(value) ? value.tree : this.type.elementType.struct_convertToTree(value));\n  }\n\n  *keys() {\n    const propNames = this.getPropertyNames(); // pop off \"length\"\n\n    propNames.pop();\n    yield* propNames.map(String);\n  }\n\n  *values() {\n    for (const tree of this.type.tree_iterateValues(this.tree)) {\n      yield createTreeBacked(this.type.elementType, tree);\n    }\n  }\n\n  *entries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.values()) {\n      yield [String(keys[i]), value];\n      i++;\n    }\n  }\n\n  *readonlyValues() {\n    for (const tree of this.type.tree_readonlyIterateValues(this.tree)) {\n      yield createTreeBacked(this.type.elementType, tree);\n    }\n  }\n\n  *readonlyEntries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.readonlyValues()) {\n      yield [String(keys[i]), value];\n      i++;\n    }\n  }\n\n}\n\nexports.CompositeArrayTreeValue = CompositeArrayTreeValue;\n\nclass BasicListTreeValue extends BasicArrayTreeValue {\n  constructor(type, tree) {\n    super(type, tree);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  push(...values) {\n    return this.type.tree_push(this.tree, ...values);\n  }\n\n  pop() {\n    return this.type.tree_pop(this.tree);\n  }\n\n}\n\nexports.BasicListTreeValue = BasicListTreeValue;\n\nclass CompositeListTreeValue extends CompositeArrayTreeValue {\n  constructor(type, tree) {\n    super(type, tree);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  push(...values) {\n    const convertedValues = values.map(value => isTreeBacked(value) ? value.tree : this.type.elementType.struct_convertToTree(value));\n    return this.type.tree_push(this.tree, ...convertedValues);\n  }\n\n  pop() {\n    return this.type.tree_pop(this.tree);\n  }\n\n}\n\nexports.CompositeListTreeValue = CompositeListTreeValue;\n\nclass ContainerTreeValue extends TreeValue {\n  constructor(type, tree) {\n    super(type, tree);\n\n    _defineProperty(this, \"type\", void 0);\n\n    this.type = type;\n  }\n\n  getProperty(property) {\n    if (!this.type.fields[property]) {\n      return undefined;\n    }\n\n    const propType = this.type.getPropertyType(property);\n    const propValue = this.type.tree_getProperty(this.tree, property);\n\n    if ((0, _types.isCompositeType)(propType)) {\n      return createTreeBacked(propType, propValue);\n    } else {\n      return propValue;\n    }\n  }\n\n  setProperty(property, value) {\n    const propType = this.type.getPropertyType(property);\n\n    if ((0, _types.isCompositeType)(propType)) {\n      if (isTreeBacked(value)) {\n        return this.type.tree_setProperty(this.tree, property, value.tree);\n      } else {\n        return this.type.tree_setProperty(this.tree, property, propType.struct_convertToTree(value));\n      }\n    } else {\n      return this.type.tree_setProperty(this.tree, property, value);\n    }\n  }\n\n  *keys() {\n    yield* this.getPropertyNames();\n  }\n\n  *values() {\n    for (const [_key, value] of this.entries()) {\n      yield value;\n    }\n  }\n\n  *entries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.type.tree_iterateValues(this.tree)) {\n      const propName = keys[i];\n      const propType = this.type.getPropertyType(propName);\n\n      if ((0, _types.isCompositeType)(propType)) {\n        yield [propName, createTreeBacked(propType, value)];\n      } else {\n        yield [propName, value];\n      }\n\n      i++;\n    }\n  }\n\n  *readonlyValues() {\n    for (const [_key, value] of this.readonlyEntries()) {\n      yield value;\n    }\n  }\n\n  *readonlyEntries() {\n    const keys = this.getPropertyNames();\n    let i = 0;\n\n    for (const value of this.type.tree_readonlyIterateValues(this.tree)) {\n      const propName = keys[i];\n      const propType = this.type.getPropertyType(propName);\n\n      if ((0, _types.isCompositeType)(propType)) {\n        yield [propName, createTreeBacked(propType, value)];\n      } else {\n        yield [propName, value];\n      }\n\n      i++;\n    }\n  }\n\n}\n\nexports.ContainerTreeValue = ContainerTreeValue;\n//# sourceMappingURL=treeValue.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.gindexChild = exports.gindexParent = exports.gindexSibling = exports.concatGindices = exports.gindexIterator = exports.iterateAtDepth = exports.countToDepth = exports.toGindexBitstring = exports.toGindex = exports.bitIndexBigInt = void 0;\nfunction bitIndexBigInt(v) {\n    return v.toString(2).length - 1;\n}\nexports.bitIndexBigInt = bitIndexBigInt;\nfunction toGindex(depth, index) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (index >= anchor) {\n        throw new Error(\"index too large for depth\");\n    }\n    return anchor | index;\n}\nexports.toGindex = toGindex;\nfunction toGindexBitstring(depth, index) {\n    const str = index ? index.toString(2) : \"\";\n    if (str.length > depth) {\n        throw new Error(\"index too large for depth\");\n    }\n    else {\n        return \"1\" + str.padStart(depth, \"0\");\n    }\n}\nexports.toGindexBitstring = toGindexBitstring;\n// Get the depth (root starting at 0) necessary to cover a subtree of `count` elements.\n// (in out): (0 0), (1 0), (2 1), (3 2), (4 2), (5 3), (6 3), (7 3), (8 3), (9 4)\nfunction countToDepth(count) {\n    if (count <= 1) {\n        return 0;\n    }\n    return (count - BigInt(1)).toString(2).length;\n}\nexports.countToDepth = countToDepth;\n/**\n * Iterate through Gindexes at a certain depth\n */\nfunction iterateAtDepth(depth, startIndex, count) {\n    const anchor = BigInt(1) << BigInt(depth);\n    if (startIndex + count > anchor) {\n        throw new Error(\"Too large for depth\");\n    }\n    let i = toGindex(depth, startIndex);\n    const last = i + count;\n    return {\n        [Symbol.iterator]() {\n            return {\n                next() {\n                    if (i < last) {\n                        const value = i;\n                        i++;\n                        return { done: false, value };\n                    }\n                    else {\n                        return { done: true, value: undefined };\n                    }\n                },\n            };\n        },\n    };\n}\nexports.iterateAtDepth = iterateAtDepth;\nconst ERR_INVALID_GINDEX = \"Invalid gindex\";\nfunction gindexIterator(gindex) {\n    let bitstring;\n    if (typeof gindex === \"string\") {\n        if (!gindex.length) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex;\n    }\n    else {\n        if (gindex < 1) {\n            throw new Error(ERR_INVALID_GINDEX);\n        }\n        bitstring = gindex.toString(2);\n    }\n    let i = 1;\n    const next = () => {\n        if (i === bitstring.length) {\n            return { done: true, value: undefined };\n        }\n        const bit = Number(bitstring[i]);\n        i++;\n        return { done: false, value: bit };\n    };\n    return {\n        [Symbol.iterator]() {\n            return { next };\n        },\n        remainingBitLength() {\n            return bitstring.length - i;\n        },\n    };\n}\nexports.gindexIterator = gindexIterator;\n/**\n * Concatenate Generalized Indices\n * Given generalized indices i1 for A -> B, i2 for B -> C .... i_n for Y -> Z, returns\n * the generalized index for A -> Z.\n */\nfunction concatGindices(gindices) {\n    return BigInt(gindices.reduce((acc, gindex) => acc + gindex.toString(2).slice(1), \"0b1\"));\n}\nexports.concatGindices = concatGindices;\nfunction gindexSibling(gindex) {\n    return gindex ^ BigInt(1);\n}\nexports.gindexSibling = gindexSibling;\nfunction gindexParent(gindex) {\n    return gindex / BigInt(2);\n}\nexports.gindexParent = gindexParent;\nfunction gindexChild(gindex, rightChild) {\n    return gindex * BigInt(2) + BigInt(rightChild);\n}\nexports.gindexChild = gindexChild;\n","module.exports = function (it) {\n  if (typeof it != 'function') throw TypeError(it + ' is not a function!');\n  return it;\n};\n","// 7.2.1 RequireObjectCoercible(argument)\nmodule.exports = function (it) {\n  if (it == undefined) throw TypeError(\"Can't call method on  \" + it);\n  return it;\n};\n","// false -> Array#indexOf\n// true  -> Array#includes\nvar toIObject = require('./_to-iobject');\nvar toLength = require('./_to-length');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nmodule.exports = function (IS_INCLUDES) {\n  return function ($this, el, fromIndex) {\n    var O = toIObject($this);\n    var length = toLength(O.length);\n    var index = toAbsoluteIndex(fromIndex, length);\n    var value;\n    // Array#includes uses SameValueZero equality algorithm\n    // eslint-disable-next-line no-self-compare\n    if (IS_INCLUDES && el != el) while (length > index) {\n      value = O[index++];\n      // eslint-disable-next-line no-self-compare\n      if (value != value) return true;\n    // Array#indexOf ignores holes, Array#includes - not\n    } else for (;length > index; index++) if (IS_INCLUDES || index in O) {\n      if (O[index] === el) return IS_INCLUDES || index || 0;\n    } return !IS_INCLUDES && -1;\n  };\n};\n","var shared = require('./_shared')('keys');\nvar uid = require('./_uid');\nmodule.exports = function (key) {\n  return shared[key] || (shared[key] = uid(key));\n};\n","// IE 8- don't enum bug keys\nmodule.exports = (\n  'constructor,hasOwnProperty,isPrototypeOf,propertyIsEnumerable,toLocaleString,toString,valueOf'\n).split(',');\n","exports.f = Object.getOwnPropertySymbols;\n","// 7.2.2 IsArray(argument)\nvar cof = require('./_cof');\nmodule.exports = Array.isArray || function isArray(arg) {\n  return cof(arg) == 'Array';\n};\n","// 19.1.2.2 / 15.2.3.5 Object.create(O [, Properties])\nvar anObject = require('./_an-object');\nvar dPs = require('./_object-dps');\nvar enumBugKeys = require('./_enum-bug-keys');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar Empty = function () { /* empty */ };\nvar PROTOTYPE = 'prototype';\n\n// Create object with fake `null` prototype: use iframe Object with cleared prototype\nvar createDict = function () {\n  // Thrash, waste and sodomy: IE GC bug\n  var iframe = require('./_dom-create')('iframe');\n  var i = enumBugKeys.length;\n  var lt = '<';\n  var gt = '>';\n  var iframeDocument;\n  iframe.style.display = 'none';\n  require('./_html').appendChild(iframe);\n  iframe.src = 'javascript:'; // eslint-disable-line no-script-url\n  // createDict = iframe.contentWindow.Object;\n  // html.removeChild(iframe);\n  iframeDocument = iframe.contentWindow.document;\n  iframeDocument.open();\n  iframeDocument.write(lt + 'script' + gt + 'document.F=Object' + lt + '/script' + gt);\n  iframeDocument.close();\n  createDict = iframeDocument.F;\n  while (i--) delete createDict[PROTOTYPE][enumBugKeys[i]];\n  return createDict();\n};\n\nmodule.exports = Object.create || function create(O, Properties) {\n  var result;\n  if (O !== null) {\n    Empty[PROTOTYPE] = anObject(O);\n    result = new Empty();\n    Empty[PROTOTYPE] = null;\n    // add \"__proto__\" for Object.getPrototypeOf polyfill\n    result[IE_PROTO] = O;\n  } else result = createDict();\n  return Properties === undefined ? result : dPs(result, Properties);\n};\n","// getting tag from 19.1.3.6 Object.prototype.toString()\nvar cof = require('./_cof');\nvar TAG = require('./_wks')('toStringTag');\n// ES3 wrong here\nvar ARG = cof(function () { return arguments; }()) == 'Arguments';\n\n// fallback for IE11 Script Access Denied error\nvar tryGet = function (it, key) {\n  try {\n    return it[key];\n  } catch (e) { /* empty */ }\n};\n\nmodule.exports = function (it) {\n  var O, T, B;\n  return it === undefined ? 'Undefined' : it === null ? 'Null'\n    // @@toStringTag case\n    : typeof (T = tryGet(O = Object(it), TAG)) == 'string' ? T\n    // builtinTag case\n    : ARG ? cof(O)\n    // ES3 arguments fallback\n    : (B = cof(O)) == 'Object' && typeof O.callee == 'function' ? 'Arguments' : B;\n};\n","'use strict';\nvar addToUnscopables = require('./_add-to-unscopables');\nvar step = require('./_iter-step');\nvar Iterators = require('./_iterators');\nvar toIObject = require('./_to-iobject');\n\n// 22.1.3.4 Array.prototype.entries()\n// 22.1.3.13 Array.prototype.keys()\n// 22.1.3.29 Array.prototype.values()\n// 22.1.3.30 Array.prototype[@@iterator]()\nmodule.exports = require('./_iter-define')(Array, 'Array', function (iterated, kind) {\n  this._t = toIObject(iterated); // target\n  this._i = 0;                   // next index\n  this._k = kind;                // kind\n// 22.1.5.2.1 %ArrayIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var kind = this._k;\n  var index = this._i++;\n  if (!O || index >= O.length) {\n    this._t = undefined;\n    return step(1);\n  }\n  if (kind == 'keys') return step(0, index);\n  if (kind == 'values') return step(0, O[index]);\n  return step(0, [index, O[index]]);\n}, 'values');\n\n// argumentsList[@@iterator] is %ArrayProto_values% (9.4.4.6, 9.4.4.7)\nIterators.Arguments = Iterators.Array;\n\naddToUnscopables('keys');\naddToUnscopables('values');\naddToUnscopables('entries');\n","// 0 -> Array#forEach\n// 1 -> Array#map\n// 2 -> Array#filter\n// 3 -> Array#some\n// 4 -> Array#every\n// 5 -> Array#find\n// 6 -> Array#findIndex\nvar ctx = require('./_ctx');\nvar IObject = require('./_iobject');\nvar toObject = require('./_to-object');\nvar toLength = require('./_to-length');\nvar asc = require('./_array-species-create');\nmodule.exports = function (TYPE, $create) {\n  var IS_MAP = TYPE == 1;\n  var IS_FILTER = TYPE == 2;\n  var IS_SOME = TYPE == 3;\n  var IS_EVERY = TYPE == 4;\n  var IS_FIND_INDEX = TYPE == 6;\n  var NO_HOLES = TYPE == 5 || IS_FIND_INDEX;\n  var create = $create || asc;\n  return function ($this, callbackfn, that) {\n    var O = toObject($this);\n    var self = IObject(O);\n    var f = ctx(callbackfn, that, 3);\n    var length = toLength(self.length);\n    var index = 0;\n    var result = IS_MAP ? create($this, length) : IS_FILTER ? create($this, 0) : undefined;\n    var val, res;\n    for (;length > index; index++) if (NO_HOLES || index in self) {\n      val = self[index];\n      res = f(val, index, O);\n      if (TYPE) {\n        if (IS_MAP) result[index] = res;   // map\n        else if (res) switch (TYPE) {\n          case 3: return true;             // some\n          case 5: return val;              // find\n          case 6: return index;            // findIndex\n          case 2: result.push(val);        // filter\n        } else if (IS_EVERY) return false; // every\n      }\n    }\n    return IS_FIND_INDEX ? -1 : IS_SOME || IS_EVERY ? IS_EVERY : result;\n  };\n};\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBasicType = isBasicType;\nexports.BasicType = exports.BASIC_TYPE = void 0;\n\nvar _type = require(\"../type\");\n\n/* eslint-disable @typescript-eslint/camelcase */\n\n/* eslint-disable @typescript-eslint/member-ordering */\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\nconst BASIC_TYPE = Symbol.for(\"ssz/BasicType\");\nexports.BASIC_TYPE = BASIC_TYPE;\n\nfunction isBasicType(type) {\n  return (0, _type.isTypeOf)(type, BASIC_TYPE);\n}\n/**\n * A BasicType is a terminal type, which has no flexibility in its representation.\n *\n * It is serialized as, at maximum, 32 bytes and merkleized as, at maximum, a single chunk\n */\n\n\nclass BasicType extends _type.Type {\n  constructor() {\n    super();\n\n    this._typeSymbols.add(BASIC_TYPE);\n  }\n\n  struct_clone(value) {\n    return value;\n  }\n\n  struct_equals(value1, value2) {\n    this.assertValidValue(value1);\n    this.assertValidValue(value2);\n    return value1 === value2;\n  }\n  /**\n   * Check if type has a variable number of elements (or subelements)\n   *\n   * For basic types, this is always false\n   */\n\n\n  hasVariableSerializedLength() {\n    return false;\n  }\n\n  getMaxSerializedLength() {\n    return this.struct_getSerializedLength();\n  }\n\n  getMinSerializedLength() {\n    return this.struct_getSerializedLength();\n  }\n\n  bytes_validate(data, offset) {\n    if (!data) {\n      throw new Error(\"Data is null or undefined\");\n    }\n\n    if (data.length === 0) {\n      throw new Error(\"Data is empty\");\n    }\n\n    const length = data.length - offset;\n\n    if (length < this.struct_getSerializedLength()) {\n      throw new Error(\"Data length of \".concat(length, \" is too small, expect \").concat(this.struct_getSerializedLength()));\n    } // accept data length > this.size()\n\n  }\n\n  struct_hashTreeRoot(value) {\n    const output = new Uint8Array(32);\n    this.struct_serializeToBytes(value, output, 0);\n    return output;\n  }\n\n}\n\nexports.BasicType = BasicType;\n//# sourceMappingURL=abstract.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isCompositeType = isCompositeType;\nexports.CompositeType = exports.COMPOSITE_TYPE = void 0;\n\nvar _backings = require(\"../../backings\");\n\nvar _type = require(\"../type\");\n\nvar _persistentMerkleTree = require(\"@chainsafe/persistent-merkle-tree\");\n\nvar _compat = require(\"../../util/compat\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst COMPOSITE_TYPE = Symbol.for(\"ssz/CompositeType\");\nexports.COMPOSITE_TYPE = COMPOSITE_TYPE;\n\nfunction isCompositeType(type) {\n  return (0, _type.isTypeOf)(type, COMPOSITE_TYPE);\n}\n/**\n * A CompositeType is a type containing other types, and is flexible in its representation.\n *\n */\n\n\nclass CompositeType extends _type.Type {\n  constructor() {\n    super();\n\n    _defineProperty(this, \"_chunkDepth\", void 0);\n\n    _defineProperty(this, \"_defaultNode\", void 0);\n\n    this._typeSymbols.add(COMPOSITE_TYPE);\n  }\n\n  tree_equals(tree1, tree2) {\n    return (0, _byteArray.byteArrayEquals)(tree1.root, tree2.root);\n  }\n\n  bytes_equals(bytes1, bytes2) {\n    return (0, _byteArray.byteArrayEquals)(bytes1, bytes2);\n  }\n\n  tree_defaultValue() {\n    return new _persistentMerkleTree.Tree(this.tree_defaultNode());\n  }\n\n  tree_clone(value) {\n    return value.clone();\n  }\n\n  bytes_clone(value, start = 0, end = value.length) {\n    const bytes = new Uint8Array(end - start);\n    value.subarray(start, end).set(bytes);\n    return bytes;\n  }\n\n  struct_serialize(struct, data) {\n    const output = new Uint8Array(this.struct_getSerializedLength(struct));\n    return this.struct_serializeToBytes(struct, output, 0);\n  }\n\n  tree_serialize(tree, data) {\n    const output = new Uint8Array(this.tree_getSerializedLength(tree));\n    return this.tree_serializeToBytes(tree, output, 0);\n  }\n\n  bytes_validate(data, start, end) {\n    if (!data) {\n      throw new Error(\"Data is null or undefined\");\n    }\n\n    if (data.length === 0) {\n      throw new Error(\"Data is empty\");\n    }\n\n    if (start < 0) {\n      throw new Error(\"Start param is negative: \".concat(start));\n    }\n\n    if (start > data.length) {\n      throw new Error(\"Start param: \".concat(start, \" is greater than length: \").concat(data.length));\n    }\n\n    if (end < 0) {\n      throw new Error(\"End param is negative: \".concat(end));\n    }\n\n    if (end > data.length) {\n      throw new Error(\"End param: \".concat(end, \" is greater than length: \").concat(data.length));\n    }\n\n    const length = end - start;\n\n    if (!this.hasVariableSerializedLength() && length !== this.struct_getSerializedLength(null)) {\n      throw new Error(\"Incorrect data length \".concat(length, \", expect \").concat(this.struct_getSerializedLength(null)));\n    }\n\n    if (end - start < this.getMinSerializedLength()) {\n      throw new Error(\"Data length \".concat(length, \" is too small, expect at least \").concat(this.getMinSerializedLength()));\n    }\n  }\n\n  struct_deserialize(data) {\n    return this.struct_deserializeFromBytes(data, 0, data.length);\n  }\n\n  tree_deserialize(data) {\n    return this.tree_deserializeFromBytes(data, 0, data.length);\n  }\n\n  struct_getChunkCount(struct) {\n    return this.getMaxChunkCount();\n  }\n\n  tree_getChunkCount(target) {\n    return this.getMaxChunkCount();\n  }\n\n  *struct_yieldChunkRoots(struct) {\n    const chunkCount = this.struct_getChunkCount(struct);\n\n    for (let i = 0; i < chunkCount; i++) {\n      yield this.struct_getRootAtChunkIndex(struct, i);\n    }\n  }\n\n  getChunkDepth() {\n    if (!this._chunkDepth) {\n      this._chunkDepth = (0, _persistentMerkleTree.countToDepth)(BigInt(this.getMaxChunkCount()));\n    }\n\n    return this._chunkDepth;\n  }\n\n  getGindexAtChunkIndex(index) {\n    return (0, _persistentMerkleTree.toGindex)(this.getChunkDepth(), BigInt(index));\n  }\n\n  tree_getSubtreeAtChunkIndex(target, index) {\n    return target.getSubtree(this.getGindexAtChunkIndex(index));\n  }\n\n  tree_setSubtreeAtChunkIndex(target, index, value, expand = false) {\n    target.setSubtree(this.getGindexAtChunkIndex(index), value, expand);\n  }\n\n  tree_getRootAtChunkIndex(target, index) {\n    return target.getRoot(this.getGindexAtChunkIndex(index));\n  }\n\n  tree_setRootAtChunkIndex(target, index, value, expand = false) {\n    target.setRoot(this.getGindexAtChunkIndex(index), value, expand);\n  }\n\n  /**\n   * Navigate to a subtype & gindex using a path\n   */\n  getPathInfo(path) {\n    const gindices = [];\n    let type = this;\n\n    for (const prop of path) {\n      if (!isCompositeType(type)) {\n        throw new Error(\"Invalid path: cannot navigate beyond a basic type\");\n      }\n\n      gindices.push(type.getPropertyGindex(prop));\n      type = type.getPropertyType(prop);\n    }\n\n    return {\n      type,\n      gindex: (0, _persistentMerkleTree.concatGindices)(gindices)\n    };\n  }\n\n  getPathGindex(path) {\n    return this.getPathInfo(path).gindex;\n  }\n  /**\n   * Get leaf gindices\n   *\n   * Note: This is a recursively called method.\n   * Subtypes recursively call this method until basic types / leaf data is hit.\n   *\n   * @param target Used for variable-length types.\n   * @param root Used to anchor the returned gindices to a non-root gindex.\n   * This is used to augment leaf gindices in recursively-called subtypes relative to the type.\n   * @returns The gindices corresponding to leaf data.\n   */\n\n\n  tree_createProof(target, paths) {\n    const gindices = paths.map(path => {\n      const {\n        type,\n        gindex\n      } = this.getPathInfo(path);\n\n      if (!isCompositeType(type)) {\n        return gindex;\n      } else {\n        // if the path subtype is composite, include the gindices of all the leaves\n        return type.tree_getLeafGindices(type.hasVariableSerializedLength() ? target.getSubtree(gindex) : undefined, gindex);\n      }\n    }).flat(1);\n    return target.getProof({\n      type: _persistentMerkleTree.ProofType.treeOffset,\n      gindices\n    });\n  }\n\n  tree_createFromProof(root, proof) {\n    const tree = _persistentMerkleTree.Tree.createFromProof(proof);\n\n    if (!(0, _byteArray.byteArrayEquals)(tree.root, root)) {\n      throw new Error(\"Proof does not match trusted root\");\n    }\n\n    return tree;\n  }\n\n  tree_createFromProofUnsafe(proof) {\n    return _persistentMerkleTree.Tree.createFromProof(proof);\n  }\n\n  struct_hashTreeRoot(struct) {\n    return (0, _compat.merkleize)(this.struct_yieldChunkRoots(struct), this.getMaxChunkCount());\n  }\n\n  tree_hashTreeRoot(tree) {\n    return tree.root;\n  } // convenience\n\n  /**\n   * Valid value assertion\n   */\n\n\n  assertValidValue(value) {\n    this.struct_assertValidValue(value);\n  }\n  /**\n   * Equality\n   */\n\n\n  equals(value1, value2) {\n    if ((0, _backings.isBackedValue)(value1) && (0, _backings.isBackedValue)(value2)) {\n      return value1.equals(value2);\n    } else {\n      return this.struct_equals(value1, value2);\n    }\n  }\n  /**\n   * Default constructor\n   */\n\n\n  defaultValue() {\n    return this.struct_defaultValue();\n  }\n  /**\n   * Clone / copy\n   */\n\n\n  clone(value) {\n    if ((0, _backings.isBackedValue)(value)) {\n      return value.clone();\n    } else {\n      return this.struct_clone(value);\n    }\n  } // Serialization / Deserialization\n\n  /**\n   * Serialized byte length\n   */\n\n\n  size(value) {\n    if ((0, _backings.isBackedValue)(value)) {\n      return value.size();\n    } else {\n      return this.struct_getSerializedLength(value);\n    }\n  }\n  /**\n   * Maximal serialized byte length\n   */\n\n\n  maxSize() {\n    return this.getMaxSerializedLength();\n  }\n  /**\n   * Minimal serialized byte length\n   */\n\n\n  minSize() {\n    return this.getMinSerializedLength();\n  }\n  /**\n   * Low-level deserialization\n   */\n\n\n  fromBytes(data, start, end) {\n    return this.struct_deserializeFromBytes(data, start, end);\n  }\n  /**\n   * Deserialization\n   */\n\n\n  deserialize(data) {\n    return this.fromBytes(data, 0, data.length);\n  }\n  /**\n   * Low-level serialization\n   *\n   * Serializes to a pre-allocated Uint8Array\n   */\n\n\n  toBytes(value, output, offset) {\n    if ((0, _backings.isBackedValue)(value)) {\n      return value.toBytes(output, offset);\n    } else {\n      return this.struct_serializeToBytes(value, output, offset);\n    }\n  }\n  /**\n   * Serialization\n   */\n\n\n  serialize(value) {\n    if ((0, _backings.isBackedValue)(value)) {\n      return value.serialize();\n    } else {\n      const output = new Uint8Array(this.size(value));\n      this.toBytes(value, output, 0);\n      return output;\n    }\n  } // Merkleization\n\n  /**\n   * Merkleization\n   */\n\n\n  hashTreeRoot(value) {\n    if ((0, _backings.isBackedValue)(value)) {\n      return value.hashTreeRoot();\n    } else {\n      return this.struct_hashTreeRoot(value);\n    }\n  }\n  /**\n   * Convert from a JSON-serializable object\n   */\n\n\n  fromJson(data, options) {\n    return this.struct_convertFromJson(data, options);\n  }\n  /**\n   * Convert to a JSON-serializable object\n   */\n\n\n  toJson(value, options) {\n    return this.struct_convertToJson(value, options);\n  }\n\n  createTreeBacked(tree) {\n    return (0, _backings.createTreeBacked)(this, tree);\n  }\n\n  createTreeBackedFromStruct(value) {\n    return this.createTreeBacked(this.struct_convertToTree(value));\n  }\n\n  createTreeBackedFromBytes(data) {\n    return this.createTreeBacked(this.tree_deserialize(data));\n  }\n\n  createTreeBackedFromJson(data, options) {\n    return this.createTreeBackedFromStruct(this.struct_convertFromJson(data, options));\n  }\n\n  createTreeBackedFromProof(root, proof) {\n    return this.createTreeBacked(this.tree_createFromProof(root, proof));\n  }\n\n  createTreeBackedFromProofUnsafe(proof) {\n    return this.createTreeBacked(this.tree_createFromProofUnsafe(proof));\n  }\n\n  defaultTreeBacked() {\n    return (0, _backings.createTreeBacked)(this, this.tree_defaultValue());\n  }\n\n}\n\nexports.CompositeType = CompositeType;\n//# sourceMappingURL=abstract.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _tree = require(\"./tree\");\n\nObject.keys(_tree).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _tree[key];\n    }\n  });\n});\n\nvar _backedValue = require(\"./backedValue\");\n\nObject.keys(_backedValue).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _backedValue[key];\n    }\n  });\n});\n\nvar _readonlyIterate = require(\"./readonlyIterate\");\n\nObject.keys(_readonlyIterate).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _readonlyIterate[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _interface = require(\"./interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _interface[key];\n    }\n  });\n});\n\nvar _treeValue = require(\"./treeValue\");\n\nObject.keys(_treeValue).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _treeValue[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.zeroNode = void 0;\nconst node_1 = require(\"./node\");\nconst zeroes = [new node_1.LeafNode(new Uint8Array(32))];\nfunction zeroNode(depth) {\n    if (depth >= zeroes.length) {\n        for (let i = zeroes.length; i <= depth; i++) {\n            zeroes[i] = new node_1.BranchNode(zeroes[i - 1], zeroes[i - 1]);\n        }\n    }\n    return zeroes[depth];\n}\nexports.zeroNode = zeroNode;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hash = hash;\nexports.merkleize = merkleize;\nexports.mixInLength = mixInLength;\n\nvar _hash2 = require(\"./hash\");\n\nvar _merkleize2 = require(\"./merkleize\");\n\nfunction hash(...inputs) {\n  return Uint8Array.from((0, _hash2.hash)(...inputs.map(Buffer.from)));\n}\n\nfunction merkleize(chunks, padTo) {\n  return (0, _merkleize2.merkleize)(Array.from(chunks).map(Buffer.from), padTo);\n}\n\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  return hash(root, lengthBuf);\n}\n//# sourceMappingURL=compat.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.hash = hash;\n\nvar _asSha = _interopRequireDefault(require(\"@chainsafe/as-sha256\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/** @module ssz */\n\n/**\n * Hash used for hashTreeRoot\n */\nfunction hash(...inputs) {\n  return _asSha.default.digest(Buffer.concat(inputs));\n}\n//# sourceMappingURL=hash.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BYTES_PER_LENGTH_PREFIX = exports.BYTES_PER_CHUNK = void 0;\n\n/** @module ssz */\n// Number of bytes per chunk.\n\n/** @ignore */\nconst BYTES_PER_CHUNK = 32; // Number of bytes per serialized length prefix.\n\n/** @ignore */\n\nexports.BYTES_PER_CHUNK = BYTES_PER_CHUNK;\nconst BYTES_PER_LENGTH_PREFIX = 4;\nexports.BYTES_PER_LENGTH_PREFIX = BYTES_PER_LENGTH_PREFIX;\n//# sourceMappingURL=constants.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.CompositeArrayType = exports.BasicArrayType = void 0;\n\nvar _abstract = require(\"./abstract\");\n\nvar _errorPath = require(\"../../util/errorPath\");\n\nvar _persistentMerkleTree = require(\"@chainsafe/persistent-merkle-tree\");\n\nvar _treeValue = require(\"../../backings/tree/treeValue\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass BasicArrayType extends _abstract.CompositeType {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"elementType\", void 0);\n\n    this.elementType = options.elementType;\n  }\n\n  struct_getSerializedLength(value) {\n    return this.elementType.struct_getSerializedLength() * this.struct_getLength(value);\n  }\n\n  getMaxSerializedLength() {\n    return this.getMaxLength() * this.elementType.getMaxSerializedLength();\n  }\n\n  getMinSerializedLength() {\n    return this.getMinLength() * this.elementType.getMinSerializedLength();\n  }\n\n  struct_assertValidValue(value) {\n    for (let i = 0; i < this.struct_getLength(value); i++) {\n      try {\n        this.elementType.struct_assertValidValue(value[i]);\n      } catch (e) {\n        throw new Error(\"Invalid element \".concat(i, \": \").concat(e.message));\n      }\n    }\n  }\n\n  struct_equals(value1, value2) {\n    if (this.struct_getLength(value1) !== this.struct_getLength(value2)) {\n      return false;\n    }\n\n    for (let i = 0; i < this.struct_getLength(value1); i++) {\n      if (!this.elementType.struct_equals(value1[i], value2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  struct_clone(value) {\n    const newValue = this.struct_defaultValue();\n\n    for (let i = 0; i < this.struct_getLength(value); i++) {\n      newValue[i] = this.elementType.struct_clone(value[i]);\n    }\n\n    return newValue;\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    const elementSize = this.elementType.struct_getSerializedLength();\n    return Array.from({\n      length: (end - start) / elementSize\n    }, (_, i) => this.elementType.struct_deserializeFromBytes(data, start + i * elementSize));\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    const length = this.struct_getLength(value);\n    let index = offset;\n\n    for (let i = 0; i < length; i++) {\n      index = this.elementType.struct_serializeToBytes(value[i], output, index);\n    }\n\n    return index;\n  }\n\n  struct_getRootAtChunkIndex(value, index) {\n    const output = new Uint8Array(32);\n    const itemSize = this.elementType.struct_getSerializedLength();\n    const itemsInChunk = Math.floor(32 / itemSize);\n    const firstIndex = index * itemsInChunk; // not inclusive\n\n    const lastIndex = Math.min(this.struct_getLength(value), firstIndex + itemsInChunk); // i = array index, grows by 1\n    // j = data offset, grows by itemSize\n\n    for (let i = firstIndex, j = 0; i < lastIndex; i++, j += itemSize) {\n      this.elementType.struct_serializeToBytes(value[i], output, j);\n    }\n\n    return output;\n  }\n\n  struct_getPropertyNames(value) {\n    const length = this.struct_getLength(value);\n    return Array.from({\n      length\n    }, (_, i) => i).concat([\"length\"]);\n  }\n\n  struct_convertFromJson(data) {\n    return Array.from({\n      length: data.length\n    }, (_, i) => this.elementType.fromJson(data[i]));\n  }\n\n  struct_convertToJson(value) {\n    return Array.from({\n      length: this.struct_getLength(value)\n    }, (_, i) => this.elementType.struct_convertToJson(value[i]));\n  }\n\n  struct_convertToTree(value) {\n    if ((0, _treeValue.isTreeBacked)(value)) return value.tree.clone();\n    const contents = [];\n\n    for (const chunk of this.struct_yieldChunkRoots(value)) {\n      contents.push(new _persistentMerkleTree.LeafNode(chunk));\n    }\n\n    return new _persistentMerkleTree.Tree((0, _persistentMerkleTree.subtreeFillToContents)(contents, this.getChunkDepth()));\n  }\n\n  tree_convertToStruct(target) {\n    const value = this.struct_defaultValue();\n    const length = this.tree_getLength(target);\n\n    for (let i = 0; i < length; i++) {\n      value[i] = this.tree_getValueAtIndex(target, i);\n    }\n\n    return value;\n  }\n\n  tree_getSerializedLength(target) {\n    return this.elementType.struct_getSerializedLength() * this.tree_getLength(target);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const target = this.tree_defaultValue();\n    const byteLength = end - start;\n    const chunkCount = Math.ceil(byteLength / 32);\n\n    for (let i = 0; i < chunkCount; i++) {\n      // view of the chunk, shared buffer from `data`\n      const dataChunk = new Uint8Array(data.buffer, data.byteOffset + start + i * 32, Math.min(32, byteLength - i * 32)); // copy chunk into new memory\n\n      const chunk = new Uint8Array(32);\n      chunk.set(dataChunk);\n      this.tree_setRootAtChunkIndex(target, i, chunk, true // expand tree as needed\n      );\n    }\n\n    return target;\n  }\n\n  tree_serializeToBytes(target, output, offset) {\n    const size = this.tree_getSerializedLength(target);\n    const fullChunkCount = Math.floor(size / 32);\n    const remainder = size % 32;\n    let i = 0;\n\n    if (fullChunkCount > 0) {\n      for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), 0, fullChunkCount)) {\n        output.set(node.root, offset + i * 32);\n        i++;\n      }\n    }\n\n    if (remainder) {\n      output.set(this.tree_getRootAtChunkIndex(target, fullChunkCount).slice(0, remainder), offset + i * 32);\n    }\n\n    return offset + size;\n  }\n\n  getPropertyGindex(prop) {\n    return this.getGindexAtChunkIndex(this.getChunkIndex(prop));\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  getPropertyType(prop) {\n    return this.elementType;\n  }\n\n  *tree_iterateValues(target) {\n    const length = this.tree_getLength(target);\n\n    if (length === 0) {\n      return;\n    }\n\n    const elementSize = this.elementType.struct_getSerializedLength();\n\n    if (32 % elementSize !== 0) {\n      throw new Error(\"cannot handle a non-chunk-alignable elementType\");\n    }\n\n    let left = length;\n\n    for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), 0, this.tree_getChunkCount(target))) {\n      const chunk = node.root;\n\n      for (let offset = 0; offset < 32; offset += elementSize) {\n        yield this.elementType.struct_deserializeFromBytes(chunk, offset);\n        left--;\n\n        if (left === 0) {\n          return;\n        }\n      }\n    }\n  }\n\n  *tree_readonlyIterateValues(target) {\n    yield* this.tree_iterateValues(target);\n  }\n\n  getChunkOffset(index) {\n    const elementSize = this.elementType.struct_getSerializedLength();\n    return index % Math.ceil(32 / elementSize) * elementSize;\n  }\n\n  getChunkIndex(index) {\n    return Math.floor(index / Math.ceil(32 / this.elementType.struct_getSerializedLength()));\n  }\n\n  tree_getValueAtIndex(target, index) {\n    const chunk = this.tree_getRootAtChunkIndex(target, this.getChunkIndex(index));\n    return this.elementType.struct_deserializeFromBytes(chunk, this.getChunkOffset(index));\n  }\n\n  tree_setValueAtIndex(target, index, value, expand = false) {\n    const chunkGindex = this.getGindexAtChunkIndex(this.getChunkIndex(index)); // copy data from old chunk, use new memory to set a new chunk\n\n    const chunk = new Uint8Array(32);\n    chunk.set(target.getRoot(chunkGindex));\n    this.elementType.struct_serializeToBytes(value, chunk, this.getChunkOffset(index));\n    target.setRoot(chunkGindex, chunk, expand);\n    return true;\n  }\n\n  tree_getProperty(target, property) {\n    const length = this.tree_getLength(target);\n\n    if (property === \"length\") {\n      return length;\n    }\n\n    const index = Number(property);\n\n    if (Number.isNaN(index)) {\n      return undefined;\n    }\n\n    if (index >= length) {\n      return undefined;\n    }\n\n    return this.tree_getValueAtIndex(target, index);\n  }\n\n  tree_setProperty(target, property, value, expand = false) {\n    return this.tree_setValueAtIndex(target, property, value, expand);\n  }\n\n  tree_deleteProperty(target, property) {\n    return this.tree_setProperty(target, property, this.elementType.struct_defaultValue());\n  }\n\n  tree_getPropertyNames(target) {\n    return Array.from({\n      length: this.tree_getLength(target)\n    }, (_, i) => String(i)).concat(\"length\");\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  bytes_getVariableOffsets(target) {\n    return [];\n  }\n\n  tree_getLeafGindices(target, root = BigInt(1)) {\n    const chunkCount = this.tree_getChunkCount(target);\n    const startIndex = (0, _persistentMerkleTree.concatGindices)([root, (0, _persistentMerkleTree.toGindex)(this.getChunkDepth(), BigInt(0))]);\n    const gindices = [];\n\n    for (let i = 0, gindex = startIndex; i < chunkCount; i++, gindex++) {\n      gindices.push(gindex);\n    }\n\n    return gindices;\n  }\n\n}\n\nexports.BasicArrayType = BasicArrayType;\n\nclass CompositeArrayType extends _abstract.CompositeType {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"elementType\", void 0);\n\n    this.elementType = options.elementType;\n  }\n\n  struct_getSerializedLength(value) {\n    if (this.elementType.hasVariableSerializedLength()) {\n      let s = 0;\n\n      for (let i = 0; i < this.struct_getLength(value); i++) {\n        s += this.elementType.struct_getSerializedLength(value[i]) + 4;\n      }\n\n      return s;\n    } else {\n      return this.elementType.struct_getSerializedLength(null) * this.struct_getLength(value);\n    }\n  }\n\n  getMaxSerializedLength() {\n    if (this.elementType.hasVariableSerializedLength()) {\n      return this.getMaxLength() * 4 + this.getMaxLength() * this.elementType.getMaxSerializedLength();\n    } else {\n      return this.getMaxLength() * this.elementType.getMaxSerializedLength();\n    }\n  }\n\n  getMinSerializedLength() {\n    if (this.elementType.hasVariableSerializedLength()) {\n      return this.getMinLength() * 4 + this.getMinLength() * this.elementType.getMinSerializedLength();\n    } else {\n      return this.getMinLength() * this.elementType.getMinSerializedLength();\n    }\n  }\n\n  struct_assertValidValue(value) {\n    for (let i = 0; i < this.struct_getLength(value); i++) {\n      try {\n        this.elementType.struct_assertValidValue(value[i]);\n      } catch (e) {\n        throw new Error(\"Invalid element \".concat(i, \": \").concat(e.message));\n      }\n    }\n  }\n\n  struct_equals(value1, value2) {\n    if (this.struct_getLength(value1) !== this.struct_getLength(value2)) {\n      return false;\n    }\n\n    for (let i = 0; i < this.struct_getLength(value1); i++) {\n      if (!this.elementType.struct_equals(value1[i], value2[i])) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  struct_clone(value) {\n    const newValue = this.struct_defaultValue();\n\n    for (let i = 0; i < this.struct_getLength(value); i++) {\n      newValue[i] = this.elementType.struct_clone(value[i]);\n    }\n\n    return newValue;\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n\n    if (start === end) {\n      return [];\n    }\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      const value = []; // all elements variable-sized\n      // indices contain offsets\n\n      let currentIndex = start;\n      let nextIndex; // data exists between offsets\n\n      const fixedSection = new DataView(data.buffer, data.byteOffset);\n      const firstOffset = start + fixedSection.getUint32(start, true);\n      let currentOffset = firstOffset;\n      let nextOffset;\n\n      while (currentIndex < firstOffset) {\n        if (currentOffset > end) {\n          throw new Error(\"Offset out of bounds\");\n        }\n\n        nextIndex = currentIndex + 4;\n        nextOffset = nextIndex === firstOffset ? end : start + fixedSection.getUint32(nextIndex, true);\n\n        if (currentOffset > nextOffset) {\n          throw new Error(\"Offsets must be increasing\");\n        }\n\n        try {\n          value.push(this.elementType.struct_deserializeFromBytes(data, currentOffset, nextOffset));\n        } catch (e) {\n          throw new _errorPath.SszErrorPath(e, value.length);\n        }\n\n        currentIndex = nextIndex;\n        currentOffset = nextOffset;\n      }\n\n      if (firstOffset !== currentIndex) {\n        throw new Error(\"First offset skips variable data\");\n      }\n\n      return value;\n    } else {\n      const elementSize = this.elementType.struct_getSerializedLength(null);\n      return Array.from({\n        length: (end - start) / elementSize\n      }, (_, i) => this.elementType.struct_deserializeFromBytes(data, start + i * elementSize, start + (i + 1) * elementSize));\n    }\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    const length = this.struct_getLength(value);\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      let variableIndex = offset + length * 4;\n      const fixedSection = new DataView(output.buffer, output.byteOffset + offset);\n\n      for (let i = 0; i < length; i++) {\n        // write offset\n        fixedSection.setUint32(i * 4, variableIndex - offset, true); // write serialized element to variable section\n\n        variableIndex = this.elementType.struct_serializeToBytes(value[i], output, variableIndex);\n      }\n\n      return variableIndex;\n    } else {\n      let index = offset;\n\n      for (let i = 0; i < length; i++) {\n        index = this.elementType.struct_serializeToBytes(value[i], output, index);\n      }\n\n      return index;\n    }\n  }\n\n  struct_getRootAtChunkIndex(value, index) {\n    return this.elementType.hashTreeRoot(value[index]);\n  }\n\n  struct_getPropertyNames(value) {\n    const length = this.struct_getLength(value);\n    return Array.from({\n      length\n    }, (_, i) => i).concat([\"length\"]);\n  }\n\n  struct_convertFromJson(data, options) {\n    return Array.from({\n      length: data.length\n    }, (_, i) => this.elementType.struct_convertFromJson(data[i], options));\n  }\n\n  struct_convertToJson(value, options) {\n    return Array.from({\n      length: this.struct_getLength(value)\n    }, (_, i) => this.elementType.struct_convertToJson(value[i], options));\n  }\n\n  struct_convertToTree(value) {\n    if ((0, _treeValue.isTreeBacked)(value)) return value.tree.clone();\n    const contents = [];\n\n    for (const element of value) {\n      contents.push(this.elementType.struct_convertToTree(element).rootNode);\n    }\n\n    return new _persistentMerkleTree.Tree((0, _persistentMerkleTree.subtreeFillToContents)(contents, this.getChunkDepth()));\n  }\n\n  tree_convertToStruct(target) {\n    const value = this.struct_defaultValue();\n    const length = this.tree_getLength(target);\n\n    for (let i = 0; i < length; i++) {\n      value[i] = this.elementType.tree_convertToStruct(this.tree_getSubtreeAtChunkIndex(target, i));\n    }\n\n    return value;\n  }\n\n  tree_getSerializedLength(target) {\n    if (this.elementType.hasVariableSerializedLength()) {\n      let s = 0;\n\n      for (let i = 0; i < this.tree_getLength(target); i++) {\n        s += this.elementType.tree_getSerializedLength(this.tree_getSubtreeAtChunkIndex(target, i)) + 4;\n      }\n\n      return s;\n    } else {\n      return this.elementType.tree_getSerializedLength(null) * this.tree_getLength(target);\n    }\n  }\n\n  tree_serializeToBytes(target, output, offset) {\n    const length = this.tree_getLength(target);\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      let variableIndex = offset + length * 4;\n      const fixedSection = new DataView(output.buffer, output.byteOffset + offset, length * 4);\n      let i = 0;\n\n      for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), i, length)) {\n        // write offset\n        fixedSection.setUint32(i * 4, variableIndex - offset, true); // write serialized element to variable section\n\n        variableIndex = this.elementType.tree_serializeToBytes(new _persistentMerkleTree.Tree(node), output, variableIndex);\n        i++;\n      }\n\n      return variableIndex;\n    } else {\n      let index = offset;\n      let i = 0;\n\n      for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), i, length)) {\n        index = this.elementType.tree_serializeToBytes(new _persistentMerkleTree.Tree(node), output, index);\n        i++;\n      }\n\n      return index;\n    }\n  }\n\n  getPropertyGindex(prop) {\n    return this.getGindexAtChunkIndex(prop);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  getPropertyType(prop) {\n    return this.elementType;\n  }\n\n  tree_getProperty(target, property) {\n    const length = this.tree_getLength(target);\n\n    if (property === \"length\") {\n      return length;\n    }\n\n    const index = Number(property);\n\n    if (Number.isNaN(index)) {\n      return undefined;\n    }\n\n    if (index >= length) {\n      return undefined;\n    }\n\n    return this.tree_getSubtreeAtChunkIndex(target, index);\n  }\n\n  tree_setProperty(target, property, value, expand = false) {\n    this.tree_setSubtreeAtChunkIndex(target, property, value, expand);\n    return true;\n  }\n\n  tree_deleteProperty(target, property) {\n    return this.tree_setProperty(target, property, this.elementType.tree_defaultValue());\n  }\n\n  tree_getPropertyNames(target) {\n    return Array.from({\n      length: this.tree_getLength(target)\n    }, (_, i) => i).concat([\"length\"]);\n  }\n\n  *tree_iterateValues(target) {\n    for (const gindex of (0, _persistentMerkleTree.iterateAtDepth)(this.getChunkDepth(), BigInt(0), BigInt(this.tree_getLength(target)))) {\n      yield target.getSubtree(gindex);\n    }\n  }\n\n  *tree_readonlyIterateValues(target) {\n    for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), 0, this.tree_getLength(target))) {\n      yield new _persistentMerkleTree.Tree(node);\n    }\n  }\n\n  bytes_getVariableOffsets(target) {\n    if (this.elementType.hasVariableSerializedLength()) {\n      if (target.length === 0) {\n        return [];\n      }\n\n      const offsets = []; // all elements are variable-sized\n      // indices contain offsets, which are indices deeper in the byte array\n\n      const fixedSection = new DataView(target.buffer, target.byteOffset);\n      const firstOffset = fixedSection.getUint32(0, true);\n      let currentOffset = firstOffset;\n      let nextOffset;\n      let currentIndex = 0;\n      let nextIndex = 0;\n\n      while (currentIndex < firstOffset) {\n        if (currentOffset > target.length) {\n          throw new Error(\"Offset out of bounds\");\n        }\n\n        nextIndex = currentIndex + 4;\n        nextOffset = nextIndex === firstOffset ? target.length : fixedSection.getUint32(nextIndex, true);\n\n        if (currentOffset > nextOffset) {\n          throw new Error(\"Offsets must be increasing\");\n        }\n\n        offsets.push([currentOffset, nextOffset]);\n        currentIndex = nextIndex;\n        currentOffset = nextOffset;\n      }\n\n      if (firstOffset !== currentIndex) {\n        throw new Error(\"First offset skips variable data\");\n      }\n\n      return offsets;\n    } else {\n      return [];\n    }\n  }\n\n  tree_getLeafGindices(target, root = BigInt(1)) {\n    // Underlying elements exist one per chunk\n    // Iterate through chunk gindices, recursively fetching leaf gindices from each chunk\n    const chunkCount = this.tree_getChunkCount(target);\n    const gindices = [];\n    const startIndex = (0, _persistentMerkleTree.toGindex)(this.getChunkDepth(), BigInt(0));\n    const extendedStartIndex = (0, _persistentMerkleTree.concatGindices)([root, startIndex]);\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      if (!target) {\n        throw new Error(\"variable type requires tree argument to get leaves\");\n      } // variable-length elements must pass the underlying subtrees to determine the length\n\n\n      for (let i = 0, gindex = startIndex, extendedGindex = extendedStartIndex; i < chunkCount; i++, gindex++, extendedGindex++) {\n        gindices.push(...this.elementType.tree_getLeafGindices(target.getSubtree(gindex), extendedGindex));\n      }\n    } else {\n      for (let i = 0, gindex = extendedStartIndex; i < chunkCount; i++, gindex++) {\n        gindices.push(...this.elementType.tree_getLeafGindices(undefined, gindex));\n      }\n    }\n\n    return gindices;\n  }\n\n}\n\nexports.CompositeArrayType = CompositeArrayType;\n//# sourceMappingURL=array.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isVectorType = isVectorType;\nexports.CompositeVectorType = exports.BasicVectorType = exports.VectorType = exports.VECTOR_TYPE = void 0;\n\nvar _array = require(\"./array\");\n\nvar _basic = require(\"../basic\");\n\nvar _type = require(\"../type\");\n\nvar _persistentMerkleTree = require(\"@chainsafe/persistent-merkle-tree\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst VECTOR_TYPE = Symbol.for(\"ssz/VectorType\"); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexports.VECTOR_TYPE = VECTOR_TYPE;\n\nfunction isVectorType(type) {\n  return (0, _type.isTypeOf)(type, VECTOR_TYPE);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\n// Trick typescript into treating VectorType as a constructor\nconst VectorType = // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction VectorType(options) {\n  if ((0, _basic.isBasicType)(options.elementType)) {\n    return new BasicVectorType(options);\n  } else {\n    return new CompositeVectorType(options);\n  }\n};\n\nexports.VectorType = VectorType;\n\nclass BasicVectorType extends _array.BasicArrayType {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"length\", void 0);\n\n    this.length = options.length;\n\n    this._typeSymbols.add(VECTOR_TYPE);\n  }\n\n  struct_defaultValue() {\n    return Array.from({\n      length: this.length\n    }, () => {\n      return this.elementType.struct_defaultValue();\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_getLength(value) {\n    return this.length;\n  }\n\n  getMaxLength() {\n    return this.length;\n  }\n\n  getMinLength() {\n    return this.length;\n  }\n\n  bytes_validate(data, start, end) {\n    super.bytes_validate(data, start, end);\n\n    if (end - start !== this.size(null)) {\n      throw new Error(\"Incorrect deserialized vector length\");\n    }\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    return super.struct_deserializeFromBytes(data, start, end);\n  }\n\n  struct_assertValidValue(value) {\n    const actualLength = value.length;\n    const expectedLength = this.struct_getLength(value);\n\n    if (actualLength !== expectedLength) {\n      throw new Error(\"Invalid vector length: expected \".concat(expectedLength, \", actual \").concat(actualLength));\n    }\n\n    super.struct_assertValidValue(value);\n  }\n\n  struct_convertFromJson(data) {\n    if (!Array.isArray(data)) {\n      throw new Error(\"Invalid JSON vector: expected an Array\");\n    }\n\n    const expectedLength = this.length;\n\n    if (data.length !== expectedLength) {\n      throw new Error(\"Invalid JSON vector length: expected \".concat(expectedLength, \", actual \").concat(data.length));\n    }\n\n    return super.struct_convertFromJson(data);\n  }\n\n  tree_defaultNode() {\n    if (!this._defaultNode) {\n      this._defaultNode = (0, _persistentMerkleTree.subtreeFillToLength)((0, _persistentMerkleTree.zeroNode)(0), this.getChunkDepth(), this.getMaxChunkCount());\n    }\n\n    return this._defaultNode;\n  }\n\n  tree_defaultValue() {\n    return new _persistentMerkleTree.Tree(this.tree_defaultNode());\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  tree_getLength(target) {\n    return this.length;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    if (end - start !== this.struct_getSerializedLength(null)) {\n      throw new Error(\"Incorrect deserialized vector length\");\n    }\n\n    return super.tree_deserializeFromBytes(data, start, end);\n  }\n\n  tree_setProperty(target, property, value) {\n    if (property >= this.tree_getLength(target)) {\n      throw new Error(\"Invalid array index\");\n    }\n\n    return super.tree_setProperty(target, property, value, false);\n  }\n\n  hasVariableSerializedLength() {\n    return false;\n  }\n\n  getMaxChunkCount() {\n    return Math.ceil(this.length * this.elementType.size() / 32);\n  }\n\n}\n\nexports.BasicVectorType = BasicVectorType;\n\nclass CompositeVectorType extends _array.CompositeArrayType {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"length\", void 0);\n\n    this.length = options.length;\n\n    this._typeSymbols.add(VECTOR_TYPE);\n  }\n\n  struct_defaultValue() {\n    return Array.from({\n      length: this.length\n    }, () => {\n      return this.elementType.struct_defaultValue();\n    });\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_getLength(value) {\n    return this.length;\n  }\n\n  getMaxLength() {\n    return this.length;\n  }\n\n  getMinLength() {\n    return this.length;\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    const value = super.struct_deserializeFromBytes(data, start, end);\n\n    if (value.length !== this.length) {\n      throw new Error(\"Incorrect deserialized vector length\");\n    }\n\n    return value;\n  }\n\n  struct_assertValidValue(value) {\n    const actualLength = value.length;\n    const expectedLength = this.struct_getLength(value);\n\n    if (actualLength !== expectedLength) {\n      throw new Error(\"Invalid vector length: expected \".concat(expectedLength, \", actual \").concat(actualLength));\n    }\n\n    super.struct_assertValidValue(value);\n  }\n\n  struct_convertFromJson(data) {\n    if (!Array.isArray(data)) {\n      throw new Error(\"Invalid JSON vector: expected an Array\");\n    }\n\n    const expectedLength = this.length;\n\n    if (data.length !== expectedLength) {\n      throw new Error(\"Invalid JSON vector length: expected \".concat(expectedLength, \", actual \").concat(data.length));\n    }\n\n    return super.struct_convertFromJson(data);\n  }\n\n  tree_defaultNode() {\n    if (!this._defaultNode) {\n      this._defaultNode = (0, _persistentMerkleTree.subtreeFillToLength)(this.elementType.tree_defaultNode(), this.getChunkDepth(), this.length);\n    }\n\n    return this._defaultNode;\n  }\n\n  tree_defaultValue() {\n    return new _persistentMerkleTree.Tree(this.tree_defaultNode());\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  tree_getLength(target) {\n    return this.length;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const target = this.tree_defaultValue();\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      const offsets = this.bytes_getVariableOffsets(new Uint8Array(data.buffer, data.byteOffset + start, end - start));\n\n      if (offsets.length !== this.length) {\n        throw new Error(\"Incorrect deserialized vector length\");\n      }\n\n      for (let i = 0; i < offsets.length; i++) {\n        const [currentOffset, nextOffset] = offsets[i];\n        this.tree_setSubtreeAtChunkIndex(target, i, this.elementType.tree_deserializeFromBytes(data, start + currentOffset, start + nextOffset));\n      }\n    } else {\n      const elementSize = this.elementType.struct_getSerializedLength(null);\n      const length = (end - start) / elementSize;\n\n      if (length !== this.length) {\n        throw new Error(\"Incorrect deserialized vector length\");\n      }\n\n      for (let i = 0; i < length; i++) {\n        this.tree_setSubtreeAtChunkIndex(target, i, this.elementType.tree_deserializeFromBytes(data, start + i * elementSize, start + (i + 1) * elementSize));\n      }\n    }\n\n    return target;\n  }\n\n  setProperty(target, property, value) {\n    if (property >= this.tree_getLength(target)) {\n      throw new Error(\"Invalid array index\");\n    }\n\n    return super.tree_setProperty(target, property, value, false);\n  }\n\n  hasVariableSerializedLength() {\n    return this.elementType.hasVariableSerializedLength();\n  }\n\n  getMaxChunkCount() {\n    return this.length;\n  }\n\n}\n\nexports.CompositeVectorType = CompositeVectorType;\n//# sourceMappingURL=vector.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ssz = exports.ts = void 0;\n\nvar _ts = _interopRequireWildcard(require(\"./types\"));\n\nexports.ts = _ts;\n\nvar _ssz = _interopRequireWildcard(require(\"./sszTypes\"));\n\nexports.ssz = _ssz;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n//# sourceMappingURL=index.js.map","'use strict';\n// ECMAScript 6 symbols shim\nvar global = require('./_global');\nvar has = require('./_has');\nvar DESCRIPTORS = require('./_descriptors');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar META = require('./_meta').KEY;\nvar $fails = require('./_fails');\nvar shared = require('./_shared');\nvar setToStringTag = require('./_set-to-string-tag');\nvar uid = require('./_uid');\nvar wks = require('./_wks');\nvar wksExt = require('./_wks-ext');\nvar wksDefine = require('./_wks-define');\nvar enumKeys = require('./_enum-keys');\nvar isArray = require('./_is-array');\nvar anObject = require('./_an-object');\nvar isObject = require('./_is-object');\nvar toObject = require('./_to-object');\nvar toIObject = require('./_to-iobject');\nvar toPrimitive = require('./_to-primitive');\nvar createDesc = require('./_property-desc');\nvar _create = require('./_object-create');\nvar gOPNExt = require('./_object-gopn-ext');\nvar $GOPD = require('./_object-gopd');\nvar $GOPS = require('./_object-gops');\nvar $DP = require('./_object-dp');\nvar $keys = require('./_object-keys');\nvar gOPD = $GOPD.f;\nvar dP = $DP.f;\nvar gOPN = gOPNExt.f;\nvar $Symbol = global.Symbol;\nvar $JSON = global.JSON;\nvar _stringify = $JSON && $JSON.stringify;\nvar PROTOTYPE = 'prototype';\nvar HIDDEN = wks('_hidden');\nvar TO_PRIMITIVE = wks('toPrimitive');\nvar isEnum = {}.propertyIsEnumerable;\nvar SymbolRegistry = shared('symbol-registry');\nvar AllSymbols = shared('symbols');\nvar OPSymbols = shared('op-symbols');\nvar ObjectProto = Object[PROTOTYPE];\nvar USE_NATIVE = typeof $Symbol == 'function' && !!$GOPS.f;\nvar QObject = global.QObject;\n// Don't use setters in Qt Script, https://github.com/zloirock/core-js/issues/173\nvar setter = !QObject || !QObject[PROTOTYPE] || !QObject[PROTOTYPE].findChild;\n\n// fallback for old Android, https://code.google.com/p/v8/issues/detail?id=687\nvar setSymbolDesc = DESCRIPTORS && $fails(function () {\n  return _create(dP({}, 'a', {\n    get: function () { return dP(this, 'a', { value: 7 }).a; }\n  })).a != 7;\n}) ? function (it, key, D) {\n  var protoDesc = gOPD(ObjectProto, key);\n  if (protoDesc) delete ObjectProto[key];\n  dP(it, key, D);\n  if (protoDesc && it !== ObjectProto) dP(ObjectProto, key, protoDesc);\n} : dP;\n\nvar wrap = function (tag) {\n  var sym = AllSymbols[tag] = _create($Symbol[PROTOTYPE]);\n  sym._k = tag;\n  return sym;\n};\n\nvar isSymbol = USE_NATIVE && typeof $Symbol.iterator == 'symbol' ? function (it) {\n  return typeof it == 'symbol';\n} : function (it) {\n  return it instanceof $Symbol;\n};\n\nvar $defineProperty = function defineProperty(it, key, D) {\n  if (it === ObjectProto) $defineProperty(OPSymbols, key, D);\n  anObject(it);\n  key = toPrimitive(key, true);\n  anObject(D);\n  if (has(AllSymbols, key)) {\n    if (!D.enumerable) {\n      if (!has(it, HIDDEN)) dP(it, HIDDEN, createDesc(1, {}));\n      it[HIDDEN][key] = true;\n    } else {\n      if (has(it, HIDDEN) && it[HIDDEN][key]) it[HIDDEN][key] = false;\n      D = _create(D, { enumerable: createDesc(0, false) });\n    } return setSymbolDesc(it, key, D);\n  } return dP(it, key, D);\n};\nvar $defineProperties = function defineProperties(it, P) {\n  anObject(it);\n  var keys = enumKeys(P = toIObject(P));\n  var i = 0;\n  var l = keys.length;\n  var key;\n  while (l > i) $defineProperty(it, key = keys[i++], P[key]);\n  return it;\n};\nvar $create = function create(it, P) {\n  return P === undefined ? _create(it) : $defineProperties(_create(it), P);\n};\nvar $propertyIsEnumerable = function propertyIsEnumerable(key) {\n  var E = isEnum.call(this, key = toPrimitive(key, true));\n  if (this === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return false;\n  return E || !has(this, key) || !has(AllSymbols, key) || has(this, HIDDEN) && this[HIDDEN][key] ? E : true;\n};\nvar $getOwnPropertyDescriptor = function getOwnPropertyDescriptor(it, key) {\n  it = toIObject(it);\n  key = toPrimitive(key, true);\n  if (it === ObjectProto && has(AllSymbols, key) && !has(OPSymbols, key)) return;\n  var D = gOPD(it, key);\n  if (D && has(AllSymbols, key) && !(has(it, HIDDEN) && it[HIDDEN][key])) D.enumerable = true;\n  return D;\n};\nvar $getOwnPropertyNames = function getOwnPropertyNames(it) {\n  var names = gOPN(toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (!has(AllSymbols, key = names[i++]) && key != HIDDEN && key != META) result.push(key);\n  } return result;\n};\nvar $getOwnPropertySymbols = function getOwnPropertySymbols(it) {\n  var IS_OP = it === ObjectProto;\n  var names = gOPN(IS_OP ? OPSymbols : toIObject(it));\n  var result = [];\n  var i = 0;\n  var key;\n  while (names.length > i) {\n    if (has(AllSymbols, key = names[i++]) && (IS_OP ? has(ObjectProto, key) : true)) result.push(AllSymbols[key]);\n  } return result;\n};\n\n// 19.4.1.1 Symbol([description])\nif (!USE_NATIVE) {\n  $Symbol = function Symbol() {\n    if (this instanceof $Symbol) throw TypeError('Symbol is not a constructor!');\n    var tag = uid(arguments.length > 0 ? arguments[0] : undefined);\n    var $set = function (value) {\n      if (this === ObjectProto) $set.call(OPSymbols, value);\n      if (has(this, HIDDEN) && has(this[HIDDEN], tag)) this[HIDDEN][tag] = false;\n      setSymbolDesc(this, tag, createDesc(1, value));\n    };\n    if (DESCRIPTORS && setter) setSymbolDesc(ObjectProto, tag, { configurable: true, set: $set });\n    return wrap(tag);\n  };\n  redefine($Symbol[PROTOTYPE], 'toString', function toString() {\n    return this._k;\n  });\n\n  $GOPD.f = $getOwnPropertyDescriptor;\n  $DP.f = $defineProperty;\n  require('./_object-gopn').f = gOPNExt.f = $getOwnPropertyNames;\n  require('./_object-pie').f = $propertyIsEnumerable;\n  $GOPS.f = $getOwnPropertySymbols;\n\n  if (DESCRIPTORS && !require('./_library')) {\n    redefine(ObjectProto, 'propertyIsEnumerable', $propertyIsEnumerable, true);\n  }\n\n  wksExt.f = function (name) {\n    return wrap(wks(name));\n  };\n}\n\n$export($export.G + $export.W + $export.F * !USE_NATIVE, { Symbol: $Symbol });\n\nfor (var es6Symbols = (\n  // 19.4.2.2, 19.4.2.3, 19.4.2.4, 19.4.2.6, 19.4.2.8, 19.4.2.9, 19.4.2.10, 19.4.2.11, 19.4.2.12, 19.4.2.13, 19.4.2.14\n  'hasInstance,isConcatSpreadable,iterator,match,replace,search,species,split,toPrimitive,toStringTag,unscopables'\n).split(','), j = 0; es6Symbols.length > j;)wks(es6Symbols[j++]);\n\nfor (var wellKnownSymbols = $keys(wks.store), k = 0; wellKnownSymbols.length > k;) wksDefine(wellKnownSymbols[k++]);\n\n$export($export.S + $export.F * !USE_NATIVE, 'Symbol', {\n  // 19.4.2.1 Symbol.for(key)\n  'for': function (key) {\n    return has(SymbolRegistry, key += '')\n      ? SymbolRegistry[key]\n      : SymbolRegistry[key] = $Symbol(key);\n  },\n  // 19.4.2.5 Symbol.keyFor(sym)\n  keyFor: function keyFor(sym) {\n    if (!isSymbol(sym)) throw TypeError(sym + ' is not a symbol!');\n    for (var key in SymbolRegistry) if (SymbolRegistry[key] === sym) return key;\n  },\n  useSetter: function () { setter = true; },\n  useSimple: function () { setter = false; }\n});\n\n$export($export.S + $export.F * !USE_NATIVE, 'Object', {\n  // 19.1.2.2 Object.create(O [, Properties])\n  create: $create,\n  // 19.1.2.4 Object.defineProperty(O, P, Attributes)\n  defineProperty: $defineProperty,\n  // 19.1.2.3 Object.defineProperties(O, Properties)\n  defineProperties: $defineProperties,\n  // 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\n  getOwnPropertyDescriptor: $getOwnPropertyDescriptor,\n  // 19.1.2.7 Object.getOwnPropertyNames(O)\n  getOwnPropertyNames: $getOwnPropertyNames,\n  // 19.1.2.8 Object.getOwnPropertySymbols(O)\n  getOwnPropertySymbols: $getOwnPropertySymbols\n});\n\n// Chrome 38 and 39 `Object.getOwnPropertySymbols` fails on primitives\n// https://bugs.chromium.org/p/v8/issues/detail?id=3443\nvar FAILS_ON_PRIMITIVES = $fails(function () { $GOPS.f(1); });\n\n$export($export.S + $export.F * FAILS_ON_PRIMITIVES, 'Object', {\n  getOwnPropertySymbols: function getOwnPropertySymbols(it) {\n    return $GOPS.f(toObject(it));\n  }\n});\n\n// 24.3.2 JSON.stringify(value [, replacer [, space]])\n$JSON && $export($export.S + $export.F * (!USE_NATIVE || $fails(function () {\n  var S = $Symbol();\n  // MS Edge converts symbol values to JSON as {}\n  // WebKit converts symbol values to JSON as null\n  // V8 throws on boxed symbols\n  return _stringify([S]) != '[null]' || _stringify({ a: S }) != '{}' || _stringify(Object(S)) != '{}';\n})), 'JSON', {\n  stringify: function stringify(it) {\n    var args = [it];\n    var i = 1;\n    var replacer, $replacer;\n    while (arguments.length > i) args.push(arguments[i++]);\n    $replacer = replacer = args[1];\n    if (!isObject(replacer) && it === undefined || isSymbol(it)) return; // IE8 returns string on undefined\n    if (!isArray(replacer)) replacer = function (key, value) {\n      if (typeof $replacer == 'function') value = $replacer.call(this, key, value);\n      if (!isSymbol(value)) return value;\n    };\n    args[1] = replacer;\n    return _stringify.apply($JSON, args);\n  }\n});\n\n// 19.4.3.4 Symbol.prototype[@@toPrimitive](hint)\n$Symbol[PROTOTYPE][TO_PRIMITIVE] || require('./_hide')($Symbol[PROTOTYPE], TO_PRIMITIVE, $Symbol[PROTOTYPE].valueOf);\n// 19.4.3.5 Symbol.prototype[@@toStringTag]\nsetToStringTag($Symbol, 'Symbol');\n// 20.2.1.9 Math[@@toStringTag]\nsetToStringTag(Math, 'Math', true);\n// 24.3.3 JSON[@@toStringTag]\nsetToStringTag(global.JSON, 'JSON', true);\n","module.exports = !require('./_descriptors') && !require('./_fails')(function () {\n  return Object.defineProperty(require('./_dom-create')('div'), 'a', { get: function () { return 7; } }).a != 7;\n});\n","var isObject = require('./_is-object');\nvar document = require('./_global').document;\n// typeof document.createElement is 'object' in old IE\nvar is = isObject(document) && isObject(document.createElement);\nmodule.exports = function (it) {\n  return is ? document.createElement(it) : {};\n};\n","exports.f = require('./_wks');\n","var has = require('./_has');\nvar toIObject = require('./_to-iobject');\nvar arrayIndexOf = require('./_array-includes')(false);\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\n\nmodule.exports = function (object, names) {\n  var O = toIObject(object);\n  var i = 0;\n  var result = [];\n  var key;\n  for (key in O) if (key != IE_PROTO) has(O, key) && result.push(key);\n  // Don't enum bug & hidden keys\n  while (names.length > i) if (has(O, key = names[i++])) {\n    ~arrayIndexOf(result, key) || result.push(key);\n  }\n  return result;\n};\n","// fallback for non-array-like ES3 and non-enumerable old V8 strings\nvar cof = require('./_cof');\n// eslint-disable-next-line no-prototype-builtins\nmodule.exports = Object('z').propertyIsEnumerable(0) ? Object : function (it) {\n  return cof(it) == 'String' ? it.split('') : Object(it);\n};\n","var dP = require('./_object-dp');\nvar anObject = require('./_an-object');\nvar getKeys = require('./_object-keys');\n\nmodule.exports = require('./_descriptors') ? Object.defineProperties : function defineProperties(O, Properties) {\n  anObject(O);\n  var keys = getKeys(Properties);\n  var length = keys.length;\n  var i = 0;\n  var P;\n  while (length > i) dP.f(O, P = keys[i++], Properties[P]);\n  return O;\n};\n","var document = require('./_global').document;\nmodule.exports = document && document.documentElement;\n","// check on default Array iterator\nvar Iterators = require('./_iterators');\nvar ITERATOR = require('./_wks')('iterator');\nvar ArrayProto = Array.prototype;\n\nmodule.exports = function (it) {\n  return it !== undefined && (Iterators.Array === it || ArrayProto[ITERATOR] === it);\n};\n","'use strict';\nvar $defineProperty = require('./_object-dp');\nvar createDesc = require('./_property-desc');\n\nmodule.exports = function (object, index, value) {\n  if (index in object) $defineProperty.f(object, index, createDesc(0, value));\n  else object[index] = value;\n};\n","var classof = require('./_classof');\nvar ITERATOR = require('./_wks')('iterator');\nvar Iterators = require('./_iterators');\nmodule.exports = require('./_core').getIteratorMethod = function (it) {\n  if (it != undefined) return it[ITERATOR]\n    || it['@@iterator']\n    || Iterators[classof(it)];\n};\n","var ITERATOR = require('./_wks')('iterator');\nvar SAFE_CLOSING = false;\n\ntry {\n  var riter = [7][ITERATOR]();\n  riter['return'] = function () { SAFE_CLOSING = true; };\n  // eslint-disable-next-line no-throw-literal\n  Array.from(riter, function () { throw 2; });\n} catch (e) { /* empty */ }\n\nmodule.exports = function (exec, skipClosing) {\n  if (!skipClosing && !SAFE_CLOSING) return false;\n  var safe = false;\n  try {\n    var arr = [7];\n    var iter = arr[ITERATOR]();\n    iter.next = function () { return { done: safe = true }; };\n    arr[ITERATOR] = function () { return iter; };\n    exec(arr);\n  } catch (e) { /* empty */ }\n  return safe;\n};\n","'use strict';\nvar LIBRARY = require('./_library');\nvar $export = require('./_export');\nvar redefine = require('./_redefine');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar $iterCreate = require('./_iter-create');\nvar setToStringTag = require('./_set-to-string-tag');\nvar getPrototypeOf = require('./_object-gpo');\nvar ITERATOR = require('./_wks')('iterator');\nvar BUGGY = !([].keys && 'next' in [].keys()); // Safari has buggy iterators w/o `next`\nvar FF_ITERATOR = '@@iterator';\nvar KEYS = 'keys';\nvar VALUES = 'values';\n\nvar returnThis = function () { return this; };\n\nmodule.exports = function (Base, NAME, Constructor, next, DEFAULT, IS_SET, FORCED) {\n  $iterCreate(Constructor, NAME, next);\n  var getMethod = function (kind) {\n    if (!BUGGY && kind in proto) return proto[kind];\n    switch (kind) {\n      case KEYS: return function keys() { return new Constructor(this, kind); };\n      case VALUES: return function values() { return new Constructor(this, kind); };\n    } return function entries() { return new Constructor(this, kind); };\n  };\n  var TAG = NAME + ' Iterator';\n  var DEF_VALUES = DEFAULT == VALUES;\n  var VALUES_BUG = false;\n  var proto = Base.prototype;\n  var $native = proto[ITERATOR] || proto[FF_ITERATOR] || DEFAULT && proto[DEFAULT];\n  var $default = $native || getMethod(DEFAULT);\n  var $entries = DEFAULT ? !DEF_VALUES ? $default : getMethod('entries') : undefined;\n  var $anyNative = NAME == 'Array' ? proto.entries || $native : $native;\n  var methods, key, IteratorPrototype;\n  // Fix native\n  if ($anyNative) {\n    IteratorPrototype = getPrototypeOf($anyNative.call(new Base()));\n    if (IteratorPrototype !== Object.prototype && IteratorPrototype.next) {\n      // Set @@toStringTag to native iterators\n      setToStringTag(IteratorPrototype, TAG, true);\n      // fix for some old engines\n      if (!LIBRARY && typeof IteratorPrototype[ITERATOR] != 'function') hide(IteratorPrototype, ITERATOR, returnThis);\n    }\n  }\n  // fix Array#{values, @@iterator}.name in V8 / FF\n  if (DEF_VALUES && $native && $native.name !== VALUES) {\n    VALUES_BUG = true;\n    $default = function values() { return $native.call(this); };\n  }\n  // Define iterator\n  if ((!LIBRARY || FORCED) && (BUGGY || VALUES_BUG || !proto[ITERATOR])) {\n    hide(proto, ITERATOR, $default);\n  }\n  // Plug for library\n  Iterators[NAME] = $default;\n  Iterators[TAG] = returnThis;\n  if (DEFAULT) {\n    methods = {\n      values: DEF_VALUES ? $default : getMethod(VALUES),\n      keys: IS_SET ? $default : getMethod(KEYS),\n      entries: $entries\n    };\n    if (FORCED) for (key in methods) {\n      if (!(key in proto)) redefine(proto, key, methods[key]);\n    } else $export($export.P + $export.F * (BUGGY || VALUES_BUG), NAME, methods);\n  }\n  return methods;\n};\n","// 19.1.2.9 / 15.2.3.2 Object.getPrototypeOf(O)\nvar has = require('./_has');\nvar toObject = require('./_to-object');\nvar IE_PROTO = require('./_shared-key')('IE_PROTO');\nvar ObjectProto = Object.prototype;\n\nmodule.exports = Object.getPrototypeOf || function (O) {\n  O = toObject(O);\n  if (has(O, IE_PROTO)) return O[IE_PROTO];\n  if (typeof O.constructor == 'function' && O instanceof O.constructor) {\n    return O.constructor.prototype;\n  } return O instanceof Object ? ObjectProto : null;\n};\n","var global = require('./_global');\nvar hide = require('./_hide');\nvar uid = require('./_uid');\nvar TYPED = uid('typed_array');\nvar VIEW = uid('view');\nvar ABV = !!(global.ArrayBuffer && global.DataView);\nvar CONSTR = ABV;\nvar i = 0;\nvar l = 9;\nvar Typed;\n\nvar TypedArrayConstructors = (\n  'Int8Array,Uint8Array,Uint8ClampedArray,Int16Array,Uint16Array,Int32Array,Uint32Array,Float32Array,Float64Array'\n).split(',');\n\nwhile (i < l) {\n  if (Typed = global[TypedArrayConstructors[i++]]) {\n    hide(Typed.prototype, TYPED, true);\n    hide(Typed.prototype, VIEW, true);\n  } else CONSTR = false;\n}\n\nmodule.exports = {\n  ABV: ABV,\n  CONSTR: CONSTR,\n  TYPED: TYPED,\n  VIEW: VIEW\n};\n","var redefine = require('./_redefine');\nmodule.exports = function (target, src, safe) {\n  for (var key in src) redefine(target, key, src[key], safe);\n  return target;\n};\n","module.exports = function (it, Constructor, name, forbiddenField) {\n  if (!(it instanceof Constructor) || (forbiddenField !== undefined && forbiddenField in it)) {\n    throw TypeError(name + ': incorrect invocation!');\n  } return it;\n};\n","// https://tc39.github.io/ecma262/#sec-toindex\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nmodule.exports = function (it) {\n  if (it === undefined) return 0;\n  var number = toInteger(it);\n  var length = toLength(number);\n  if (number !== length) throw RangeError('Wrong length!');\n  return length;\n};\n","// 22.1.3.6 Array.prototype.fill(value, start = 0, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nmodule.exports = function fill(value /* , start = 0, end = @length */) {\n  var O = toObject(this);\n  var length = toLength(O.length);\n  var aLen = arguments.length;\n  var index = toAbsoluteIndex(aLen > 1 ? arguments[1] : undefined, length);\n  var end = aLen > 2 ? arguments[2] : undefined;\n  var endPos = end === undefined ? length : toAbsoluteIndex(end, length);\n  while (endPos > index) O[index++] = value;\n  return O;\n};\n","'use strict';\nvar $export = require('./_export');\nvar $forEach = require('./_array-methods')(0);\nvar STRICT = require('./_strict-method')([].forEach, true);\n\n$export($export.P + $export.F * !STRICT, 'Array', {\n  // 22.1.3.10 / 15.4.4.18 Array.prototype.forEach(callbackfn [, thisArg])\n  forEach: function forEach(callbackfn /* , thisArg */) {\n    return $forEach(this, callbackfn, arguments[1]);\n  }\n});\n","// most Object methods by ES6 should accept primitives\nvar $export = require('./_export');\nvar core = require('./_core');\nvar fails = require('./_fails');\nmodule.exports = function (KEY, exec) {\n  var fn = (core.Object || {})[KEY] || Object[KEY];\n  var exp = {};\n  exp[KEY] = exec(fn);\n  $export($export.S + $export.F * fails(function () { fn(1); }), 'Object', exp);\n};\n","\"use strict\";\n//# sourceMappingURL=misc.js.map","\"use strict\";\n//# sourceMappingURL=operations.js.map","\"use strict\";\n//# sourceMappingURL=validator.js.map","\"use strict\";\n//# sourceMappingURL=api.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _constants = require(\"./constants\");\n\nObject.keys(_constants).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _constants[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _constants[key];\n    }\n  });\n});\n\nvar _preset = require(\"./preset\");\n\nObject.keys(_preset).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _preset[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _preset[key];\n    }\n  });\n});\n\nvar _activePreset = require(\"./activePreset\");\n\nObject.keys(_activePreset).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _activePreset[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _activePreset[key];\n    }\n  });\n});\n\nvar _forkName = require(\"./forkName\");\n\nObject.keys(_forkName).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _forkName[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _forkName[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _presetName = require(\"./presetName\");\n\nObject.keys(_presetName).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _presetName[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _presetName[key];\n    }\n  });\n});\n\nvar _interface = require(\"./interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _interface[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _interface[key];\n    }\n  });\n});\n\nvar _ssz = require(\"./ssz\");\n\nObject.keys(_ssz).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ssz[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _ssz[key];\n    }\n  });\n});\n\nvar _phase = require(\"./phase0\");\n\nObject.keys(_phase).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _phase[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _phase[key];\n    }\n  });\n});\n\nvar _altair = require(\"./altair\");\n\nObject.keys(_altair).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _altair[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _altair[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _basic = require(\"./basic\");\n\nObject.keys(_basic).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _basic[key];\n    }\n  });\n});\n\nvar _composite = require(\"./composite\");\n\nObject.keys(_composite).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _composite[key];\n    }\n  });\n});\n\nvar _type = require(\"./type\");\n\nObject.keys(_type).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _type[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBooleanType = isBooleanType;\nexports.BooleanType = exports.BOOLEAN_TYPE = void 0;\n\nvar _type = require(\"../type\");\n\nvar _abstract = require(\"./abstract\");\n\n/* eslint-disable @typescript-eslint/camelcase */\nconst BOOLEAN_TYPE = Symbol.for(\"ssz/BooleanType\");\nexports.BOOLEAN_TYPE = BOOLEAN_TYPE;\n\nfunction isBooleanType(type) {\n  return (0, _type.isTypeOf)(type, BOOLEAN_TYPE);\n}\n\nclass BooleanType extends _abstract.BasicType {\n  constructor() {\n    super();\n\n    this._typeSymbols.add(BOOLEAN_TYPE);\n  }\n\n  struct_getSerializedLength() {\n    return 1;\n  }\n\n  struct_assertValidValue(value) {\n    if (value !== true && value !== false) {\n      throw new Error(\"Boolean value must be true or false\");\n    }\n  }\n\n  struct_defaultValue() {\n    return false;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    output[offset] = value ? 1 : 0;\n    return offset + 1;\n  }\n\n  struct_deserializeFromBytes(data, offset) {\n    this.bytes_validate(data, offset);\n\n    if (data[offset] === 1) {\n      return true;\n    } else if (data[offset] === 0) {\n      return false;\n    } else {\n      throw new Error(\"Invalid boolean value\");\n    }\n  }\n\n  struct_convertFromJson(data) {\n    this.struct_assertValidValue(data);\n    return data;\n  }\n\n  struct_convertToJson(value) {\n    return value;\n  }\n\n}\n\nexports.BooleanType = BooleanType;\n//# sourceMappingURL=boolean.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isUintType = isUintType;\nexports.isNumberUintType = isNumberUintType;\nexports.isBigIntUintType = isBigIntUintType;\nexports.BigIntUintType = exports.BIGINT_UINT_TYPE = exports.NumberUintType = exports.NUMBER_UINT_TYPE = exports.UintType = exports.UINT_TYPE = void 0;\n\nvar _type = require(\"../type\");\n\nvar _abstract = require(\"./abstract\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst UINT_TYPE = Symbol.for(\"ssz/UintType\");\nexports.UINT_TYPE = UINT_TYPE;\n\nfunction isUintType(type) {\n  return (0, _type.isTypeOf)(type, UINT_TYPE);\n} // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\n\nclass UintType extends _abstract.BasicType {\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"byteLength\", void 0);\n\n    this.byteLength = options.byteLength;\n\n    this._typeSymbols.add(UINT_TYPE);\n  }\n\n  struct_getSerializedLength() {\n    return this.byteLength;\n  }\n\n}\n\nexports.UintType = UintType;\nconst NUMBER_UINT_TYPE = Symbol.for(\"ssz/NumberUintType\");\nexports.NUMBER_UINT_TYPE = NUMBER_UINT_TYPE;\nconst BIGINT_4_BYTES = BigInt(32);\n\nfunction isNumberUintType(type) {\n  return (0, _type.isTypeOf)(type, NUMBER_UINT_TYPE);\n}\n\nclass NumberUintType extends UintType {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"_maxBigInt\", void 0);\n\n    this._typeSymbols.add(NUMBER_UINT_TYPE);\n  }\n\n  struct_assertValidValue(value) {\n    if (value !== Infinity && (!Number.isSafeInteger(value) || value > BigInt(2) ** (BigInt(8) * BigInt(this.byteLength)))) {\n      throw new Error(\"Uint value is not a number\");\n    }\n\n    if (value < 0) {\n      throw new Error(\"Uint value must be gte 0\");\n    }\n  }\n\n  struct_defaultValue() {\n    return 0;\n  }\n\n  struct_getMaxBigInt() {\n    if (this._maxBigInt === undefined) {\n      this._maxBigInt = BigInt(2) ** BigInt(this.byteLength * 8) - BigInt(1);\n    }\n\n    return this._maxBigInt;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    if (this.byteLength > 6 && value === Infinity) {\n      for (let i = offset; i < offset + this.byteLength; i++) {\n        output[i] = 0xff;\n      }\n    } else {\n      let v = value;\n      const MAX_BYTE = 0xff;\n\n      for (let i = 0; i < this.byteLength; i++) {\n        output[offset + i] = v & MAX_BYTE;\n        v = Math.floor(v / 256);\n      }\n    }\n\n    return offset + this.byteLength;\n  }\n\n  struct_deserializeFromBytes(data, offset) {\n    this.bytes_validate(data, offset);\n    let isInfinity = true;\n    let output = 0;\n\n    for (let i = 0; i < this.byteLength; i++) {\n      output += data[offset + i] * 2 ** (8 * i);\n\n      if (data[offset + i] !== 0xff) {\n        isInfinity = false;\n      }\n    }\n\n    if (this.byteLength > 6 && isInfinity) {\n      return Infinity;\n    }\n\n    return Number(output);\n  }\n\n  struct_convertFromJson(data) {\n    let n;\n    const bigN = BigInt(data);\n\n    if (bigN === this.struct_getMaxBigInt()) {\n      n = Infinity;\n    } else if (bigN < Number.MAX_SAFE_INTEGER) {\n      n = Number(bigN);\n    } else {\n      throw new Error(\"Uint value unsafe\");\n    }\n\n    this.assertValidValue(n);\n    return n;\n  }\n\n  struct_convertToJson(value) {\n    if (this.byteLength > 4) {\n      if (value === Infinity) {\n        return this.struct_getMaxBigInt().toString();\n      }\n\n      return String(value);\n    }\n\n    return value;\n  }\n\n}\n\nexports.NumberUintType = NumberUintType;\nconst BIGINT_UINT_TYPE = Symbol.for(\"ssz/BigIntUintType\");\nexports.BIGINT_UINT_TYPE = BIGINT_UINT_TYPE;\n\nfunction isBigIntUintType(type) {\n  return (0, _type.isTypeOf)(type, BIGINT_UINT_TYPE);\n}\n\nclass BigIntUintType extends UintType {\n  constructor(options) {\n    super(options);\n\n    this._typeSymbols.add(BIGINT_UINT_TYPE);\n  }\n\n  struct_assertValidValue(value) {\n    if (typeof value !== \"bigint\") {\n      throw new Error(\"Uint value is not a bigint\");\n    }\n\n    if (value < 0) {\n      throw new Error(\"Uint value must be gte 0\");\n    }\n  }\n\n  struct_defaultValue() {\n    return BigInt(0);\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    // Motivation\n    // BigInt bit shifting and BigInt allocation is slower compared to number\n    // For every 4 bytes, we extract value to groupedBytes\n    // and do bit shifting on the number\n    let v = value;\n    let groupedBytes = Number(BigInt.asUintN(32, v));\n\n    for (let i = 0; i < this.byteLength; i++) {\n      output[offset + i] = Number(groupedBytes & 0xff);\n\n      if ((i + 1) % 4 !== 0) {\n        groupedBytes >>= 8;\n      } else {\n        v >>= BIGINT_4_BYTES;\n        groupedBytes = Number(BigInt.asUintN(32, v));\n      }\n    }\n\n    return offset + this.byteLength;\n  }\n\n  struct_deserializeFromBytes(data, offset) {\n    this.bytes_validate(data, offset); // Motivation:\n    //   Creating BigInts and bitshifting is more expensive than\n    // number bitshifting.\n    // Implementation:\n    //   Iterate throuth the bytearray, bitshifting the data into a 'groupOutput' number, byte by byte\n    // After each 4 bytes, bitshift the groupOutput into the bigint output and clear the groupOutput out\n    // After iterating through the bytearray,\n    // There may be additional data in the groupOutput if the bytearray if the bytearray isn't divisible by 4\n\n    let output = BigInt(0);\n    let groupIndex = 0,\n        groupOutput = 0;\n\n    for (let i = 0; i < this.byteLength; i++) {\n      groupOutput += data[offset + i] << 8 * (i % 4);\n\n      if ((i + 1) % 4 === 0) {\n        // Left shift returns a signed integer and the output may have become negative\n        // In that case, the output needs to be converted to unsigned integer\n        if (groupOutput < 0) {\n          groupOutput >>>= 0;\n        } // Optimization to set the output the first time, forgoing BigInt addition\n\n\n        if (groupIndex === 0) {\n          output = BigInt(groupOutput);\n        } else {\n          output += BigInt(groupOutput) << BigInt(32 * groupIndex);\n        }\n\n        groupIndex++;\n        groupOutput = 0;\n      }\n    } // if this.byteLength isn't a multiple of 4, there will be additional data\n\n\n    if (groupOutput) {\n      output += BigInt(groupOutput >>> 0) << BigInt(32 * groupIndex);\n    }\n\n    return output;\n  }\n\n  struct_convertFromJson(data) {\n    const value = BigInt(data);\n    this.assertValidValue(value);\n    return value;\n  }\n\n  struct_convertToJson(value) {\n    if (this.byteLength > 4) {\n      return value.toString();\n    } else {\n      return Number(value);\n    }\n  }\n\n}\n\nexports.BigIntUintType = BigIntUintType;\n//# sourceMappingURL=uint.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isTree = isTree;\n\nfunction isTree(value) {\n  return Boolean(value.rootNode && value.rootNode.isLeaf);\n}\n//# sourceMappingURL=tree.js.map","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.hash = void 0;\nconst as_sha256_1 = require(\"@chainsafe/as-sha256\");\nconst input = new Uint8Array(64);\n/**\n * Hash two 32 byte arrays\n */\nfunction hash(a, b) {\n    input.set(a, 0);\n    input.set(b, 32);\n    return as_sha256_1.default.digest64(input);\n}\nexports.hash = hash;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.default = void 0;\n\nvar _wasm = require(\"./wasm\");\n\nclass SHA256 {\n  constructor() {\n    this.ctx = (0, _wasm.newInstance)();\n  }\n\n  init() {\n    this.ctx.init();\n    return this;\n  }\n\n  update(data) {\n    const INPUT_LENGTH = this.ctx.INPUT_LENGTH;\n    const input = new Uint8Array(this.ctx.memory.buffer, this.ctx.input.value, INPUT_LENGTH);\n\n    if (data.length > INPUT_LENGTH) {\n      for (let i = 0; i < data.length; i += INPUT_LENGTH) {\n        const sliced = data.slice(i, i + INPUT_LENGTH);\n        input.set(sliced);\n        this.ctx.update(this.ctx.input.value, sliced.length);\n      }\n    } else {\n      input.set(data);\n      this.ctx.update(this.ctx.input.value, data.length);\n    }\n\n    return this;\n  }\n\n  final() {\n    this.ctx.final(this.ctx.output.value);\n    const output = new Uint8Array(32);\n    output.set(new Uint8Array(this.ctx.memory.buffer, this.ctx.output.value, 32));\n    return output;\n  }\n\n  static digest(data) {\n    if (data.length <= staticInstance.ctx.INPUT_LENGTH) {\n      const input = new Uint8Array(staticInstance.ctx.memory.buffer, staticInstance.ctx.input.value, staticInstance.ctx.INPUT_LENGTH);\n      input.set(data);\n      staticInstance.ctx.digest(data.length);\n      const output = new Uint8Array(32);\n      output.set(new Uint8Array(staticInstance.ctx.memory.buffer, staticInstance.ctx.output.value, 32));\n      return output;\n    }\n\n    return staticInstance.init().update(data).final();\n  }\n\n  static digest64(data) {\n    if (data.length == 64) {\n      const input = new Uint8Array(staticInstance.ctx.memory.buffer, staticInstance.ctx.input.value, staticInstance.ctx.INPUT_LENGTH);\n      input.set(data);\n      staticInstance.ctx.digest64(staticInstance.ctx.input.value, staticInstance.ctx.output.value);\n      const output = new Uint8Array(32);\n      output.set(new Uint8Array(staticInstance.ctx.memory.buffer, staticInstance.ctx.output.value, 32));\n      return output;\n    }\n\n    throw new Error(\"InvalidLengthForDigest64\");\n  }\n\n}\n\nexports.default = SHA256;\nconst staticInstance = new SHA256();","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeProof = exports.serializeProof = exports.createNodeFromProof = exports.createProof = exports.ProofTypeSerialized = exports.ProofType = void 0;\nconst single_1 = require(\"./single\");\nconst treeOffset_1 = require(\"./treeOffset\");\nvar ProofType;\n(function (ProofType) {\n    ProofType[\"single\"] = \"single\";\n    ProofType[\"treeOffset\"] = \"treeOffset\";\n})(ProofType = exports.ProofType || (exports.ProofType = {}));\n/**\n * Serialized proofs are prepended with a single byte, denoting their type\n */\nexports.ProofTypeSerialized = [\n    ProofType.single,\n    ProofType.treeOffset, // 1\n];\nfunction createProof(rootNode, input) {\n    switch (input.type) {\n        case ProofType.single: {\n            const [leaf, witnesses] = single_1.createSingleProof(rootNode, input.gindex);\n            return {\n                type: ProofType.single,\n                gindex: input.gindex,\n                leaf,\n                witnesses,\n            };\n        }\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.createTreeOffsetProof(rootNode, input.gindices);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createProof = createProof;\nfunction createNodeFromProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n            return single_1.createNodeFromSingleProof(proof.gindex, proof.leaf, proof.witnesses);\n        case ProofType.treeOffset:\n            return treeOffset_1.createNodeFromTreeOffsetProof(proof.offsets, proof.leaves);\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.createNodeFromProof = createNodeFromProof;\nfunction serializeProof(proof) {\n    switch (proof.type) {\n        case ProofType.single:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const output = new Uint8Array(1 + treeOffset_1.computeTreeOffsetProofSerializedLength(proof.offsets, proof.leaves));\n            output[0] = exports.ProofTypeSerialized.indexOf(ProofType.treeOffset);\n            treeOffset_1.serializeTreeOffsetProof(output, 1, proof.offsets, proof.leaves);\n            return output;\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.serializeProof = serializeProof;\nfunction deserializeProof(data) {\n    const proofType = exports.ProofTypeSerialized[data[0]];\n    if (!proofType) {\n        throw new Error(\"Invalid proof type\");\n    }\n    switch (proofType) {\n        case ProofType.single:\n            throw new Error(\"Not implemented\");\n        case ProofType.treeOffset: {\n            const [offsets, leaves] = treeOffset_1.deserializeTreeOffsetProof(data, 1);\n            return {\n                type: ProofType.treeOffset,\n                offsets,\n                leaves,\n            };\n        }\n        default:\n            throw new Error(\"Invalid proof type\");\n    }\n}\nexports.deserializeProof = deserializeProof;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.createNodeFromSingleProof = exports.createSingleProof = exports.ERR_INVALID_NAV = void 0;\nconst node_1 = require(\"../node\");\nconst gindex_1 = require(\"../gindex\");\nexports.ERR_INVALID_NAV = \"Invalid tree navigation\";\nfunction createSingleProof(rootNode, index) {\n    const witnesses = [];\n    let node = rootNode;\n    for (const i of gindex_1.gindexIterator(index)) {\n        if (i) {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.left.root);\n            node = node.right;\n        }\n        else {\n            if (node.isLeaf())\n                throw new Error(exports.ERR_INVALID_NAV);\n            witnesses.push(node.right.root);\n            node = node.left;\n        }\n    }\n    return [node.root, witnesses.reverse()];\n}\nexports.createSingleProof = createSingleProof;\nfunction createNodeFromSingleProof(gindex, leaf, witnesses) {\n    let node = new node_1.LeafNode(leaf);\n    const w = witnesses.reverse();\n    while (gindex > 1) {\n        const sibling = new node_1.LeafNode(w.pop());\n        if (gindex % BigInt(2) === BigInt(0)) {\n            node = new node_1.BranchNode(node, sibling);\n        }\n        else {\n            node = new node_1.BranchNode(sibling, node);\n        }\n        gindex = gindex / BigInt(2);\n    }\n    return node;\n}\nexports.createNodeFromSingleProof = createNodeFromSingleProof;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.renderJsonPath = renderJsonPath;\nexports.SszErrorPath = void 0;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * Tracks the JSON path location of nested errors\n */\nclass SszErrorPath extends Error {\n  constructor(e, keyOrIndex) {\n    const prevJsonPath = e instanceof SszErrorPath ? e.jsonPath : [];\n    const jsonPath = [keyOrIndex, ...prevJsonPath];\n    const rawMessage = e instanceof SszErrorPath ? e.rawMessage : e.message;\n    super(\"\".concat(renderJsonPath(jsonPath), \": \").concat(rawMessage));\n\n    _defineProperty(this, \"jsonPath\", void 0);\n\n    _defineProperty(this, \"rawMessage\", void 0);\n\n    this.jsonPath = jsonPath;\n    this.rawMessage = rawMessage;\n  }\n\n}\n/**\n * Render an array of JSON path items\n * @param jsonPath [\"a\", 2, \"n\", \"m\"]\n * @returns \"a[2].n.m\"\n */\n\n\nexports.SszErrorPath = SszErrorPath;\n\nfunction renderJsonPath(jsonPath) {\n  let path = \"\";\n\n  for (const item of jsonPath) {\n    switch (typeof item) {\n      case \"number\":\n        path += \"[\".concat(item, \"]\");\n        break;\n\n      case \"string\":\n      default:\n        path += path.length > 0 ? \".\".concat(item) : item;\n        break;\n    }\n  }\n\n  return path;\n}\n//# sourceMappingURL=errorPath.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isListType = isListType;\nexports.CompositeListType = exports.BasicListType = exports.ListType = exports.LIST_TYPE = exports.LENGTH_GINDEX = void 0;\n\nvar _array = require(\"./array\");\n\nvar _basic = require(\"../basic\");\n\nvar _type = require(\"../type\");\n\nvar _compat = require(\"../../util/compat\");\n\nvar _persistentMerkleTree = require(\"@chainsafe/persistent-merkle-tree\");\n\nvar _treeValue = require(\"../../backings/tree/treeValue\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\n/**\n * SSZ Lists (variable-length arrays) include the length of the list in the tree\n * This length is always in the same index in the tree\n * ```\n *   1\n *  / \\\n * 2   3 // <-here\n * ```\n */\nconst LENGTH_GINDEX = BigInt(3);\nexports.LENGTH_GINDEX = LENGTH_GINDEX;\nconst LIST_TYPE = Symbol.for(\"ssz/ListType\"); // eslint-disable-next-line @typescript-eslint/no-explicit-any\n\nexports.LIST_TYPE = LIST_TYPE;\n\nfunction isListType(type) {\n  return (0, _type.isTypeOf)(type, LIST_TYPE);\n} // Trick typescript into treating ListType as a constructor\n\n\nconst ListType = // eslint-disable-next-line @typescript-eslint/no-explicit-any\nfunction ListType(options) {\n  if ((0, _basic.isBasicType)(options.elementType)) {\n    return new BasicListType(options);\n  } else {\n    return new CompositeListType(options);\n  }\n};\n\nexports.ListType = ListType;\n\nclass BasicListType extends _array.BasicArrayType {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"limit\", void 0);\n\n    this.limit = options.limit;\n\n    this._typeSymbols.add(LIST_TYPE);\n  }\n\n  struct_defaultValue() {\n    return [];\n  }\n\n  struct_getLength(value) {\n    return value.length;\n  }\n\n  getMaxLength() {\n    return this.limit;\n  }\n\n  getMinLength() {\n    return 0;\n  }\n\n  bytes_validate(data, start, end) {\n    super.bytes_validate(data, start, end);\n\n    if (end - start > this.getMaxSerializedLength()) {\n      throw new Error(\"Deserialized list length greater than limit\");\n    }\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    return super.struct_deserializeFromBytes(data, start, end);\n  }\n\n  struct_getChunkCount(value) {\n    return Math.ceil(value.length * this.elementType.struct_getSerializedLength() / 32);\n  }\n\n  struct_hashTreeRoot(value) {\n    return (0, _compat.mixInLength)(super.struct_hashTreeRoot(value), value.length);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_convertFromJson(data, options) {\n    if (!Array.isArray(data)) {\n      throw new Error(\"Invalid JSON list: expected an Array\");\n    }\n\n    const maxLength = this.limit;\n\n    if (data.length > maxLength) {\n      throw new Error(\"Invalid JSON list: length \".concat(data.length, \" greater than limit \").concat(maxLength));\n    }\n\n    return super.struct_convertFromJson(data);\n  }\n\n  struct_convertToTree(value) {\n    if ((0, _treeValue.isTreeBacked)(value)) return value.tree.clone();\n    const tree = super.struct_convertToTree(value);\n    this.tree_setLength(tree, value.length);\n    return tree;\n  }\n\n  tree_defaultNode() {\n    if (!this._defaultNode) {\n      this._defaultNode = new _persistentMerkleTree.BranchNode((0, _persistentMerkleTree.zeroNode)(super.getChunkDepth()), (0, _persistentMerkleTree.zeroNode)(0));\n    }\n\n    return this._defaultNode;\n  }\n\n  tree_defaultValue() {\n    return new _persistentMerkleTree.Tree(this.tree_defaultNode());\n  }\n\n  tree_getLength(target) {\n    return _basic.number32Type.struct_deserializeFromBytes(target.getRoot(LENGTH_GINDEX), 0);\n  }\n\n  tree_setLength(target, length) {\n    const chunk = new Uint8Array(32);\n\n    _basic.number32Type.toBytes(length, chunk, 0);\n\n    target.setRoot(LENGTH_GINDEX, chunk);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const length = (end - start) / this.elementType.struct_getSerializedLength();\n\n    if (!Number.isSafeInteger(length)) {\n      throw new Error(\"Deserialized list byte length must be divisible by element size\");\n    }\n\n    if (length > this.limit) {\n      throw new Error(\"Deserialized list length greater than limit\");\n    }\n\n    const value = super.tree_deserializeFromBytes(data, start, end);\n    this.tree_setLength(value, length);\n    return value;\n  }\n\n  tree_getChunkCount(target) {\n    return Math.ceil(this.tree_getLength(target) * this.elementType.struct_getSerializedLength() / 32);\n  }\n\n  getChunkDepth() {\n    return super.getChunkDepth() + 1;\n  }\n\n  tree_setProperty(target, property, value) {\n    const length = this.tree_getLength(target);\n\n    if (property > length) {\n      throw new Error(\"Invalid length index\");\n    } else if (property == length) {\n      this.tree_pushSingle(target, value);\n      return true;\n    } else {\n      return this.tree_setValueAtIndex(target, property, value);\n    }\n  }\n\n  tree_deleteProperty(target, property) {\n    const length = this.tree_getLength(target);\n\n    if (property > length) {\n      throw new Error(\"Invalid length index\");\n    } else if (property == length) {\n      this.tree_pop(target);\n      return true;\n    } else {\n      return super.tree_deleteProperty(target, property);\n    }\n  }\n\n  tree_pushSingle(target, value) {\n    const length = this.tree_getLength(target);\n    const expand = this.getChunkIndex(length) != this.getChunkIndex(length + 1);\n    this.tree_setValueAtIndex(target, length, value, expand);\n    this.tree_setLength(target, length + 1);\n    return length + 1;\n  }\n\n  tree_push(target, ...values) {\n    let newLength;\n\n    for (const value of values) newLength = this.tree_pushSingle(target, value);\n\n    return newLength;\n  }\n\n  tree_pop(target) {\n    const length = this.tree_getLength(target);\n    const value = this.tree_getProperty(target, length - 1);\n    super.tree_deleteProperty(target, length - 1);\n    this.tree_setLength(target, length - 1);\n    return value;\n  }\n\n  hasVariableSerializedLength() {\n    return true;\n  }\n\n  getMaxChunkCount() {\n    return Math.ceil(this.limit * this.elementType.size() / 32);\n  }\n\n  tree_getLeafGindices(target, root = BigInt(1)) {\n    if (!target) {\n      throw new Error(\"variable type requires tree argument to get leaves\");\n    }\n\n    const gindices = super.tree_getLeafGindices(target, root); // include the length chunk\n\n    gindices.push((0, _persistentMerkleTree.concatGindices)([root, LENGTH_GINDEX]));\n    return gindices;\n  }\n\n}\n\nexports.BasicListType = BasicListType;\n\nclass CompositeListType extends _array.CompositeArrayType {\n  constructor(options) {\n    super(options);\n\n    _defineProperty(this, \"limit\", void 0);\n\n    this.limit = options.limit;\n\n    this._typeSymbols.add(LIST_TYPE);\n  }\n\n  hasVariableSerializedLength() {\n    return true;\n  }\n\n  getMaxChunkCount() {\n    return this.limit;\n  }\n\n  struct_defaultValue() {\n    return [];\n  }\n\n  struct_getLength(value) {\n    return value.length;\n  }\n\n  getMaxLength() {\n    return this.limit;\n  }\n\n  getMinLength() {\n    return 0;\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    const value = super.struct_deserializeFromBytes(data, start, end);\n\n    if (value.length > this.limit) {\n      throw new Error(\"Deserialized list length greater than limit: \".concat(value.length, \" \").concat(this.limit));\n    }\n\n    return value;\n  }\n\n  struct_getChunkCount(value) {\n    return value.length;\n  }\n\n  struct_hashTreeRoot(value) {\n    return (0, _compat.mixInLength)(super.struct_hashTreeRoot(value), value.length);\n  }\n\n  struct_convertFromJson(data, options) {\n    if (!Array.isArray(data)) {\n      throw new Error(\"Invalid JSON list: expected an Array\");\n    }\n\n    const maxLength = this.limit;\n\n    if (data.length > maxLength) {\n      throw new Error(\"Invalid JSON list: length \".concat(data.length, \" greater than limit \").concat(maxLength));\n    }\n\n    return super.struct_convertFromJson(data, options);\n  }\n\n  tree_defaultNode() {\n    if (!this._defaultNode) {\n      this._defaultNode = new _persistentMerkleTree.BranchNode((0, _persistentMerkleTree.zeroNode)(super.getChunkDepth()), (0, _persistentMerkleTree.zeroNode)(0));\n    }\n\n    return this._defaultNode;\n  }\n\n  tree_defaultValue() {\n    return new _persistentMerkleTree.Tree(this.tree_defaultNode());\n  }\n\n  struct_convertToTree(value) {\n    if ((0, _treeValue.isTreeBacked)(value)) return value.tree.clone();\n    const tree = super.struct_convertToTree(value);\n    this.tree_setLength(tree, value.length);\n    return tree;\n  }\n\n  tree_getLength(target) {\n    return _basic.number32Type.struct_deserializeFromBytes(target.getRoot(LENGTH_GINDEX), 0);\n  }\n\n  tree_setLength(target, length) {\n    const chunk = new Uint8Array(32);\n\n    _basic.number32Type.struct_serializeToBytes(length, chunk, 0);\n\n    target.setRoot(LENGTH_GINDEX, chunk);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const target = this.tree_defaultValue();\n\n    if (this.elementType.hasVariableSerializedLength()) {\n      const offsets = this.bytes_getVariableOffsets(new Uint8Array(data.buffer, data.byteOffset + start, end - start));\n\n      if (offsets.length > this.limit) {\n        throw new Error(\"Deserialized list length greater than limit\");\n      }\n\n      for (let i = 0; i < offsets.length; i++) {\n        const [currentOffset, nextOffset] = offsets[i];\n        this.tree_setSubtreeAtChunkIndex(target, i, this.elementType.tree_deserializeFromBytes(data, start + currentOffset, start + nextOffset));\n      }\n\n      this.tree_setLength(target, offsets.length);\n    } else {\n      const elementSize = this.elementType.struct_getSerializedLength(null);\n      const length = (end - start) / elementSize;\n\n      if (!Number.isSafeInteger(length)) {\n        throw new Error(\"Deserialized list byte length must be divisible by element size\");\n      }\n\n      if (length > this.limit) {\n        throw new Error(\"Deserialized list length greater than limit\");\n      }\n\n      for (let i = 0; i < length; i++) {\n        this.tree_setSubtreeAtChunkIndex(target, i, this.elementType.tree_deserializeFromBytes(data, start + i * elementSize, start + (i + 1) * elementSize), true // expand tree as needed\n        );\n      }\n\n      this.tree_setLength(target, length);\n    }\n\n    return target;\n  }\n\n  tree_getChunkCount(target) {\n    return this.tree_getLength(target);\n  }\n\n  getChunkDepth() {\n    return super.getChunkDepth() + 1;\n  }\n\n  tree_setProperty(target, property, value) {\n    const length = this.tree_getLength(target);\n\n    if (property > length) {\n      throw new Error(\"Invalid length index\");\n    } else if (property == length) {\n      this.tree_pushSingle(target, value);\n    } else {\n      this.tree_setSubtreeAtChunkIndex(target, property, value);\n    }\n\n    return true;\n  }\n\n  tree_deleteProperty(target, property) {\n    const length = this.tree_getLength(target);\n\n    if (property > length) {\n      throw new Error(\"Invalid length index\");\n    } else if (property == length) {\n      this.tree_pop(target);\n      return true;\n    } else {\n      return super.tree_deleteProperty(target, property);\n    }\n  }\n\n  tree_pushSingle(target, value) {\n    const length = this.tree_getLength(target);\n    this.tree_setSubtreeAtChunkIndex(target, length, value, true);\n    this.tree_setLength(target, length + 1);\n    return length + 1;\n  }\n\n  tree_push(target, ...values) {\n    let newLength;\n\n    for (const value of values) newLength = this.tree_pushSingle(target, value);\n\n    return newLength;\n  }\n\n  tree_pop(target) {\n    const length = this.tree_getLength(target);\n    const value = this.tree_getProperty(target, length - 1);\n    this.tree_setSubtreeAtChunkIndex(target, length - 1, new _persistentMerkleTree.Tree((0, _persistentMerkleTree.zeroNode)(0)));\n    this.tree_setLength(target, length - 1);\n    return value;\n  }\n\n  tree_getLeafGindices(target, root = BigInt(1)) {\n    if (!target) {\n      throw new Error(\"variable type requires tree argument to get leaves\");\n    }\n\n    const gindices = super.tree_getLeafGindices(target, root); // include the length chunk\n\n    gindices.push((0, _persistentMerkleTree.concatGindices)([root, LENGTH_GINDEX]));\n    return gindices;\n  }\n\n}\n\nexports.CompositeListType = CompositeListType;\n//# sourceMappingURL=list.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isByteVectorType = isByteVectorType;\nexports.ByteVectorType = exports.BYTEVECTOR_TYPE = void 0;\n\nvar _vector = require(\"./vector\");\n\nvar _basic = require(\"../basic\");\n\nvar _type = require(\"../type\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst BYTEVECTOR_TYPE = Symbol.for(\"ssz/ByteVectorType\");\nexports.BYTEVECTOR_TYPE = BYTEVECTOR_TYPE;\n\nfunction isByteVectorType(type) {\n  return (0, _type.isTypeOf)(type, BYTEVECTOR_TYPE);\n}\n\nclass ByteVectorType extends _vector.BasicVectorType {\n  constructor(options) {\n    super(_objectSpread({\n      elementType: _basic.byteType\n    }, options));\n\n    this._typeSymbols.add(BYTEVECTOR_TYPE);\n  }\n\n  struct_defaultValue() {\n    return new Uint8Array(this.length);\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    const length = end - start;\n\n    if (length !== this.length) {\n      throw new Error(\"Invalid deserialized vector length: expected \".concat(this.length, \", actual: \").concat(length));\n    }\n\n    const value = new Uint8Array(length);\n    value.set(data.slice(start, end));\n    return value;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    output.set(value, offset);\n    return offset + this.length;\n  }\n\n  struct_convertFromJson(data) {\n    const value = (0, _byteArray.fromHexString)(data);\n\n    if (value.length !== this.length) {\n      throw new Error(\"Invalid JSON vector length: expected \".concat(this.length, \", actual: \").concat(value.length));\n    }\n\n    return value;\n  }\n\n  struct_convertToJson(value) {\n    return (0, _byteArray.toHexString)(value);\n  }\n\n  tree_convertToStruct(target) {\n    const value = new Uint8Array(this.length);\n    const chunkIterator = target.iterateNodesAtDepth(this.getChunkDepth(), 0, this.getMaxChunkCount());\n\n    if (this.length % 32 === 0) {\n      for (let i = 0; i < this.length; i += 32) {\n        value.set(chunkIterator.next().value.root, i);\n      }\n    } else {\n      let i;\n\n      for (i = 0; i < this.length - 32; i += 32) {\n        value.set(chunkIterator.next().value.root, i);\n      }\n\n      value.set(chunkIterator.next().value.root.subarray(0, this.length - i), i);\n    }\n\n    return value;\n  }\n\n}\n\nexports.ByteVectorType = ByteVectorType;\n//# sourceMappingURL=byteVector.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _interface = require(\"./interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _interface[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _interface[key];\n    }\n  });\n});\n\nvar _ssz = require(\"./ssz\");\n\nObject.keys(_ssz).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ssz[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _ssz[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _interface = require(\"./interface\");\n\nObject.keys(_interface).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _interface[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _interface[key];\n    }\n  });\n});\n\nvar _ssz = require(\"./ssz\");\n\nObject.keys(_ssz).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _ssz[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _ssz[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ssz = exports.ts = void 0;\n\nvar _ts = _interopRequireWildcard(require(\"./types\"));\n\nexports.ts = _ts;\n\nvar _ssz = _interopRequireWildcard(require(\"./sszTypes\"));\n\nexports.ssz = _ssz;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ParticipationFlags = exports.Domain = exports.BLSSignature = exports.BLSPubkey = exports.ForkDigest = exports.DomainType = exports.Version = exports.Root = exports.Gwei = exports.ValidatorIndex = exports.SubCommitteeIndex = exports.CommitteeIndex = exports.Epoch = exports.Slot = exports.Uint256 = exports.Uint128 = exports.Uint64 = exports.Number64 = exports.Uint32 = exports.Uint16 = exports.Uint8 = exports.Bytes96 = exports.Bytes48 = exports.Bytes32 = exports.Bytes8 = exports.Bytes4 = exports.Boolean = void 0;\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\nconst Boolean = _ssz.booleanType;\nexports.Boolean = Boolean;\nconst Bytes4 = new _ssz.ByteVectorType({\n  length: 4\n});\nexports.Bytes4 = Bytes4;\nconst Bytes8 = new _ssz.ByteVectorType({\n  length: 8\n});\nexports.Bytes8 = Bytes8;\nconst Bytes32 = new _ssz.ByteVectorType({\n  length: 32\n});\nexports.Bytes32 = Bytes32;\nconst Bytes48 = new _ssz.ByteVectorType({\n  length: 48\n});\nexports.Bytes48 = Bytes48;\nconst Bytes96 = new _ssz.ByteVectorType({\n  length: 96\n});\nexports.Bytes96 = Bytes96;\nconst Uint8 = _ssz.byteType;\nexports.Uint8 = Uint8;\nconst Uint16 = new _ssz.NumberUintType({\n  byteLength: 2\n});\nexports.Uint16 = Uint16;\nconst Uint32 = _ssz.number32Type;\nexports.Uint32 = Uint32;\nconst Number64 = new _ssz.NumberUintType({\n  byteLength: 8\n});\nexports.Number64 = Number64;\nconst Uint64 = new _ssz.BigIntUintType({\n  byteLength: 8\n});\nexports.Uint64 = Uint64;\nconst Uint128 = new _ssz.BigIntUintType({\n  byteLength: 16\n});\nexports.Uint128 = Uint128;\nconst Uint256 = new _ssz.BigIntUintType({\n  byteLength: 32\n}); // Custom types, defined for type hinting and readability\n\nexports.Uint256 = Uint256;\nconst Slot = Number64;\nexports.Slot = Slot;\nconst Epoch = Number64;\nexports.Epoch = Epoch;\nconst CommitteeIndex = Number64;\nexports.CommitteeIndex = CommitteeIndex;\nconst SubCommitteeIndex = Number64;\nexports.SubCommitteeIndex = SubCommitteeIndex;\nconst ValidatorIndex = Number64;\nexports.ValidatorIndex = ValidatorIndex;\nconst Gwei = Uint64;\nexports.Gwei = Gwei;\nconst Root = new _ssz.RootType({\n  expandedType: () => {\n    throw new Error(\"Generic Root type has no expanded type\");\n  }\n});\nexports.Root = Root;\nconst Version = Bytes4;\nexports.Version = Version;\nconst DomainType = Bytes4;\nexports.DomainType = DomainType;\nconst ForkDigest = Bytes4;\nexports.ForkDigest = ForkDigest;\nconst BLSPubkey = Bytes48;\nexports.BLSPubkey = BLSPubkey;\nconst BLSSignature = Bytes96;\nexports.BLSSignature = BLSSignature;\nconst Domain = Bytes32;\nexports.Domain = Domain;\nconst ParticipationFlags = Uint8;\nexports.ParticipationFlags = ParticipationFlags;\n//# sourceMappingURL=sszTypes.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LazyVariable = void 0;\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nclass LazyVariable {\n  constructor() {\n    _defineProperty(this, \"var\", {\n      set: false\n    });\n  }\n\n  get() {\n    if (!this.var.set) throw Error(\"variable not set\");\n    return this.var.value;\n  }\n\n  set(value) {\n    this.var = {\n      set: true,\n      value\n    };\n  }\n\n}\n\nexports.LazyVariable = LazyVariable;\n//# sourceMappingURL=lazyVar.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ssz = exports.ts = void 0;\n\nvar _ts = _interopRequireWildcard(require(\"./types\"));\n\nexports.ts = _ts;\n\nvar _ssz = _interopRequireWildcard(require(\"./sszTypes\"));\n\nexports.ssz = _ssz;\n\nfunction _getRequireWildcardCache() { if (typeof WeakMap !== \"function\") return null; var cache = new WeakMap(); _getRequireWildcardCache = function () { return cache; }; return cache; }\n\nfunction _interopRequireWildcard(obj) { if (obj && obj.__esModule) { return obj; } if (obj === null || typeof obj !== \"object\" && typeof obj !== \"function\") { return { default: obj }; } var cache = _getRequireWildcardCache(); if (cache && cache.has(obj)) { return cache.get(obj); } var newObj = {}; var hasPropertyDescriptor = Object.defineProperty && Object.getOwnPropertyDescriptor; for (var key in obj) { if (Object.prototype.hasOwnProperty.call(obj, key)) { var desc = hasPropertyDescriptor ? Object.getOwnPropertyDescriptor(obj, key) : null; if (desc && (desc.get || desc.set)) { Object.defineProperty(newObj, key, desc); } else { newObj[key] = obj[key]; } } } newObj.default = obj; if (cache) { cache.set(obj, newObj); } return newObj; }\n//# sourceMappingURL=index.js.map","module.exports = require('./_shared')('native-function-to-string', Function.toString);\n","var META = require('./_uid')('meta');\nvar isObject = require('./_is-object');\nvar has = require('./_has');\nvar setDesc = require('./_object-dp').f;\nvar id = 0;\nvar isExtensible = Object.isExtensible || function () {\n  return true;\n};\nvar FREEZE = !require('./_fails')(function () {\n  return isExtensible(Object.preventExtensions({}));\n});\nvar setMeta = function (it) {\n  setDesc(it, META, { value: {\n    i: 'O' + ++id, // object ID\n    w: {}          // weak collections IDs\n  } });\n};\nvar fastKey = function (it, create) {\n  // return primitive with prefix\n  if (!isObject(it)) return typeof it == 'symbol' ? it : (typeof it == 'string' ? 'S' : 'P') + it;\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return 'F';\n    // not necessary to add metadata\n    if (!create) return 'E';\n    // add missing metadata\n    setMeta(it);\n  // return object ID\n  } return it[META].i;\n};\nvar getWeak = function (it, create) {\n  if (!has(it, META)) {\n    // can't set metadata to uncaught frozen object\n    if (!isExtensible(it)) return true;\n    // not necessary to add metadata\n    if (!create) return false;\n    // add missing metadata\n    setMeta(it);\n  // return hash weak collections IDs\n  } return it[META].w;\n};\n// add metadata on freeze-family methods calling\nvar onFreeze = function (it) {\n  if (FREEZE && meta.NEED && isExtensible(it) && !has(it, META)) setMeta(it);\n  return it;\n};\nvar meta = module.exports = {\n  KEY: META,\n  NEED: false,\n  fastKey: fastKey,\n  getWeak: getWeak,\n  onFreeze: onFreeze\n};\n","var global = require('./_global');\nvar core = require('./_core');\nvar LIBRARY = require('./_library');\nvar wksExt = require('./_wks-ext');\nvar defineProperty = require('./_object-dp').f;\nmodule.exports = function (name) {\n  var $Symbol = core.Symbol || (core.Symbol = LIBRARY ? {} : global.Symbol || {});\n  if (name.charAt(0) != '_' && !(name in $Symbol)) defineProperty($Symbol, name, { value: wksExt.f(name) });\n};\n","// all enumerable object keys, includes symbols\nvar getKeys = require('./_object-keys');\nvar gOPS = require('./_object-gops');\nvar pIE = require('./_object-pie');\nmodule.exports = function (it) {\n  var result = getKeys(it);\n  var getSymbols = gOPS.f;\n  if (getSymbols) {\n    var symbols = getSymbols(it);\n    var isEnum = pIE.f;\n    var i = 0;\n    var key;\n    while (symbols.length > i) if (isEnum.call(it, key = symbols[i++])) result.push(key);\n  } return result;\n};\n","// fallback for IE11 buggy Object.getOwnPropertyNames with iframe and window\nvar toIObject = require('./_to-iobject');\nvar gOPN = require('./_object-gopn').f;\nvar toString = {}.toString;\n\nvar windowNames = typeof window == 'object' && window && Object.getOwnPropertyNames\n  ? Object.getOwnPropertyNames(window) : [];\n\nvar getWindowNames = function (it) {\n  try {\n    return gOPN(it);\n  } catch (e) {\n    return windowNames.slice();\n  }\n};\n\nmodule.exports.f = function getOwnPropertyNames(it) {\n  return windowNames && toString.call(it) == '[object Window]' ? getWindowNames(it) : gOPN(toIObject(it));\n};\n","'use strict';\nvar ctx = require('./_ctx');\nvar $export = require('./_export');\nvar toObject = require('./_to-object');\nvar call = require('./_iter-call');\nvar isArrayIter = require('./_is-array-iter');\nvar toLength = require('./_to-length');\nvar createProperty = require('./_create-property');\nvar getIterFn = require('./core.get-iterator-method');\n\n$export($export.S + $export.F * !require('./_iter-detect')(function (iter) { Array.from(iter); }), 'Array', {\n  // 22.1.2.1 Array.from(arrayLike, mapfn = undefined, thisArg = undefined)\n  from: function from(arrayLike /* , mapfn = undefined, thisArg = undefined */) {\n    var O = toObject(arrayLike);\n    var C = typeof this == 'function' ? this : Array;\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var index = 0;\n    var iterFn = getIterFn(O);\n    var length, result, step, iterator;\n    if (mapping) mapfn = ctx(mapfn, aLen > 2 ? arguments[2] : undefined, 2);\n    // if object isn't iterable or it's array with default iterator - use simple case\n    if (iterFn != undefined && !(C == Array && isArrayIter(iterFn))) {\n      for (iterator = iterFn.call(O), result = new C(); !(step = iterator.next()).done; index++) {\n        createProperty(result, index, mapping ? call(iterator, mapfn, [step.value, index], true) : step.value);\n      }\n    } else {\n      length = toLength(O.length);\n      for (result = new C(length); length > index; index++) {\n        createProperty(result, index, mapping ? mapfn(O[index], index) : O[index]);\n      }\n    }\n    result.length = index;\n    return result;\n  }\n});\n","// call something on iterator step with safe closing on error\nvar anObject = require('./_an-object');\nmodule.exports = function (iterator, fn, value, entries) {\n  try {\n    return entries ? fn(anObject(value)[0], value[1]) : fn(value);\n  // 7.4.6 IteratorClose(iterator, completion)\n  } catch (e) {\n    var ret = iterator['return'];\n    if (ret !== undefined) anObject(ret.call(iterator));\n    throw e;\n  }\n};\n","'use strict';\nvar $at = require('./_string-at')(true);\n\n// 21.1.3.27 String.prototype[@@iterator]()\nrequire('./_iter-define')(String, 'String', function (iterated) {\n  this._t = String(iterated); // target\n  this._i = 0;                // next index\n// 21.1.5.2.1 %StringIteratorPrototype%.next()\n}, function () {\n  var O = this._t;\n  var index = this._i;\n  var point;\n  if (index >= O.length) return { value: undefined, done: true };\n  point = $at(O, index);\n  this._i += point.length;\n  return { value: point, done: false };\n});\n","var toInteger = require('./_to-integer');\nvar defined = require('./_defined');\n// true  -> String#at\n// false -> String#codePointAt\nmodule.exports = function (TO_STRING) {\n  return function (that, pos) {\n    var s = String(defined(that));\n    var i = toInteger(pos);\n    var l = s.length;\n    var a, b;\n    if (i < 0 || i >= l) return TO_STRING ? '' : undefined;\n    a = s.charCodeAt(i);\n    return a < 0xd800 || a > 0xdbff || i + 1 === l || (b = s.charCodeAt(i + 1)) < 0xdc00 || b > 0xdfff\n      ? TO_STRING ? s.charAt(i) : a\n      : TO_STRING ? s.slice(i, i + 2) : (a - 0xd800 << 10) + (b - 0xdc00) + 0x10000;\n  };\n};\n","'use strict';\nvar create = require('./_object-create');\nvar descriptor = require('./_property-desc');\nvar setToStringTag = require('./_set-to-string-tag');\nvar IteratorPrototype = {};\n\n// 25.1.2.1.1 %IteratorPrototype%[@@iterator]()\nrequire('./_hide')(IteratorPrototype, require('./_wks')('iterator'), function () { return this; });\n\nmodule.exports = function (Constructor, NAME, next) {\n  Constructor.prototype = create(IteratorPrototype, { next: descriptor(1, next) });\n  setToStringTag(Constructor, NAME + ' Iterator');\n};\n","'use strict';\n// 19.1.3.6 Object.prototype.toString()\nvar classof = require('./_classof');\nvar test = {};\ntest[require('./_wks')('toStringTag')] = 'z';\nif (test + '' != '[object z]') {\n  require('./_redefine')(Object.prototype, 'toString', function toString() {\n    return '[object ' + classof(this) + ']';\n  }, true);\n}\n","// 22.1.3.31 Array.prototype[@@unscopables]\nvar UNSCOPABLES = require('./_wks')('unscopables');\nvar ArrayProto = Array.prototype;\nif (ArrayProto[UNSCOPABLES] == undefined) require('./_hide')(ArrayProto, UNSCOPABLES, {});\nmodule.exports = function (key) {\n  ArrayProto[UNSCOPABLES][key] = true;\n};\n","module.exports = function (done, value) {\n  return { value: value, done: !!done };\n};\n","var $iterators = require('./es6.array.iterator');\nvar getKeys = require('./_object-keys');\nvar redefine = require('./_redefine');\nvar global = require('./_global');\nvar hide = require('./_hide');\nvar Iterators = require('./_iterators');\nvar wks = require('./_wks');\nvar ITERATOR = wks('iterator');\nvar TO_STRING_TAG = wks('toStringTag');\nvar ArrayValues = Iterators.Array;\n\nvar DOMIterables = {\n  CSSRuleList: true, // TODO: Not spec compliant, should be false.\n  CSSStyleDeclaration: false,\n  CSSValueList: false,\n  ClientRectList: false,\n  DOMRectList: false,\n  DOMStringList: false,\n  DOMTokenList: true,\n  DataTransferItemList: false,\n  FileList: false,\n  HTMLAllCollection: false,\n  HTMLCollection: false,\n  HTMLFormElement: false,\n  HTMLSelectElement: false,\n  MediaList: true, // TODO: Not spec compliant, should be false.\n  MimeTypeArray: false,\n  NamedNodeMap: false,\n  NodeList: true,\n  PaintRequestList: false,\n  Plugin: false,\n  PluginArray: false,\n  SVGLengthList: false,\n  SVGNumberList: false,\n  SVGPathSegList: false,\n  SVGPointList: false,\n  SVGStringList: false,\n  SVGTransformList: false,\n  SourceBufferList: false,\n  StyleSheetList: true, // TODO: Not spec compliant, should be false.\n  TextTrackCueList: false,\n  TextTrackList: false,\n  TouchList: false\n};\n\nfor (var collections = getKeys(DOMIterables), i = 0; i < collections.length; i++) {\n  var NAME = collections[i];\n  var explicit = DOMIterables[NAME];\n  var Collection = global[NAME];\n  var proto = Collection && Collection.prototype;\n  var key;\n  if (proto) {\n    if (!proto[ITERATOR]) hide(proto, ITERATOR, ArrayValues);\n    if (!proto[TO_STRING_TAG]) hide(proto, TO_STRING_TAG, NAME);\n    Iterators[NAME] = ArrayValues;\n    if (explicit) for (key in $iterators) if (!proto[key]) redefine(proto, key, $iterators[key], true);\n  }\n}\n","require('./_typed-array')('Uint8', 1, function (init) {\n  return function Uint8Array(data, byteOffset, length) {\n    return init(this, data, byteOffset, length);\n  };\n});\n","'use strict';\nif (require('./_descriptors')) {\n  var LIBRARY = require('./_library');\n  var global = require('./_global');\n  var fails = require('./_fails');\n  var $export = require('./_export');\n  var $typed = require('./_typed');\n  var $buffer = require('./_typed-buffer');\n  var ctx = require('./_ctx');\n  var anInstance = require('./_an-instance');\n  var propertyDesc = require('./_property-desc');\n  var hide = require('./_hide');\n  var redefineAll = require('./_redefine-all');\n  var toInteger = require('./_to-integer');\n  var toLength = require('./_to-length');\n  var toIndex = require('./_to-index');\n  var toAbsoluteIndex = require('./_to-absolute-index');\n  var toPrimitive = require('./_to-primitive');\n  var has = require('./_has');\n  var classof = require('./_classof');\n  var isObject = require('./_is-object');\n  var toObject = require('./_to-object');\n  var isArrayIter = require('./_is-array-iter');\n  var create = require('./_object-create');\n  var getPrototypeOf = require('./_object-gpo');\n  var gOPN = require('./_object-gopn').f;\n  var getIterFn = require('./core.get-iterator-method');\n  var uid = require('./_uid');\n  var wks = require('./_wks');\n  var createArrayMethod = require('./_array-methods');\n  var createArrayIncludes = require('./_array-includes');\n  var speciesConstructor = require('./_species-constructor');\n  var ArrayIterators = require('./es6.array.iterator');\n  var Iterators = require('./_iterators');\n  var $iterDetect = require('./_iter-detect');\n  var setSpecies = require('./_set-species');\n  var arrayFill = require('./_array-fill');\n  var arrayCopyWithin = require('./_array-copy-within');\n  var $DP = require('./_object-dp');\n  var $GOPD = require('./_object-gopd');\n  var dP = $DP.f;\n  var gOPD = $GOPD.f;\n  var RangeError = global.RangeError;\n  var TypeError = global.TypeError;\n  var Uint8Array = global.Uint8Array;\n  var ARRAY_BUFFER = 'ArrayBuffer';\n  var SHARED_BUFFER = 'Shared' + ARRAY_BUFFER;\n  var BYTES_PER_ELEMENT = 'BYTES_PER_ELEMENT';\n  var PROTOTYPE = 'prototype';\n  var ArrayProto = Array[PROTOTYPE];\n  var $ArrayBuffer = $buffer.ArrayBuffer;\n  var $DataView = $buffer.DataView;\n  var arrayForEach = createArrayMethod(0);\n  var arrayFilter = createArrayMethod(2);\n  var arraySome = createArrayMethod(3);\n  var arrayEvery = createArrayMethod(4);\n  var arrayFind = createArrayMethod(5);\n  var arrayFindIndex = createArrayMethod(6);\n  var arrayIncludes = createArrayIncludes(true);\n  var arrayIndexOf = createArrayIncludes(false);\n  var arrayValues = ArrayIterators.values;\n  var arrayKeys = ArrayIterators.keys;\n  var arrayEntries = ArrayIterators.entries;\n  var arrayLastIndexOf = ArrayProto.lastIndexOf;\n  var arrayReduce = ArrayProto.reduce;\n  var arrayReduceRight = ArrayProto.reduceRight;\n  var arrayJoin = ArrayProto.join;\n  var arraySort = ArrayProto.sort;\n  var arraySlice = ArrayProto.slice;\n  var arrayToString = ArrayProto.toString;\n  var arrayToLocaleString = ArrayProto.toLocaleString;\n  var ITERATOR = wks('iterator');\n  var TAG = wks('toStringTag');\n  var TYPED_CONSTRUCTOR = uid('typed_constructor');\n  var DEF_CONSTRUCTOR = uid('def_constructor');\n  var ALL_CONSTRUCTORS = $typed.CONSTR;\n  var TYPED_ARRAY = $typed.TYPED;\n  var VIEW = $typed.VIEW;\n  var WRONG_LENGTH = 'Wrong length!';\n\n  var $map = createArrayMethod(1, function (O, length) {\n    return allocate(speciesConstructor(O, O[DEF_CONSTRUCTOR]), length);\n  });\n\n  var LITTLE_ENDIAN = fails(function () {\n    // eslint-disable-next-line no-undef\n    return new Uint8Array(new Uint16Array([1]).buffer)[0] === 1;\n  });\n\n  var FORCED_SET = !!Uint8Array && !!Uint8Array[PROTOTYPE].set && fails(function () {\n    new Uint8Array(1).set({});\n  });\n\n  var toOffset = function (it, BYTES) {\n    var offset = toInteger(it);\n    if (offset < 0 || offset % BYTES) throw RangeError('Wrong offset!');\n    return offset;\n  };\n\n  var validate = function (it) {\n    if (isObject(it) && TYPED_ARRAY in it) return it;\n    throw TypeError(it + ' is not a typed array!');\n  };\n\n  var allocate = function (C, length) {\n    if (!(isObject(C) && TYPED_CONSTRUCTOR in C)) {\n      throw TypeError('It is not a typed array constructor!');\n    } return new C(length);\n  };\n\n  var speciesFromList = function (O, list) {\n    return fromList(speciesConstructor(O, O[DEF_CONSTRUCTOR]), list);\n  };\n\n  var fromList = function (C, list) {\n    var index = 0;\n    var length = list.length;\n    var result = allocate(C, length);\n    while (length > index) result[index] = list[index++];\n    return result;\n  };\n\n  var addGetter = function (it, key, internal) {\n    dP(it, key, { get: function () { return this._d[internal]; } });\n  };\n\n  var $from = function from(source /* , mapfn, thisArg */) {\n    var O = toObject(source);\n    var aLen = arguments.length;\n    var mapfn = aLen > 1 ? arguments[1] : undefined;\n    var mapping = mapfn !== undefined;\n    var iterFn = getIterFn(O);\n    var i, length, values, result, step, iterator;\n    if (iterFn != undefined && !isArrayIter(iterFn)) {\n      for (iterator = iterFn.call(O), values = [], i = 0; !(step = iterator.next()).done; i++) {\n        values.push(step.value);\n      } O = values;\n    }\n    if (mapping && aLen > 2) mapfn = ctx(mapfn, arguments[2], 2);\n    for (i = 0, length = toLength(O.length), result = allocate(this, length); length > i; i++) {\n      result[i] = mapping ? mapfn(O[i], i) : O[i];\n    }\n    return result;\n  };\n\n  var $of = function of(/* ...items */) {\n    var index = 0;\n    var length = arguments.length;\n    var result = allocate(this, length);\n    while (length > index) result[index] = arguments[index++];\n    return result;\n  };\n\n  // iOS Safari 6.x fails here\n  var TO_LOCALE_BUG = !!Uint8Array && fails(function () { arrayToLocaleString.call(new Uint8Array(1)); });\n\n  var $toLocaleString = function toLocaleString() {\n    return arrayToLocaleString.apply(TO_LOCALE_BUG ? arraySlice.call(validate(this)) : validate(this), arguments);\n  };\n\n  var proto = {\n    copyWithin: function copyWithin(target, start /* , end */) {\n      return arrayCopyWithin.call(validate(this), target, start, arguments.length > 2 ? arguments[2] : undefined);\n    },\n    every: function every(callbackfn /* , thisArg */) {\n      return arrayEvery(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    fill: function fill(value /* , start, end */) { // eslint-disable-line no-unused-vars\n      return arrayFill.apply(validate(this), arguments);\n    },\n    filter: function filter(callbackfn /* , thisArg */) {\n      return speciesFromList(this, arrayFilter(validate(this), callbackfn,\n        arguments.length > 1 ? arguments[1] : undefined));\n    },\n    find: function find(predicate /* , thisArg */) {\n      return arrayFind(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    findIndex: function findIndex(predicate /* , thisArg */) {\n      return arrayFindIndex(validate(this), predicate, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    forEach: function forEach(callbackfn /* , thisArg */) {\n      arrayForEach(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    indexOf: function indexOf(searchElement /* , fromIndex */) {\n      return arrayIndexOf(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    includes: function includes(searchElement /* , fromIndex */) {\n      return arrayIncludes(validate(this), searchElement, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    join: function join(separator) { // eslint-disable-line no-unused-vars\n      return arrayJoin.apply(validate(this), arguments);\n    },\n    lastIndexOf: function lastIndexOf(searchElement /* , fromIndex */) { // eslint-disable-line no-unused-vars\n      return arrayLastIndexOf.apply(validate(this), arguments);\n    },\n    map: function map(mapfn /* , thisArg */) {\n      return $map(validate(this), mapfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    reduce: function reduce(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduce.apply(validate(this), arguments);\n    },\n    reduceRight: function reduceRight(callbackfn /* , initialValue */) { // eslint-disable-line no-unused-vars\n      return arrayReduceRight.apply(validate(this), arguments);\n    },\n    reverse: function reverse() {\n      var that = this;\n      var length = validate(that).length;\n      var middle = Math.floor(length / 2);\n      var index = 0;\n      var value;\n      while (index < middle) {\n        value = that[index];\n        that[index++] = that[--length];\n        that[length] = value;\n      } return that;\n    },\n    some: function some(callbackfn /* , thisArg */) {\n      return arraySome(validate(this), callbackfn, arguments.length > 1 ? arguments[1] : undefined);\n    },\n    sort: function sort(comparefn) {\n      return arraySort.call(validate(this), comparefn);\n    },\n    subarray: function subarray(begin, end) {\n      var O = validate(this);\n      var length = O.length;\n      var $begin = toAbsoluteIndex(begin, length);\n      return new (speciesConstructor(O, O[DEF_CONSTRUCTOR]))(\n        O.buffer,\n        O.byteOffset + $begin * O.BYTES_PER_ELEMENT,\n        toLength((end === undefined ? length : toAbsoluteIndex(end, length)) - $begin)\n      );\n    }\n  };\n\n  var $slice = function slice(start, end) {\n    return speciesFromList(this, arraySlice.call(validate(this), start, end));\n  };\n\n  var $set = function set(arrayLike /* , offset */) {\n    validate(this);\n    var offset = toOffset(arguments[1], 1);\n    var length = this.length;\n    var src = toObject(arrayLike);\n    var len = toLength(src.length);\n    var index = 0;\n    if (len + offset > length) throw RangeError(WRONG_LENGTH);\n    while (index < len) this[offset + index] = src[index++];\n  };\n\n  var $iterators = {\n    entries: function entries() {\n      return arrayEntries.call(validate(this));\n    },\n    keys: function keys() {\n      return arrayKeys.call(validate(this));\n    },\n    values: function values() {\n      return arrayValues.call(validate(this));\n    }\n  };\n\n  var isTAIndex = function (target, key) {\n    return isObject(target)\n      && target[TYPED_ARRAY]\n      && typeof key != 'symbol'\n      && key in target\n      && String(+key) == String(key);\n  };\n  var $getDesc = function getOwnPropertyDescriptor(target, key) {\n    return isTAIndex(target, key = toPrimitive(key, true))\n      ? propertyDesc(2, target[key])\n      : gOPD(target, key);\n  };\n  var $setDesc = function defineProperty(target, key, desc) {\n    if (isTAIndex(target, key = toPrimitive(key, true))\n      && isObject(desc)\n      && has(desc, 'value')\n      && !has(desc, 'get')\n      && !has(desc, 'set')\n      // TODO: add validation descriptor w/o calling accessors\n      && !desc.configurable\n      && (!has(desc, 'writable') || desc.writable)\n      && (!has(desc, 'enumerable') || desc.enumerable)\n    ) {\n      target[key] = desc.value;\n      return target;\n    } return dP(target, key, desc);\n  };\n\n  if (!ALL_CONSTRUCTORS) {\n    $GOPD.f = $getDesc;\n    $DP.f = $setDesc;\n  }\n\n  $export($export.S + $export.F * !ALL_CONSTRUCTORS, 'Object', {\n    getOwnPropertyDescriptor: $getDesc,\n    defineProperty: $setDesc\n  });\n\n  if (fails(function () { arrayToString.call({}); })) {\n    arrayToString = arrayToLocaleString = function toString() {\n      return arrayJoin.call(this);\n    };\n  }\n\n  var $TypedArrayPrototype$ = redefineAll({}, proto);\n  redefineAll($TypedArrayPrototype$, $iterators);\n  hide($TypedArrayPrototype$, ITERATOR, $iterators.values);\n  redefineAll($TypedArrayPrototype$, {\n    slice: $slice,\n    set: $set,\n    constructor: function () { /* noop */ },\n    toString: arrayToString,\n    toLocaleString: $toLocaleString\n  });\n  addGetter($TypedArrayPrototype$, 'buffer', 'b');\n  addGetter($TypedArrayPrototype$, 'byteOffset', 'o');\n  addGetter($TypedArrayPrototype$, 'byteLength', 'l');\n  addGetter($TypedArrayPrototype$, 'length', 'e');\n  dP($TypedArrayPrototype$, TAG, {\n    get: function () { return this[TYPED_ARRAY]; }\n  });\n\n  // eslint-disable-next-line max-statements\n  module.exports = function (KEY, BYTES, wrapper, CLAMPED) {\n    CLAMPED = !!CLAMPED;\n    var NAME = KEY + (CLAMPED ? 'Clamped' : '') + 'Array';\n    var GETTER = 'get' + KEY;\n    var SETTER = 'set' + KEY;\n    var TypedArray = global[NAME];\n    var Base = TypedArray || {};\n    var TAC = TypedArray && getPrototypeOf(TypedArray);\n    var FORCED = !TypedArray || !$typed.ABV;\n    var O = {};\n    var TypedArrayPrototype = TypedArray && TypedArray[PROTOTYPE];\n    var getter = function (that, index) {\n      var data = that._d;\n      return data.v[GETTER](index * BYTES + data.o, LITTLE_ENDIAN);\n    };\n    var setter = function (that, index, value) {\n      var data = that._d;\n      if (CLAMPED) value = (value = Math.round(value)) < 0 ? 0 : value > 0xff ? 0xff : value & 0xff;\n      data.v[SETTER](index * BYTES + data.o, value, LITTLE_ENDIAN);\n    };\n    var addElement = function (that, index) {\n      dP(that, index, {\n        get: function () {\n          return getter(this, index);\n        },\n        set: function (value) {\n          return setter(this, index, value);\n        },\n        enumerable: true\n      });\n    };\n    if (FORCED) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME, '_d');\n        var index = 0;\n        var offset = 0;\n        var buffer, byteLength, length, klass;\n        if (!isObject(data)) {\n          length = toIndex(data);\n          byteLength = length * BYTES;\n          buffer = new $ArrayBuffer(byteLength);\n        } else if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          buffer = data;\n          offset = toOffset($offset, BYTES);\n          var $len = data.byteLength;\n          if ($length === undefined) {\n            if ($len % BYTES) throw RangeError(WRONG_LENGTH);\n            byteLength = $len - offset;\n            if (byteLength < 0) throw RangeError(WRONG_LENGTH);\n          } else {\n            byteLength = toLength($length) * BYTES;\n            if (byteLength + offset > $len) throw RangeError(WRONG_LENGTH);\n          }\n          length = byteLength / BYTES;\n        } else if (TYPED_ARRAY in data) {\n          return fromList(TypedArray, data);\n        } else {\n          return $from.call(TypedArray, data);\n        }\n        hide(that, '_d', {\n          b: buffer,\n          o: offset,\n          l: byteLength,\n          e: length,\n          v: new $DataView(buffer)\n        });\n        while (index < length) addElement(that, index++);\n      });\n      TypedArrayPrototype = TypedArray[PROTOTYPE] = create($TypedArrayPrototype$);\n      hide(TypedArrayPrototype, 'constructor', TypedArray);\n    } else if (!fails(function () {\n      TypedArray(1);\n    }) || !fails(function () {\n      new TypedArray(-1); // eslint-disable-line no-new\n    }) || !$iterDetect(function (iter) {\n      new TypedArray(); // eslint-disable-line no-new\n      new TypedArray(null); // eslint-disable-line no-new\n      new TypedArray(1.5); // eslint-disable-line no-new\n      new TypedArray(iter); // eslint-disable-line no-new\n    }, true)) {\n      TypedArray = wrapper(function (that, data, $offset, $length) {\n        anInstance(that, TypedArray, NAME);\n        var klass;\n        // `ws` module bug, temporarily remove validation length for Uint8Array\n        // https://github.com/websockets/ws/pull/645\n        if (!isObject(data)) return new Base(toIndex(data));\n        if (data instanceof $ArrayBuffer || (klass = classof(data)) == ARRAY_BUFFER || klass == SHARED_BUFFER) {\n          return $length !== undefined\n            ? new Base(data, toOffset($offset, BYTES), $length)\n            : $offset !== undefined\n              ? new Base(data, toOffset($offset, BYTES))\n              : new Base(data);\n        }\n        if (TYPED_ARRAY in data) return fromList(TypedArray, data);\n        return $from.call(TypedArray, data);\n      });\n      arrayForEach(TAC !== Function.prototype ? gOPN(Base).concat(gOPN(TAC)) : gOPN(Base), function (key) {\n        if (!(key in TypedArray)) hide(TypedArray, key, Base[key]);\n      });\n      TypedArray[PROTOTYPE] = TypedArrayPrototype;\n      if (!LIBRARY) TypedArrayPrototype.constructor = TypedArray;\n    }\n    var $nativeIterator = TypedArrayPrototype[ITERATOR];\n    var CORRECT_ITER_NAME = !!$nativeIterator\n      && ($nativeIterator.name == 'values' || $nativeIterator.name == undefined);\n    var $iterator = $iterators.values;\n    hide(TypedArray, TYPED_CONSTRUCTOR, true);\n    hide(TypedArrayPrototype, TYPED_ARRAY, NAME);\n    hide(TypedArrayPrototype, VIEW, true);\n    hide(TypedArrayPrototype, DEF_CONSTRUCTOR, TypedArray);\n\n    if (CLAMPED ? new TypedArray(1)[TAG] != NAME : !(TAG in TypedArrayPrototype)) {\n      dP(TypedArrayPrototype, TAG, {\n        get: function () { return NAME; }\n      });\n    }\n\n    O[NAME] = TypedArray;\n\n    $export($export.G + $export.W + $export.F * (TypedArray != Base), O);\n\n    $export($export.S, NAME, {\n      BYTES_PER_ELEMENT: BYTES\n    });\n\n    $export($export.S + $export.F * fails(function () { Base.of.call(TypedArray, 1); }), NAME, {\n      from: $from,\n      of: $of\n    });\n\n    if (!(BYTES_PER_ELEMENT in TypedArrayPrototype)) hide(TypedArrayPrototype, BYTES_PER_ELEMENT, BYTES);\n\n    $export($export.P, NAME, proto);\n\n    setSpecies(NAME);\n\n    $export($export.P + $export.F * FORCED_SET, NAME, { set: $set });\n\n    $export($export.P + $export.F * !CORRECT_ITER_NAME, NAME, $iterators);\n\n    if (!LIBRARY && TypedArrayPrototype.toString != arrayToString) TypedArrayPrototype.toString = arrayToString;\n\n    $export($export.P + $export.F * fails(function () {\n      new TypedArray(1).slice();\n    }), NAME, { slice: $slice });\n\n    $export($export.P + $export.F * (fails(function () {\n      return [1, 2].toLocaleString() != new TypedArray([1, 2]).toLocaleString();\n    }) || !fails(function () {\n      TypedArrayPrototype.toLocaleString.call([1, 2]);\n    })), NAME, { toLocaleString: $toLocaleString });\n\n    Iterators[NAME] = CORRECT_ITER_NAME ? $nativeIterator : $iterator;\n    if (!LIBRARY && !CORRECT_ITER_NAME) hide(TypedArrayPrototype, ITERATOR, $iterator);\n  };\n} else module.exports = function () { /* empty */ };\n","'use strict';\nvar global = require('./_global');\nvar DESCRIPTORS = require('./_descriptors');\nvar LIBRARY = require('./_library');\nvar $typed = require('./_typed');\nvar hide = require('./_hide');\nvar redefineAll = require('./_redefine-all');\nvar fails = require('./_fails');\nvar anInstance = require('./_an-instance');\nvar toInteger = require('./_to-integer');\nvar toLength = require('./_to-length');\nvar toIndex = require('./_to-index');\nvar gOPN = require('./_object-gopn').f;\nvar dP = require('./_object-dp').f;\nvar arrayFill = require('./_array-fill');\nvar setToStringTag = require('./_set-to-string-tag');\nvar ARRAY_BUFFER = 'ArrayBuffer';\nvar DATA_VIEW = 'DataView';\nvar PROTOTYPE = 'prototype';\nvar WRONG_LENGTH = 'Wrong length!';\nvar WRONG_INDEX = 'Wrong index!';\nvar $ArrayBuffer = global[ARRAY_BUFFER];\nvar $DataView = global[DATA_VIEW];\nvar Math = global.Math;\nvar RangeError = global.RangeError;\n// eslint-disable-next-line no-shadow-restricted-names\nvar Infinity = global.Infinity;\nvar BaseBuffer = $ArrayBuffer;\nvar abs = Math.abs;\nvar pow = Math.pow;\nvar floor = Math.floor;\nvar log = Math.log;\nvar LN2 = Math.LN2;\nvar BUFFER = 'buffer';\nvar BYTE_LENGTH = 'byteLength';\nvar BYTE_OFFSET = 'byteOffset';\nvar $BUFFER = DESCRIPTORS ? '_b' : BUFFER;\nvar $LENGTH = DESCRIPTORS ? '_l' : BYTE_LENGTH;\nvar $OFFSET = DESCRIPTORS ? '_o' : BYTE_OFFSET;\n\n// IEEE754 conversions based on https://github.com/feross/ieee754\nfunction packIEEE754(value, mLen, nBytes) {\n  var buffer = new Array(nBytes);\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var rt = mLen === 23 ? pow(2, -24) - pow(2, -77) : 0;\n  var i = 0;\n  var s = value < 0 || value === 0 && 1 / value < 0 ? 1 : 0;\n  var e, m, c;\n  value = abs(value);\n  // eslint-disable-next-line no-self-compare\n  if (value != value || value === Infinity) {\n    // eslint-disable-next-line no-self-compare\n    m = value != value ? 1 : 0;\n    e = eMax;\n  } else {\n    e = floor(log(value) / LN2);\n    if (value * (c = pow(2, -e)) < 1) {\n      e--;\n      c *= 2;\n    }\n    if (e + eBias >= 1) {\n      value += rt / c;\n    } else {\n      value += rt * pow(2, 1 - eBias);\n    }\n    if (value * c >= 2) {\n      e++;\n      c /= 2;\n    }\n    if (e + eBias >= eMax) {\n      m = 0;\n      e = eMax;\n    } else if (e + eBias >= 1) {\n      m = (value * c - 1) * pow(2, mLen);\n      e = e + eBias;\n    } else {\n      m = value * pow(2, eBias - 1) * pow(2, mLen);\n      e = 0;\n    }\n  }\n  for (; mLen >= 8; buffer[i++] = m & 255, m /= 256, mLen -= 8);\n  e = e << mLen | m;\n  eLen += mLen;\n  for (; eLen > 0; buffer[i++] = e & 255, e /= 256, eLen -= 8);\n  buffer[--i] |= s * 128;\n  return buffer;\n}\nfunction unpackIEEE754(buffer, mLen, nBytes) {\n  var eLen = nBytes * 8 - mLen - 1;\n  var eMax = (1 << eLen) - 1;\n  var eBias = eMax >> 1;\n  var nBits = eLen - 7;\n  var i = nBytes - 1;\n  var s = buffer[i--];\n  var e = s & 127;\n  var m;\n  s >>= 7;\n  for (; nBits > 0; e = e * 256 + buffer[i], i--, nBits -= 8);\n  m = e & (1 << -nBits) - 1;\n  e >>= -nBits;\n  nBits += mLen;\n  for (; nBits > 0; m = m * 256 + buffer[i], i--, nBits -= 8);\n  if (e === 0) {\n    e = 1 - eBias;\n  } else if (e === eMax) {\n    return m ? NaN : s ? -Infinity : Infinity;\n  } else {\n    m = m + pow(2, mLen);\n    e = e - eBias;\n  } return (s ? -1 : 1) * m * pow(2, e - mLen);\n}\n\nfunction unpackI32(bytes) {\n  return bytes[3] << 24 | bytes[2] << 16 | bytes[1] << 8 | bytes[0];\n}\nfunction packI8(it) {\n  return [it & 0xff];\n}\nfunction packI16(it) {\n  return [it & 0xff, it >> 8 & 0xff];\n}\nfunction packI32(it) {\n  return [it & 0xff, it >> 8 & 0xff, it >> 16 & 0xff, it >> 24 & 0xff];\n}\nfunction packF64(it) {\n  return packIEEE754(it, 52, 8);\n}\nfunction packF32(it) {\n  return packIEEE754(it, 23, 4);\n}\n\nfunction addGetter(C, key, internal) {\n  dP(C[PROTOTYPE], key, { get: function () { return this[internal]; } });\n}\n\nfunction get(view, bytes, index, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = store.slice(start, start + bytes);\n  return isLittleEndian ? pack : pack.reverse();\n}\nfunction set(view, bytes, index, conversion, value, isLittleEndian) {\n  var numIndex = +index;\n  var intIndex = toIndex(numIndex);\n  if (intIndex + bytes > view[$LENGTH]) throw RangeError(WRONG_INDEX);\n  var store = view[$BUFFER]._b;\n  var start = intIndex + view[$OFFSET];\n  var pack = conversion(+value);\n  for (var i = 0; i < bytes; i++) store[start + i] = pack[isLittleEndian ? i : bytes - i - 1];\n}\n\nif (!$typed.ABV) {\n  $ArrayBuffer = function ArrayBuffer(length) {\n    anInstance(this, $ArrayBuffer, ARRAY_BUFFER);\n    var byteLength = toIndex(length);\n    this._b = arrayFill.call(new Array(byteLength), 0);\n    this[$LENGTH] = byteLength;\n  };\n\n  $DataView = function DataView(buffer, byteOffset, byteLength) {\n    anInstance(this, $DataView, DATA_VIEW);\n    anInstance(buffer, $ArrayBuffer, DATA_VIEW);\n    var bufferLength = buffer[$LENGTH];\n    var offset = toInteger(byteOffset);\n    if (offset < 0 || offset > bufferLength) throw RangeError('Wrong offset!');\n    byteLength = byteLength === undefined ? bufferLength - offset : toLength(byteLength);\n    if (offset + byteLength > bufferLength) throw RangeError(WRONG_LENGTH);\n    this[$BUFFER] = buffer;\n    this[$OFFSET] = offset;\n    this[$LENGTH] = byteLength;\n  };\n\n  if (DESCRIPTORS) {\n    addGetter($ArrayBuffer, BYTE_LENGTH, '_l');\n    addGetter($DataView, BUFFER, '_b');\n    addGetter($DataView, BYTE_LENGTH, '_l');\n    addGetter($DataView, BYTE_OFFSET, '_o');\n  }\n\n  redefineAll($DataView[PROTOTYPE], {\n    getInt8: function getInt8(byteOffset) {\n      return get(this, 1, byteOffset)[0] << 24 >> 24;\n    },\n    getUint8: function getUint8(byteOffset) {\n      return get(this, 1, byteOffset)[0];\n    },\n    getInt16: function getInt16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return (bytes[1] << 8 | bytes[0]) << 16 >> 16;\n    },\n    getUint16: function getUint16(byteOffset /* , littleEndian */) {\n      var bytes = get(this, 2, byteOffset, arguments[1]);\n      return bytes[1] << 8 | bytes[0];\n    },\n    getInt32: function getInt32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1]));\n    },\n    getUint32: function getUint32(byteOffset /* , littleEndian */) {\n      return unpackI32(get(this, 4, byteOffset, arguments[1])) >>> 0;\n    },\n    getFloat32: function getFloat32(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 4, byteOffset, arguments[1]), 23, 4);\n    },\n    getFloat64: function getFloat64(byteOffset /* , littleEndian */) {\n      return unpackIEEE754(get(this, 8, byteOffset, arguments[1]), 52, 8);\n    },\n    setInt8: function setInt8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      set(this, 1, byteOffset, packI8, value);\n    },\n    setInt16: function setInt16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setUint16: function setUint16(byteOffset, value /* , littleEndian */) {\n      set(this, 2, byteOffset, packI16, value, arguments[2]);\n    },\n    setInt32: function setInt32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setUint32: function setUint32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packI32, value, arguments[2]);\n    },\n    setFloat32: function setFloat32(byteOffset, value /* , littleEndian */) {\n      set(this, 4, byteOffset, packF32, value, arguments[2]);\n    },\n    setFloat64: function setFloat64(byteOffset, value /* , littleEndian */) {\n      set(this, 8, byteOffset, packF64, value, arguments[2]);\n    }\n  });\n} else {\n  if (!fails(function () {\n    $ArrayBuffer(1);\n  }) || !fails(function () {\n    new $ArrayBuffer(-1); // eslint-disable-line no-new\n  }) || fails(function () {\n    new $ArrayBuffer(); // eslint-disable-line no-new\n    new $ArrayBuffer(1.5); // eslint-disable-line no-new\n    new $ArrayBuffer(NaN); // eslint-disable-line no-new\n    return $ArrayBuffer.name != ARRAY_BUFFER;\n  })) {\n    $ArrayBuffer = function ArrayBuffer(length) {\n      anInstance(this, $ArrayBuffer);\n      return new BaseBuffer(toIndex(length));\n    };\n    var ArrayBufferProto = $ArrayBuffer[PROTOTYPE] = BaseBuffer[PROTOTYPE];\n    for (var keys = gOPN(BaseBuffer), j = 0, key; keys.length > j;) {\n      if (!((key = keys[j++]) in $ArrayBuffer)) hide($ArrayBuffer, key, BaseBuffer[key]);\n    }\n    if (!LIBRARY) ArrayBufferProto.constructor = $ArrayBuffer;\n  }\n  // iOS Safari 7.x bug\n  var view = new $DataView(new $ArrayBuffer(2));\n  var $setInt8 = $DataView[PROTOTYPE].setInt8;\n  view.setInt8(0, 2147483648);\n  view.setInt8(1, 2147483649);\n  if (view.getInt8(0) || !view.getInt8(1)) redefineAll($DataView[PROTOTYPE], {\n    setInt8: function setInt8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    },\n    setUint8: function setUint8(byteOffset, value) {\n      $setInt8.call(this, byteOffset, value << 24 >> 24);\n    }\n  }, true);\n}\nsetToStringTag($ArrayBuffer, ARRAY_BUFFER);\nsetToStringTag($DataView, DATA_VIEW);\nhide($DataView[PROTOTYPE], $typed.VIEW, true);\nexports[ARRAY_BUFFER] = $ArrayBuffer;\nexports[DATA_VIEW] = $DataView;\n","// 9.4.2.3 ArraySpeciesCreate(originalArray, length)\nvar speciesConstructor = require('./_array-species-constructor');\n\nmodule.exports = function (original, length) {\n  return new (speciesConstructor(original))(length);\n};\n","var isObject = require('./_is-object');\nvar isArray = require('./_is-array');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (original) {\n  var C;\n  if (isArray(original)) {\n    C = original.constructor;\n    // cross-realm fallback\n    if (typeof C == 'function' && (C === Array || isArray(C.prototype))) C = undefined;\n    if (isObject(C)) {\n      C = C[SPECIES];\n      if (C === null) C = undefined;\n    }\n  } return C === undefined ? Array : C;\n};\n","// 7.3.20 SpeciesConstructor(O, defaultConstructor)\nvar anObject = require('./_an-object');\nvar aFunction = require('./_a-function');\nvar SPECIES = require('./_wks')('species');\nmodule.exports = function (O, D) {\n  var C = anObject(O).constructor;\n  var S;\n  return C === undefined || (S = anObject(C)[SPECIES]) == undefined ? D : aFunction(S);\n};\n","'use strict';\nvar global = require('./_global');\nvar dP = require('./_object-dp');\nvar DESCRIPTORS = require('./_descriptors');\nvar SPECIES = require('./_wks')('species');\n\nmodule.exports = function (KEY) {\n  var C = global[KEY];\n  if (DESCRIPTORS && C && !C[SPECIES]) dP.f(C, SPECIES, {\n    configurable: true,\n    get: function () { return this; }\n  });\n};\n","// 22.1.3.3 Array.prototype.copyWithin(target, start, end = this.length)\n'use strict';\nvar toObject = require('./_to-object');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\n\nmodule.exports = [].copyWithin || function copyWithin(target /* = 0 */, start /* = 0, end = @length */) {\n  var O = toObject(this);\n  var len = toLength(O.length);\n  var to = toAbsoluteIndex(target, len);\n  var from = toAbsoluteIndex(start, len);\n  var end = arguments.length > 2 ? arguments[2] : undefined;\n  var count = Math.min((end === undefined ? len : toAbsoluteIndex(end, len)) - from, len - to);\n  var inc = 1;\n  if (from < to && to < from + count) {\n    inc = -1;\n    from += count - 1;\n    to += count - 1;\n  }\n  while (count-- > 0) {\n    if (from in O) O[to] = O[from];\n    else delete O[to];\n    to += inc;\n    from += inc;\n  } return O;\n};\n","// https://github.com/tc39/proposal-object-values-entries\nvar $export = require('./_export');\nvar $entries = require('./_object-to-array')(true);\n\n$export($export.S, 'Object', {\n  entries: function entries(it) {\n    return $entries(it);\n  }\n});\n","var DESCRIPTORS = require('./_descriptors');\nvar getKeys = require('./_object-keys');\nvar toIObject = require('./_to-iobject');\nvar isEnum = require('./_object-pie').f;\nmodule.exports = function (isEntries) {\n  return function (it) {\n    var O = toIObject(it);\n    var keys = getKeys(O);\n    var length = keys.length;\n    var i = 0;\n    var result = [];\n    var key;\n    while (length > i) {\n      key = keys[i++];\n      if (!DESCRIPTORS || isEnum.call(O, key)) {\n        result.push(isEntries ? [key, O[key]] : O[key]);\n      }\n    }\n    return result;\n  };\n};\n","// 22.1.2.2 / 15.4.3.2 Array.isArray(arg)\nvar $export = require('./_export');\n\n$export($export.S, 'Array', { isArray: require('./_is-array') });\n","'use strict';\nvar $export = require('./_export');\nvar html = require('./_html');\nvar cof = require('./_cof');\nvar toAbsoluteIndex = require('./_to-absolute-index');\nvar toLength = require('./_to-length');\nvar arraySlice = [].slice;\n\n// fallback for not array-like ES3 strings and DOM objects\n$export($export.P + $export.F * require('./_fails')(function () {\n  if (html) arraySlice.call(html);\n}), 'Array', {\n  slice: function slice(begin, end) {\n    var len = toLength(this.length);\n    var klass = cof(this);\n    end = end === undefined ? len : end;\n    if (klass == 'Array') return arraySlice.call(this, begin, end);\n    var start = toAbsoluteIndex(begin, len);\n    var upTo = toAbsoluteIndex(end, len);\n    var size = toLength(upTo - start);\n    var cloned = new Array(size);\n    var i = 0;\n    for (; i < size; i++) cloned[i] = klass == 'String'\n      ? this.charAt(start + i)\n      : this[start + i];\n    return cloned;\n  }\n});\n","var dP = require('./_object-dp').f;\nvar FProto = Function.prototype;\nvar nameRE = /^\\s*function ([^ (]*)/;\nvar NAME = 'name';\n\n// 19.2.4.2 name\nNAME in FProto || require('./_descriptors') && dP(FProto, NAME, {\n  configurable: true,\n  get: function () {\n    try {\n      return ('' + this).match(nameRE)[1];\n    } catch (e) {\n      return '';\n    }\n  }\n});\n","'use strict';\nvar $export = require('./_export');\nvar aFunction = require('./_a-function');\nvar toObject = require('./_to-object');\nvar fails = require('./_fails');\nvar $sort = [].sort;\nvar test = [1, 2, 3];\n\n$export($export.P + $export.F * (fails(function () {\n  // IE8-\n  test.sort(undefined);\n}) || !fails(function () {\n  // V8 bug\n  test.sort(null);\n  // Old WebKit\n}) || !require('./_strict-method')($sort)), 'Array', {\n  // 22.1.3.25 Array.prototype.sort(comparefn)\n  sort: function sort(comparefn) {\n    return comparefn === undefined\n      ? $sort.call(toObject(this))\n      : $sort.call(toObject(this), aFunction(comparefn));\n  }\n});\n","// 19.1.2.14 Object.keys(O)\nvar toObject = require('./_to-object');\nvar $keys = require('./_object-keys');\n\nrequire('./_object-sap')('keys', function () {\n  return function keys(it) {\n    return $keys(toObject(it));\n  };\n});\n","'use strict';\nvar $export = require('./_export');\nvar $indexOf = require('./_array-includes')(false);\nvar $native = [].indexOf;\nvar NEGATIVE_ZERO = !!$native && 1 / [1].indexOf(1, -0) < 0;\n\n$export($export.P + $export.F * (NEGATIVE_ZERO || !require('./_strict-method')($native)), 'Array', {\n  // 22.1.3.11 / 15.4.4.14 Array.prototype.indexOf(searchElement [, fromIndex])\n  indexOf: function indexOf(searchElement /* , fromIndex = 0 */) {\n    return NEGATIVE_ZERO\n      // convert -0 to +0\n      ? $native.apply(this, arguments) || 0\n      : $indexOf(this, searchElement, arguments[1]);\n  }\n});\n","var $export = require('./_export');\n// 19.1.2.4 / 15.2.3.6 Object.defineProperty(O, P, Attributes)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperty: require('./_object-dp').f });\n","'use strict';\nvar $export = require('./_export');\nvar $filter = require('./_array-methods')(2);\n\n$export($export.P + $export.F * !require('./_strict-method')([].filter, true), 'Array', {\n  // 22.1.3.7 / 15.4.4.20 Array.prototype.filter(callbackfn [, thisArg])\n  filter: function filter(callbackfn /* , thisArg */) {\n    return $filter(this, callbackfn, arguments[1]);\n  }\n});\n","// 19.1.2.6 Object.getOwnPropertyDescriptor(O, P)\nvar toIObject = require('./_to-iobject');\nvar $getOwnPropertyDescriptor = require('./_object-gopd').f;\n\nrequire('./_object-sap')('getOwnPropertyDescriptor', function () {\n  return function getOwnPropertyDescriptor(it, key) {\n    return $getOwnPropertyDescriptor(toIObject(it), key);\n  };\n});\n","// https://github.com/tc39/proposal-object-getownpropertydescriptors\nvar $export = require('./_export');\nvar ownKeys = require('./_own-keys');\nvar toIObject = require('./_to-iobject');\nvar gOPD = require('./_object-gopd');\nvar createProperty = require('./_create-property');\n\n$export($export.S, 'Object', {\n  getOwnPropertyDescriptors: function getOwnPropertyDescriptors(object) {\n    var O = toIObject(object);\n    var getDesc = gOPD.f;\n    var keys = ownKeys(O);\n    var result = {};\n    var i = 0;\n    var key, desc;\n    while (keys.length > i) {\n      desc = getDesc(O, key = keys[i++]);\n      if (desc !== undefined) createProperty(result, key, desc);\n    }\n    return result;\n  }\n});\n","// all object keys, includes non-enumerable and symbols\nvar gOPN = require('./_object-gopn');\nvar gOPS = require('./_object-gops');\nvar anObject = require('./_an-object');\nvar Reflect = require('./_global').Reflect;\nmodule.exports = Reflect && Reflect.ownKeys || function ownKeys(it) {\n  var keys = gOPN.f(anObject(it));\n  var getSymbols = gOPS.f;\n  return getSymbols ? keys.concat(getSymbols(it)) : keys;\n};\n","var $export = require('./_export');\n// 19.1.2.3 / 15.2.3.7 Object.defineProperties(O, Properties)\n$export($export.S + $export.F * !require('./_descriptors'), 'Object', { defineProperties: require('./_object-dps') });\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  phase0: true,\n  altair: true,\n  allForks: true\n};\nObject.defineProperty(exports, \"phase0\", {\n  enumerable: true,\n  get: function () {\n    return _phase.ts;\n  }\n});\nObject.defineProperty(exports, \"altair\", {\n  enumerable: true,\n  get: function () {\n    return _altair.ts;\n  }\n});\nObject.defineProperty(exports, \"allForks\", {\n  enumerable: true,\n  get: function () {\n    return _allForks.ts;\n  }\n});\n\nvar _types = require(\"./primitive/types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n\nvar _phase = require(\"./phase0\");\n\nvar _altair = require(\"./altair\");\n\nvar _allForks = require(\"./allForks\");\n//# sourceMappingURL=types.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _misc = require(\"./misc\");\n\nObject.keys(_misc).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _misc[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _misc[key];\n    }\n  });\n});\n\nvar _operations = require(\"./operations\");\n\nObject.keys(_operations).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _operations[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _operations[key];\n    }\n  });\n});\n\nvar _block = require(\"./block\");\n\nObject.keys(_block).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _block[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _block[key];\n    }\n  });\n});\n\nvar _state = require(\"./state\");\n\nObject.keys(_state).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _state[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _state[key];\n    }\n  });\n});\n\nvar _validator = require(\"./validator\");\n\nObject.keys(_validator).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _validator[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _validator[key];\n    }\n  });\n});\n\nvar _wire = require(\"./wire\");\n\nObject.keys(_wire).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _wire[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _wire[key];\n    }\n  });\n});\n\nvar _api = require(\"./api\");\n\nObject.keys(_api).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _api[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _api[key];\n    }\n  });\n});\n\nvar _types = require(\"../../primitive/types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n//# sourceMappingURL=block.js.map","\"use strict\";\n//# sourceMappingURL=state.js.map","\"use strict\";\n//# sourceMappingURL=wire.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.SlashingProtectionAttestationLowerBound = exports.SlashingProtectionAttestation = exports.SlashingProtectionBlock = exports.Genesis = exports.BeaconBlocksByRootRequest = exports.BeaconBlocksByRangeRequest = exports.Metadata = exports.Ping = exports.Goodbye = exports.Status = exports.SignedAggregateAndProof = exports.AggregateAndProof = exports.CommitteeAssignment = exports.BeaconState = exports.EpochAttestations = exports.SignedBeaconBlock = exports.BeaconBlock = exports.BeaconBlockBody = exports.SignedVoluntaryExit = exports.VoluntaryExit = exports.ProposerSlashing = exports.Deposit = exports.AttesterSlashing = exports.Attestation = exports.SigningData = exports.PendingAttestation = exports.IndexedAttestation = exports.AttestationData = exports.Validator = exports.HistoricalBatch = exports.HistoricalStateRoots = exports.HistoricalBlockRoots = exports.ENRForkID = exports.ForkData = exports.Fork = exports.Eth1DataOrdered = exports.Eth1Data = exports.DepositEvent = exports.DepositDataRootList = exports.DepositData = exports.DepositMessage = exports.CommitteeIndices = exports.CommitteeBits = exports.Checkpoint = exports.SignedBeaconBlockHeader = exports.BeaconBlockHeader = exports.AttestationSubnets = void 0;\n\nvar _lodestarParams = require(\"@chainsafe/lodestar-params\");\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\nvar _primitive = require(\"../primitive\");\n\nvar _lazyVar = require(\"../utils/lazyVar\");\n\nconst {\n  Boolean,\n  Bytes32,\n  Number64,\n  Uint64,\n  Slot,\n  Epoch,\n  CommitteeIndex,\n  ValidatorIndex,\n  Gwei,\n  Root,\n  Version,\n  ForkDigest,\n  BLSPubkey,\n  BLSSignature,\n  Domain\n} = _primitive.ssz; // So the expandedRoots can be referenced, and break the circular dependency\n\nconst typesRef = new _lazyVar.LazyVariable(); // Misc types\n// ==========\n\nconst AttestationSubnets = new _ssz.BitVectorType({\n  length: _lodestarParams.ATTESTATION_SUBNET_COUNT\n});\nexports.AttestationSubnets = AttestationSubnets;\nconst BeaconBlockHeader = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    proposerIndex: ValidatorIndex,\n    parentRoot: Root,\n    stateRoot: Root,\n    bodyRoot: Root\n  }\n});\nexports.BeaconBlockHeader = BeaconBlockHeader;\nconst SignedBeaconBlockHeader = new _ssz.ContainerType({\n  fields: {\n    message: BeaconBlockHeader,\n    signature: BLSSignature\n  }\n});\nexports.SignedBeaconBlockHeader = SignedBeaconBlockHeader;\nconst Checkpoint = new _ssz.ContainerType({\n  fields: {\n    epoch: Epoch,\n    root: Root\n  }\n});\nexports.Checkpoint = Checkpoint;\nconst CommitteeBits = new _ssz.BitListType({\n  limit: _lodestarParams.MAX_VALIDATORS_PER_COMMITTEE\n});\nexports.CommitteeBits = CommitteeBits;\nconst CommitteeIndices = new _ssz.ListType({\n  elementType: ValidatorIndex,\n  limit: _lodestarParams.MAX_VALIDATORS_PER_COMMITTEE\n});\nexports.CommitteeIndices = CommitteeIndices;\nconst DepositMessage = new _ssz.ContainerType({\n  fields: {\n    pubkey: BLSPubkey,\n    withdrawalCredentials: Bytes32,\n    amount: Gwei\n  }\n});\nexports.DepositMessage = DepositMessage;\nconst DepositData = new _ssz.ContainerType({\n  fields: {\n    pubkey: BLSPubkey,\n    withdrawalCredentials: Bytes32,\n    amount: Gwei,\n    signature: BLSSignature\n  }\n});\nexports.DepositData = DepositData;\nconst DepositDataRootList = new _ssz.ListType({\n  elementType: new _ssz.RootType({\n    expandedType: DepositData\n  }),\n  limit: 2 ** _lodestarParams.DEPOSIT_CONTRACT_TREE_DEPTH\n});\nexports.DepositDataRootList = DepositDataRootList;\nconst DepositEvent = new _ssz.ContainerType({\n  fields: {\n    depositData: DepositData,\n    blockNumber: Number64,\n    index: Number64\n  }\n});\nexports.DepositEvent = DepositEvent;\nconst Eth1Data = new _ssz.ContainerType({\n  fields: {\n    depositRoot: Root,\n    depositCount: Number64,\n    blockHash: Bytes32\n  }\n});\nexports.Eth1Data = Eth1Data;\nconst Eth1DataOrdered = new _ssz.ContainerType({\n  fields: {\n    depositRoot: Root,\n    depositCount: Number64,\n    blockHash: Bytes32,\n    blockNumber: Number64\n  }\n});\nexports.Eth1DataOrdered = Eth1DataOrdered;\nconst Fork = new _ssz.ContainerType({\n  fields: {\n    previousVersion: Version,\n    currentVersion: Version,\n    epoch: Epoch\n  }\n});\nexports.Fork = Fork;\nconst ForkData = new _ssz.ContainerType({\n  fields: {\n    currentVersion: Version,\n    genesisValidatorsRoot: Root\n  }\n});\nexports.ForkData = ForkData;\nconst ENRForkID = new _ssz.ContainerType({\n  fields: {\n    forkDigest: ForkDigest,\n    nextForkVersion: Version,\n    nextForkEpoch: Epoch\n  }\n});\nexports.ENRForkID = ENRForkID;\nconst HistoricalBlockRoots = new _ssz.VectorType({\n  elementType: new _ssz.RootType({\n    expandedType: () => typesRef.get().BeaconBlock\n  }),\n  length: _lodestarParams.SLOTS_PER_HISTORICAL_ROOT\n});\nexports.HistoricalBlockRoots = HistoricalBlockRoots;\nconst HistoricalStateRoots = new _ssz.VectorType({\n  elementType: new _ssz.RootType({\n    expandedType: () => typesRef.get().BeaconState\n  }),\n  length: _lodestarParams.SLOTS_PER_HISTORICAL_ROOT\n});\nexports.HistoricalStateRoots = HistoricalStateRoots;\nconst HistoricalBatch = new _ssz.ContainerType({\n  fields: {\n    blockRoots: HistoricalBlockRoots,\n    stateRoots: HistoricalStateRoots\n  }\n});\nexports.HistoricalBatch = HistoricalBatch;\nconst Validator = new _ssz.ContainerType({\n  fields: {\n    pubkey: BLSPubkey,\n    withdrawalCredentials: Bytes32,\n    effectiveBalance: Gwei,\n    slashed: Boolean,\n    activationEligibilityEpoch: Epoch,\n    activationEpoch: Epoch,\n    exitEpoch: Epoch,\n    withdrawableEpoch: Epoch\n  }\n}); // Misc dependants\n\nexports.Validator = Validator;\nconst AttestationData = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    index: CommitteeIndex,\n    beaconBlockRoot: Root,\n    source: Checkpoint,\n    target: Checkpoint\n  }\n});\nexports.AttestationData = AttestationData;\nconst IndexedAttestation = new _ssz.ContainerType({\n  fields: {\n    attestingIndices: CommitteeIndices,\n    data: AttestationData,\n    signature: BLSSignature\n  }\n});\nexports.IndexedAttestation = IndexedAttestation;\nconst PendingAttestation = new _ssz.ContainerType({\n  fields: {\n    aggregationBits: CommitteeBits,\n    data: AttestationData,\n    inclusionDelay: Slot,\n    proposerIndex: ValidatorIndex\n  }\n});\nexports.PendingAttestation = PendingAttestation;\nconst SigningData = new _ssz.ContainerType({\n  fields: {\n    objectRoot: Root,\n    domain: Domain\n  }\n}); // Operations types\n// ================\n\nexports.SigningData = SigningData;\nconst Attestation = new _ssz.ContainerType({\n  fields: {\n    aggregationBits: CommitteeBits,\n    data: AttestationData,\n    signature: BLSSignature\n  }\n});\nexports.Attestation = Attestation;\nconst AttesterSlashing = new _ssz.ContainerType({\n  fields: {\n    attestation1: IndexedAttestation,\n    attestation2: IndexedAttestation\n  }\n});\nexports.AttesterSlashing = AttesterSlashing;\nconst Deposit = new _ssz.ContainerType({\n  fields: {\n    proof: new _ssz.VectorType({\n      elementType: Bytes32,\n      length: _lodestarParams.DEPOSIT_CONTRACT_TREE_DEPTH + 1\n    }),\n    data: DepositData\n  }\n});\nexports.Deposit = Deposit;\nconst ProposerSlashing = new _ssz.ContainerType({\n  fields: {\n    signedHeader1: SignedBeaconBlockHeader,\n    signedHeader2: SignedBeaconBlockHeader\n  }\n});\nexports.ProposerSlashing = ProposerSlashing;\nconst VoluntaryExit = new _ssz.ContainerType({\n  fields: {\n    epoch: Epoch,\n    validatorIndex: ValidatorIndex\n  }\n});\nexports.VoluntaryExit = VoluntaryExit;\nconst SignedVoluntaryExit = new _ssz.ContainerType({\n  fields: {\n    message: VoluntaryExit,\n    signature: BLSSignature\n  }\n}); // Block types\n// ===========\n\nexports.SignedVoluntaryExit = SignedVoluntaryExit;\nconst BeaconBlockBody = new _ssz.ContainerType({\n  fields: {\n    randaoReveal: BLSSignature,\n    eth1Data: Eth1Data,\n    graffiti: Bytes32,\n    proposerSlashings: new _ssz.ListType({\n      elementType: ProposerSlashing,\n      limit: _lodestarParams.MAX_PROPOSER_SLASHINGS\n    }),\n    attesterSlashings: new _ssz.ListType({\n      elementType: AttesterSlashing,\n      limit: _lodestarParams.MAX_ATTESTER_SLASHINGS\n    }),\n    attestations: new _ssz.ListType({\n      elementType: Attestation,\n      limit: _lodestarParams.MAX_ATTESTATIONS\n    }),\n    deposits: new _ssz.ListType({\n      elementType: Deposit,\n      limit: _lodestarParams.MAX_DEPOSITS\n    }),\n    voluntaryExits: new _ssz.ListType({\n      elementType: SignedVoluntaryExit,\n      limit: _lodestarParams.MAX_VOLUNTARY_EXITS\n    })\n  }\n});\nexports.BeaconBlockBody = BeaconBlockBody;\nconst BeaconBlock = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    proposerIndex: ValidatorIndex,\n    parentRoot: new _ssz.RootType({\n      expandedType: () => typesRef.get().BeaconBlock\n    }),\n    stateRoot: new _ssz.RootType({\n      expandedType: () => typesRef.get().BeaconState\n    }),\n    body: BeaconBlockBody\n  }\n});\nexports.BeaconBlock = BeaconBlock;\nconst SignedBeaconBlock = new _ssz.ContainerType({\n  fields: {\n    message: BeaconBlock,\n    signature: BLSSignature\n  }\n}); // State types\n// ===========\n\nexports.SignedBeaconBlock = SignedBeaconBlock;\nconst EpochAttestations = new _ssz.ListType({\n  elementType: PendingAttestation,\n  limit: _lodestarParams.MAX_ATTESTATIONS * _lodestarParams.SLOTS_PER_EPOCH\n});\nexports.EpochAttestations = EpochAttestations;\nconst BeaconState = new _ssz.ContainerType({\n  fields: {\n    // Misc\n    genesisTime: Number64,\n    genesisValidatorsRoot: Root,\n    slot: Slot,\n    fork: Fork,\n    // History\n    latestBlockHeader: BeaconBlockHeader,\n    blockRoots: HistoricalBlockRoots,\n    stateRoots: HistoricalStateRoots,\n    historicalRoots: new _ssz.ListType({\n      elementType: new _ssz.RootType({\n        expandedType: HistoricalBatch\n      }),\n      limit: _lodestarParams.HISTORICAL_ROOTS_LIMIT\n    }),\n    // Eth1\n    eth1Data: Eth1Data,\n    eth1DataVotes: new _ssz.ListType({\n      elementType: Eth1Data,\n      limit: _lodestarParams.EPOCHS_PER_ETH1_VOTING_PERIOD * _lodestarParams.SLOTS_PER_EPOCH\n    }),\n    eth1DepositIndex: Number64,\n    // Registry\n    validators: new _ssz.ListType({\n      elementType: Validator,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    balances: new _ssz.ListType({\n      elementType: Gwei,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    randaoMixes: new _ssz.VectorType({\n      elementType: Bytes32,\n      length: _lodestarParams.EPOCHS_PER_HISTORICAL_VECTOR\n    }),\n    // Slashings\n    slashings: new _ssz.VectorType({\n      elementType: Gwei,\n      length: _lodestarParams.EPOCHS_PER_SLASHINGS_VECTOR\n    }),\n    // Attestations\n    previousEpochAttestations: EpochAttestations,\n    currentEpochAttestations: EpochAttestations,\n    // Finality\n    justificationBits: new _ssz.BitVectorType({\n      length: _lodestarParams.JUSTIFICATION_BITS_LENGTH\n    }),\n    previousJustifiedCheckpoint: Checkpoint,\n    currentJustifiedCheckpoint: Checkpoint,\n    finalizedCheckpoint: Checkpoint\n  }\n}); // Validator types\n// ===============\n\nexports.BeaconState = BeaconState;\nconst CommitteeAssignment = new _ssz.ContainerType({\n  fields: {\n    validators: CommitteeIndices,\n    committeeIndex: CommitteeIndex,\n    slot: Slot\n  }\n});\nexports.CommitteeAssignment = CommitteeAssignment;\nconst AggregateAndProof = new _ssz.ContainerType({\n  fields: {\n    aggregatorIndex: ValidatorIndex,\n    aggregate: Attestation,\n    selectionProof: BLSSignature\n  }\n});\nexports.AggregateAndProof = AggregateAndProof;\nconst SignedAggregateAndProof = new _ssz.ContainerType({\n  fields: {\n    message: AggregateAndProof,\n    signature: BLSSignature\n  }\n}); // ReqResp types\n// =============\n\nexports.SignedAggregateAndProof = SignedAggregateAndProof;\nconst Status = new _ssz.ContainerType({\n  fields: {\n    forkDigest: ForkDigest,\n    finalizedRoot: Root,\n    finalizedEpoch: Epoch,\n    headRoot: Root,\n    headSlot: Slot\n  }\n});\nexports.Status = Status;\nconst Goodbye = Uint64;\nexports.Goodbye = Goodbye;\nconst Ping = Uint64;\nexports.Ping = Ping;\nconst Metadata = new _ssz.ContainerType({\n  fields: {\n    seqNumber: Uint64,\n    attnets: AttestationSubnets\n  }\n});\nexports.Metadata = Metadata;\nconst BeaconBlocksByRangeRequest = new _ssz.ContainerType({\n  fields: {\n    startSlot: Slot,\n    count: Number64,\n    step: Number64\n  }\n});\nexports.BeaconBlocksByRangeRequest = BeaconBlocksByRangeRequest;\nconst BeaconBlocksByRootRequest = new _ssz.ListType({\n  elementType: Root,\n  limit: _lodestarParams.MAX_REQUEST_BLOCKS\n}); // Api types\n// =========\n\nexports.BeaconBlocksByRootRequest = BeaconBlocksByRootRequest;\nconst Genesis = new _ssz.ContainerType({\n  fields: {\n    genesisValidatorsRoot: Root,\n    genesisTime: Uint64,\n    genesisForkVersion: Version\n  }\n}); // Non-speced types\n// ================\n\nexports.Genesis = Genesis;\nconst SlashingProtectionBlock = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    signingRoot: Root\n  }\n});\nexports.SlashingProtectionBlock = SlashingProtectionBlock;\nconst SlashingProtectionAttestation = new _ssz.ContainerType({\n  fields: {\n    sourceEpoch: Epoch,\n    targetEpoch: Epoch,\n    signingRoot: Root\n  }\n});\nexports.SlashingProtectionAttestation = SlashingProtectionAttestation;\nconst SlashingProtectionAttestationLowerBound = new _ssz.ContainerType({\n  fields: {\n    minSourceEpoch: Epoch,\n    minTargetEpoch: Epoch\n  }\n}); // MUST set typesRef here, otherwise expandedType() calls will throw\n\nexports.SlashingProtectionAttestationLowerBound = SlashingProtectionAttestationLowerBound;\ntypesRef.set({\n  BeaconBlock,\n  BeaconState\n});\n//# sourceMappingURL=sszTypes.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.NEXT_SYNC_COMMITTEE_INDEX_FLOORLOG2 = exports.NEXT_SYNC_COMMITTEE_INDEX = exports.FINALIZED_ROOT_INDEX_FLOORLOG2 = exports.FINALIZED_ROOT_INDEX = exports.MIN_SYNC_COMMITTEE_PARTICIPANTS = exports.MAX_REQUEST_BLOCKS = exports.SYNC_COMMITTEE_SUBNET_COUNT = exports.TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE = exports.ATTESTATION_SUBNET_COUNT = exports.EPOCHS_PER_RANDOM_SUBNET_SUBSCRIPTION = exports.RANDOM_SUBNETS_PER_VALIDATOR = exports.TARGET_AGGREGATORS_PER_COMMITTEE = exports.PARTICIPATION_FLAG_WEIGHTS = exports.WEIGHT_DENOMINATOR = exports.PROPOSER_WEIGHT = exports.SYNC_REWARD_WEIGHT = exports.TIMELY_HEAD_WEIGHT = exports.TIMELY_TARGET_WEIGHT = exports.TIMELY_SOURCE_WEIGHT = exports.TIMELY_HEAD_FLAG_INDEX = exports.TIMELY_TARGET_FLAG_INDEX = exports.TIMELY_SOURCE_FLAG_INDEX = exports.DOMAIN_CONTRIBUTION_AND_PROOF = exports.DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF = exports.DOMAIN_SYNC_COMMITTEE = exports.DOMAIN_AGGREGATE_AND_PROOF = exports.DOMAIN_SELECTION_PROOF = exports.DOMAIN_VOLUNTARY_EXIT = exports.DOMAIN_DEPOSIT = exports.DOMAIN_RANDAO = exports.DOMAIN_BEACON_ATTESTER = exports.DOMAIN_BEACON_PROPOSER = exports.ETH1_ADDRESS_WITHDRAWAL_PREFIX = exports.BLS_WITHDRAWAL_PREFIX = exports.JUSTIFICATION_BITS_LENGTH = exports.DEPOSIT_CONTRACT_TREE_DEPTH = exports.BASE_REWARDS_PER_EPOCH = exports.FAR_FUTURE_EPOCH = exports.GENESIS_EPOCH = exports.GENESIS_SLOT = void 0;\n// Misc\nconst GENESIS_SLOT = 0;\nexports.GENESIS_SLOT = GENESIS_SLOT;\nconst GENESIS_EPOCH = 0;\nexports.GENESIS_EPOCH = GENESIS_EPOCH;\nconst FAR_FUTURE_EPOCH = Infinity;\nexports.FAR_FUTURE_EPOCH = FAR_FUTURE_EPOCH;\nconst BASE_REWARDS_PER_EPOCH = 4;\nexports.BASE_REWARDS_PER_EPOCH = BASE_REWARDS_PER_EPOCH;\nconst DEPOSIT_CONTRACT_TREE_DEPTH = 2 ** 5; // 32\n\nexports.DEPOSIT_CONTRACT_TREE_DEPTH = DEPOSIT_CONTRACT_TREE_DEPTH;\nconst JUSTIFICATION_BITS_LENGTH = 4; // Withdrawal prefixes\n\nexports.JUSTIFICATION_BITS_LENGTH = JUSTIFICATION_BITS_LENGTH;\nconst BLS_WITHDRAWAL_PREFIX = Uint8Array.from([0]);\nexports.BLS_WITHDRAWAL_PREFIX = BLS_WITHDRAWAL_PREFIX;\nconst ETH1_ADDRESS_WITHDRAWAL_PREFIX = Uint8Array.from([0]); // Domain types\n\nexports.ETH1_ADDRESS_WITHDRAWAL_PREFIX = ETH1_ADDRESS_WITHDRAWAL_PREFIX;\nconst DOMAIN_BEACON_PROPOSER = Uint8Array.from([0, 0, 0, 0]);\nexports.DOMAIN_BEACON_PROPOSER = DOMAIN_BEACON_PROPOSER;\nconst DOMAIN_BEACON_ATTESTER = Uint8Array.from([1, 0, 0, 0]);\nexports.DOMAIN_BEACON_ATTESTER = DOMAIN_BEACON_ATTESTER;\nconst DOMAIN_RANDAO = Uint8Array.from([2, 0, 0, 0]);\nexports.DOMAIN_RANDAO = DOMAIN_RANDAO;\nconst DOMAIN_DEPOSIT = Uint8Array.from([3, 0, 0, 0]);\nexports.DOMAIN_DEPOSIT = DOMAIN_DEPOSIT;\nconst DOMAIN_VOLUNTARY_EXIT = Uint8Array.from([4, 0, 0, 0]);\nexports.DOMAIN_VOLUNTARY_EXIT = DOMAIN_VOLUNTARY_EXIT;\nconst DOMAIN_SELECTION_PROOF = Uint8Array.from([5, 0, 0, 0]);\nexports.DOMAIN_SELECTION_PROOF = DOMAIN_SELECTION_PROOF;\nconst DOMAIN_AGGREGATE_AND_PROOF = Uint8Array.from([6, 0, 0, 0]);\nexports.DOMAIN_AGGREGATE_AND_PROOF = DOMAIN_AGGREGATE_AND_PROOF;\nconst DOMAIN_SYNC_COMMITTEE = Uint8Array.from([7, 0, 0, 0]);\nexports.DOMAIN_SYNC_COMMITTEE = DOMAIN_SYNC_COMMITTEE;\nconst DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF = Uint8Array.from([8, 0, 0, 0]);\nexports.DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF = DOMAIN_SYNC_COMMITTEE_SELECTION_PROOF;\nconst DOMAIN_CONTRIBUTION_AND_PROOF = Uint8Array.from([9, 0, 0, 0]); // Participation flag indices\n\nexports.DOMAIN_CONTRIBUTION_AND_PROOF = DOMAIN_CONTRIBUTION_AND_PROOF;\nconst TIMELY_SOURCE_FLAG_INDEX = 0;\nexports.TIMELY_SOURCE_FLAG_INDEX = TIMELY_SOURCE_FLAG_INDEX;\nconst TIMELY_TARGET_FLAG_INDEX = 1;\nexports.TIMELY_TARGET_FLAG_INDEX = TIMELY_TARGET_FLAG_INDEX;\nconst TIMELY_HEAD_FLAG_INDEX = 2; // Incentivization weights\n\nexports.TIMELY_HEAD_FLAG_INDEX = TIMELY_HEAD_FLAG_INDEX;\nconst TIMELY_SOURCE_WEIGHT = BigInt(14);\nexports.TIMELY_SOURCE_WEIGHT = TIMELY_SOURCE_WEIGHT;\nconst TIMELY_TARGET_WEIGHT = BigInt(26);\nexports.TIMELY_TARGET_WEIGHT = TIMELY_TARGET_WEIGHT;\nconst TIMELY_HEAD_WEIGHT = BigInt(14);\nexports.TIMELY_HEAD_WEIGHT = TIMELY_HEAD_WEIGHT;\nconst SYNC_REWARD_WEIGHT = BigInt(2);\nexports.SYNC_REWARD_WEIGHT = SYNC_REWARD_WEIGHT;\nconst PROPOSER_WEIGHT = BigInt(8);\nexports.PROPOSER_WEIGHT = PROPOSER_WEIGHT;\nconst WEIGHT_DENOMINATOR = BigInt(64); // altair misc\n\nexports.WEIGHT_DENOMINATOR = WEIGHT_DENOMINATOR;\nconst PARTICIPATION_FLAG_WEIGHTS = [TIMELY_SOURCE_WEIGHT, TIMELY_TARGET_WEIGHT, TIMELY_HEAD_WEIGHT]; // phase0 validator\n\nexports.PARTICIPATION_FLAG_WEIGHTS = PARTICIPATION_FLAG_WEIGHTS;\nconst TARGET_AGGREGATORS_PER_COMMITTEE = 16;\nexports.TARGET_AGGREGATORS_PER_COMMITTEE = TARGET_AGGREGATORS_PER_COMMITTEE;\nconst RANDOM_SUBNETS_PER_VALIDATOR = 1;\nexports.RANDOM_SUBNETS_PER_VALIDATOR = RANDOM_SUBNETS_PER_VALIDATOR;\nconst EPOCHS_PER_RANDOM_SUBNET_SUBSCRIPTION = 256;\n/** Rationale: https://github.com/ethereum/eth2.0-specs/blob/dev/specs/phase0/p2p-interface.md#why-are-there-attestation_subnet_count-attestation-subnets */\n\nexports.EPOCHS_PER_RANDOM_SUBNET_SUBSCRIPTION = EPOCHS_PER_RANDOM_SUBNET_SUBSCRIPTION;\nconst ATTESTATION_SUBNET_COUNT = 64; // altair validator\n\nexports.ATTESTATION_SUBNET_COUNT = ATTESTATION_SUBNET_COUNT;\nconst TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE = 4;\nexports.TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE = TARGET_AGGREGATORS_PER_SYNC_SUBCOMMITTEE;\nconst SYNC_COMMITTEE_SUBNET_COUNT = 4;\nexports.SYNC_COMMITTEE_SUBNET_COUNT = SYNC_COMMITTEE_SUBNET_COUNT;\nconst MAX_REQUEST_BLOCKS = 2 ** 10; // 1024\n//\n\nexports.MAX_REQUEST_BLOCKS = MAX_REQUEST_BLOCKS;\nconst MIN_SYNC_COMMITTEE_PARTICIPANTS = 1; // Lightclient pre-computed\n\n/**\n * ```ts\n * config.types.altair.BeaconState.getPathGindex([\"finalizedCheckpoint\", \"root\"])\n * ```\n */\n\nexports.MIN_SYNC_COMMITTEE_PARTICIPANTS = MIN_SYNC_COMMITTEE_PARTICIPANTS;\nconst FINALIZED_ROOT_INDEX = 105;\n/**\n * ```ts\n * Math.floor(Math.log2(FINALIZED_ROOT_INDEX))\n * ```\n */\n\nexports.FINALIZED_ROOT_INDEX = FINALIZED_ROOT_INDEX;\nconst FINALIZED_ROOT_INDEX_FLOORLOG2 = 6;\n/**\n * ```ts\n * config.types.altair.BeaconState.getPathGindex([\"nextSyncCommittee\"])\n * ```\n */\n\nexports.FINALIZED_ROOT_INDEX_FLOORLOG2 = FINALIZED_ROOT_INDEX_FLOORLOG2;\nconst NEXT_SYNC_COMMITTEE_INDEX = 55;\n/**\n * ```ts\n * Math.floor(Math.log2(NEXT_SYNC_COMMITTEE_INDEX))\n * ```\n */\n\nexports.NEXT_SYNC_COMMITTEE_INDEX = NEXT_SYNC_COMMITTEE_INDEX;\nconst NEXT_SYNC_COMMITTEE_INDEX_FLOORLOG2 = 5;\nexports.NEXT_SYNC_COMMITTEE_INDEX_FLOORLOG2 = NEXT_SYNC_COMMITTEE_INDEX_FLOORLOG2;\n//# sourceMappingURL=constants.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PresetName = void 0;\nlet PresetName;\nexports.PresetName = PresetName;\n\n(function (PresetName) {\n  PresetName[\"mainnet\"] = \"mainnet\";\n  PresetName[\"minimal\"] = \"minimal\";\n})(PresetName || (exports.PresetName = PresetName = {}));\n//# sourceMappingURL=presetName.js.map","\"use strict\";\n//# sourceMappingURL=interface.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.BeaconPreset = void 0;\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\nvar _phase = require(\"./phase0\");\n\nvar _altair = require(\"./altair\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst BeaconPreset = new _ssz.ContainerType({\n  fields: _objectSpread(_objectSpread({}, _phase.Phase0Preset.fields), _altair.AltairPreset.fields)\n});\nexports.BeaconPreset = BeaconPreset;\n//# sourceMappingURL=ssz.js.map","\"use strict\";\n//# sourceMappingURL=interface.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.booleanType = exports.number32Type = exports.byteType = void 0;\n\nvar _uint = require(\"./uint\");\n\nvar _boolean = require(\"./boolean\");\n\nconst byteType = new _uint.NumberUintType({\n  byteLength: 1\n});\nexports.byteType = byteType;\nconst number32Type = new _uint.NumberUintType({\n  byteLength: 4\n});\nexports.number32Type = number32Type;\nconst booleanType = new _boolean.BooleanType();\nexports.booleanType = booleanType;\n//# sourceMappingURL=wellKnown.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _abstract = require(\"./abstract\");\n\nObject.keys(_abstract).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _abstract[key];\n    }\n  });\n});\n\nvar _array = require(\"./array\");\n\nObject.keys(_array).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _array[key];\n    }\n  });\n});\n\nvar _vector = require(\"./vector\");\n\nObject.keys(_vector).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _vector[key];\n    }\n  });\n});\n\nvar _list = require(\"./list\");\n\nObject.keys(_list).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _list[key];\n    }\n  });\n});\n\nvar _bitVector = require(\"./bitVector\");\n\nObject.keys(_bitVector).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _bitVector[key];\n    }\n  });\n});\n\nvar _bitList = require(\"./bitList\");\n\nObject.keys(_bitList).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _bitList[key];\n    }\n  });\n});\n\nvar _byteVector = require(\"./byteVector\");\n\nObject.keys(_byteVector).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _byteVector[key];\n    }\n  });\n});\n\nvar _root = require(\"./root\");\n\nObject.keys(_root).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _root[key];\n    }\n  });\n});\n\nvar _container = require(\"./container\");\n\nObject.keys(_container).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function get() {\n      return _container[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n//# sourceMappingURL=interface.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBackedValue = isBackedValue;\n\nvar _tree = require(\"./tree\");\n\nfunction isBackedValue(value) {\n  return (0, _tree.isTreeBacked)(value);\n}\n//# sourceMappingURL=backedValue.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.readonlyValues = readonlyValues;\nexports.readonlyEntries = readonlyEntries;\n\nvar _tree = require(\"./tree\");\n\nfunction readonlyValues(obj) {\n  if ((0, _tree.isTreeBacked)(obj) && obj.readonlyValues) {\n    return obj.readonlyValues();\n  } else {\n    return Object.values(obj);\n  }\n}\n\nfunction readonlyEntries(obj) {\n  if ((0, _tree.isTreeBacked)(obj) && obj.readonlyEntries) {\n    return obj.readonlyEntries();\n  } else {\n    return Object.entries(obj);\n  }\n}\n//# sourceMappingURL=readonlyIterate.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.newInstance = newInstance;\n\nvar _loader = _interopRequireDefault(require(\"@assemblyscript/loader\"));\n\nvar _buffer = require(\"buffer\");\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\n/* babel-plugin-inline-binary-import '../build/optimized.wasm' */\nconst wasmCode = \"\\0asm\\x01\\0\\0\\0\\x01\\x1F\\x06`\\x02\\x7F\\x7F\\0`\\0\\0`\\x01\\x7F\\0`\\x01\\x7F\\x01\\x7F`\\x03\\x7F\\x7F\\x7F\\0`\\x04\\x7F\\x7F\\x7F\\x7F\\0\\x02\\r\\x01\\x03env\\x05abort\\0\\x05\\x03\\x0F\\x0E\\x02\\x03\\0\\x03\\x01\\x01\\x04\\0\\0\\x03\\x02\\x02\\0\\x01\\x05\\x03\\x01\\0\\x01\\x06\\xAC\\x01\\\"\\x7F\\0A\\x80\\x04\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x7F\\x01A\\0\\x0B\\x07V\\t\\x06memory\\x02\\0\\fINPUT_LENGTH\\x03\\0\\x05input\\x03\\x1C\\x06output\\x03\\x1E\\x04init\\0\\x06\\x06update\\0\\t\\x05final\\0\\x0B\\x06digest\\0\\f\\bdigest64\\0\\r\\b\\x01\\x0E\\n\\xD2\\f\\x0EF\\x01\\x02\\x7F \\0?\\0\\\"\\x02A\\x10t\\\"\\x01K\\x04@ \\x02 \\0 \\x01kA\\xFF\\xFF\\x03jA\\x80\\x80|qA\\x10v\\\"\\x01 \\x02 \\x01J\\x1B@\\0A\\0H\\x04@ \\x01@\\0A\\0H\\x04@\\0\\x0B\\x0B\\x0B \\0$\\x17\\x0BR\\x01\\x03\\x7F \\0A\\xF0\\xFF\\xFF\\xFF\\x03K\\x04@\\0\\x0B#\\x17A\\x10j\\\"\\x02 \\0A\\x0FjApq\\\"\\x01A\\x10 \\x01A\\x10K\\x1B\\\"\\x03j\\x10\\x01 \\x02A\\x10k\\\"\\x01 \\x036\\x02\\0 \\x01A\\x016\\x02\\x04 \\x01A\\x006\\x02\\b \\x01 \\x006\\x02\\f \\x02\\x0B%\\x01\\x01\\x7F\\x03@ \\x01\\x04@ \\0\\\"\\x02A\\x01j!\\0 \\x02A\\0:\\0\\0 \\x01A\\x01k!\\x01\\f\\x01\\x0B\\x0B\\x0B)\\x01\\x01\\x7F \\0A\\xF0\\xFF\\xFF\\xFF\\x03K\\x04@A\\x80\\x05A\\xB0\\x05A6A*\\x10\\0\\0\\x0B \\0\\x10\\x02\\\"\\x01 \\0\\x10\\x03 \\x01\\x0BG\\0A\\xB4\\x02(\\x02\\0$\\x01A\\xE4\\x04(\\x02\\0$\\x02A\\xE0\\x05$\\x16A\\xE0\\x05$\\x17A\\xC0\\0\\x10\\x04$\\x18#\\x18$\\x19A\\x80\\x02\\x10\\x04$\\x1A#\\x1A$\\x1BA\\x80\\x04\\x10\\x04$\\x1C#\\x1C$\\x1DA \\x10\\x04$\\x1E#\\x1E$\\x1F\\x0BJ\\0A\\xE7\\xCC\\xA7\\xD0\\x06$\\x03A\\x85\\xDD\\x9E\\xDB{$\\x04A\\xF2\\xE6\\xBB\\xE3\\x03$\\x05A\\xBA\\xEA\\xBF\\xAAz$\\x06A\\xFF\\xA4\\xB9\\x88\\x05$\\x07A\\x8C\\xD1\\x95\\xD8y$\\bA\\xAB\\xB3\\x8F\\xFC\\x01$\\tA\\x99\\x9A\\x83\\xDF\\x05$\\nA\\0$ A\\0$!\\x0Bg\\x01\\x02\\x7F\\x02@ \\x02!\\x03 \\0 \\x01F\\r\\0 \\0 \\x01I\\x04@\\x03@ \\x03\\x04@ \\0\\\"\\x02A\\x01j!\\0 \\x01\\\"\\x04A\\x01j!\\x01 \\x02 \\x04-\\0\\0:\\0\\0 \\x03A\\x01k!\\x03\\f\\x01\\x0B\\x0B\\x05\\x03@ \\x03\\x04@ \\x03A\\x01k\\\"\\x03 \\0j \\x01 \\x03j-\\0\\0:\\0\\0\\f\\x01\\x0B\\x0B\\x0B\\x0B\\x0B\\xEC\\x03\\x01\\x01\\x7F#\\x03$\\x0B#\\x04$\\f#\\x05$\\r#\\x06$\\x0E#\\x07$\\x0F#\\b$\\x10#\\t$\\x11#\\n$\\x12 \\x01\\x04@A\\0$\\x13\\x03@#\\x13A\\x10I\\x04@ \\0#\\x13A\\x02tj \\x01#\\x13A\\x02t\\\"\\x02j-\\0\\0A\\x18t \\x01 \\x02A\\x01jj-\\0\\0A\\x10tr \\x01 \\x02A\\x02jj-\\0\\0A\\btr \\x01 \\x02A\\x03jj-\\0\\0r6\\x02\\0#\\x13A\\x01j$\\x13\\f\\x01\\x0B\\x0BA\\x10$\\x13\\x03@#\\x13A\\xC0\\0I\\x04@ \\0#\\x13A\\x02tj \\0#\\x13A\\x10kA\\x02tj(\\x02\\0 \\0#\\x13A\\x07kA\\x02tj(\\x02\\0 \\0#\\x13A\\x02kA\\x02tj(\\x02\\0\\\"\\x01A\\x11x \\x01A\\x13xs \\x01A\\nvsj \\0#\\x13A\\x0FkA\\x02tj(\\x02\\0\\\"\\x01A\\x07x \\x01A\\x12xs \\x01A\\x03vsjj6\\x02\\0#\\x13A\\x01j$\\x13\\f\\x01\\x0B\\x0B\\x0BA\\0$\\x13\\x03@#\\x13A\\xC0\\0I\\x04@ \\0#\\x13A\\x02tj(\\x02\\0#\\x01#\\x13A\\x02tj(\\x02\\0#\\x12#\\x0F\\\"\\x01A\\x06x \\x01A\\x0Bxs \\x01A\\x19xsj#\\x0F\\\"\\x01#\\x10q#\\x11 \\x01A\\x7Fsqsjjj$\\x14#\\x0B\\\"\\x01A\\x02x \\x01A\\rxs \\x01A\\x16xs#\\x0B\\\"\\x01#\\f\\\"\\x02q \\x01#\\r\\\"\\x01qs \\x01 \\x02qsj$\\x15#\\x11$\\x12#\\x10$\\x11#\\x0F$\\x10#\\x0E#\\x14j$\\x0F#\\r$\\x0E#\\f$\\r#\\x0B$\\f#\\x14#\\x15j$\\x0B#\\x13A\\x01j$\\x13\\f\\x01\\x0B\\x0B#\\x03#\\x0Bj$\\x03#\\x04#\\fj$\\x04#\\x05#\\rj$\\x05#\\x06#\\x0Ej$\\x06#\\x07#\\x0Fj$\\x07#\\b#\\x10j$\\b#\\t#\\x11j$\\t#\\n#\\x12j$\\n\\x0B\\xB1\\x01\\x01\\x02\\x7F \\x01#!j$!# \\x04@A\\xC0\\0# k \\x01L\\x04@#\\x19# j \\0A\\xC0\\0# k\\x10\\x07# A\\xC0\\0# kj$ A\\xC0\\0# k!\\x02 \\x01A\\xC0\\0# kk!\\x01#\\x1B#\\x19\\x10\\bA\\0$ \\x05#\\x19# j \\0 \\x01\\x10\\x07 \\x01# j$ \\x0F\\x0B\\x0B\\x03@ \\x03 \\x01A\\xC0\\0mH\\x04@#\\x1B \\0 \\x02j\\x10\\b \\x03A\\x01j!\\x03 \\x02A@k!\\x02\\f\\x01\\x0B\\x0B \\x01A?q\\x04@#\\x19# j \\0 \\x02j \\x01A?q\\\"\\0\\x10\\x07 \\0# j$ \\x0B\\x0B\\x19\\0 \\0A\\x80\\xFE\\x83xqA\\bw \\0A\\xFF\\x81\\xFC\\x07qA\\bxr\\x0B\\xAD\\x02\\x01\\x02\\x7F#!A?qA?H\\x04@#\\x19# jA\\x80\\x01:\\0\\0# A\\x01j$ \\x0B#!A?qA8N\\x04@#\\x19# j\\\"\\x01A\\xC0\\0# kj!\\x02\\x03@ \\x01 \\x02I\\x04@ \\x01A\\0:\\0\\0 \\x01A\\x01j!\\x01\\f\\x01\\x0B\\x0B#\\x1B#\\x19\\x10\\bA\\0$ \\x0B#!A?qA?N\\x04@#\\x19# jA\\x80\\x01:\\0\\0# A\\x01j$ \\x0B#\\x19# j\\\"\\x01A8# kj!\\x02\\x03@ \\x01 \\x02I\\x04@ \\x01A\\0:\\0\\0 \\x01A\\x01j!\\x01\\f\\x01\\x0B\\x0B#\\x19A8j#!A\\x80\\x80\\x80\\x80\\x02m\\x10\\n6\\x02\\0#\\x19A<j#!A\\x03t\\x10\\n6\\x02\\0#\\x1B#\\x19\\x10\\b \\0#\\x03\\x10\\n6\\x02\\0 \\0A\\x04j#\\x04\\x10\\n6\\x02\\0 \\0A\\bj#\\x05\\x10\\n6\\x02\\0 \\0A\\fj#\\x06\\x10\\n6\\x02\\0 \\0A\\x10j#\\x07\\x10\\n6\\x02\\0 \\0A\\x14j#\\b\\x10\\n6\\x02\\0 \\0A\\x18j#\\t\\x10\\n6\\x02\\0 \\0A\\x1Cj#\\n\\x10\\n6\\x02\\0\\x0B\\x0E\\0\\x10\\x06#\\x1D \\0\\x10\\t#\\x1F\\x10\\x0B\\x0Bm\\0\\x10\\x06#\\x1B \\0\\x10\\b#\\x02A\\0\\x10\\b \\x01#\\x03\\x10\\n6\\x02\\0 \\x01A\\x04j#\\x04\\x10\\n6\\x02\\0 \\x01A\\bj#\\x05\\x10\\n6\\x02\\0 \\x01A\\fj#\\x06\\x10\\n6\\x02\\0 \\x01A\\x10j#\\x07\\x10\\n6\\x02\\0 \\x01A\\x14j#\\b\\x10\\n6\\x02\\0 \\x01A\\x18j#\\t\\x10\\n6\\x02\\0 \\x01A\\x1Cj#\\n\\x10\\n6\\x02\\0\\x0B\\x04\\0\\x10\\x05\\x0B\\x0B\\xAB\\x05\\x07\\0A\\x11\\x0B\\x8F\\x02\\x01\\0\\0\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\x01\\0\\0\\x98/\\x8AB\\x91D7q\\xCF\\xFB\\xC0\\xB5\\xA5\\xDB\\xB5\\xE9[\\xC2V9\\xF1\\x11\\xF1Y\\xA4\\x82?\\x92\\xD5^\\x1C\\xAB\\x98\\xAA\\x07\\xD8\\x01[\\x83\\x12\\xBE\\x851$\\xC3}\\fUt]\\xBEr\\xFE\\xB1\\xDE\\x80\\xA7\\x06\\xDC\\x9Bt\\xF1\\x9B\\xC1\\xC1i\\x9B\\xE4\\x86G\\xBE\\xEF\\xC6\\x9D\\xC1\\x0F\\xCC\\xA1\\f$o,\\xE9-\\xAA\\x84tJ\\xDC\\xA9\\xB0\\\\\\xDA\\x88\\xF9vRQ>\\x98m\\xC61\\xA8\\xC8'\\x03\\xB0\\xC7\\x7FY\\xBF\\xF3\\x0B\\xE0\\xC6G\\x91\\xA7\\xD5Qc\\xCA\\x06g))\\x14\\x85\\n\\xB7'8!\\x1B.\\xFCm,M\\x13\\r8STs\\ne\\xBB\\njv.\\xC9\\xC2\\x81\\x85,r\\x92\\xA1\\xE8\\xBF\\xA2Kf\\x1A\\xA8p\\x8BK\\xC2\\xA3Ql\\xC7\\x19\\xE8\\x92\\xD1$\\x06\\x99\\xD6\\x855\\x0E\\xF4p\\xA0j\\x10\\x16\\xC1\\xA4\\x19\\bl7\\x1ELwH'\\xB5\\xBC\\xB04\\xB3\\f\\x1C9J\\xAA\\xD8NO\\xCA\\x9C[\\xF3o.h\\xEE\\x82\\x8Ftoc\\xA5x\\x14x\\xC8\\x84\\b\\x02\\xC7\\x8C\\xFA\\xFF\\xBE\\x90\\xEBlP\\xA4\\xF7\\xA3\\xF9\\xBE\\xF2xq\\xC6\\0A\\xA0\\x02\\x0B\\x1D\\x10\\0\\0\\0\\x01\\0\\0\\0\\x03\\0\\0\\0\\x10\\0\\0\\0 \\0\\0\\0 \\0\\0\\0\\0\\x01\\0\\0@\\0A\\xC1\\x02\\x0B\\x13\\x01\\0\\0\\x01\\0\\0\\0\\0\\0\\0\\0\\0\\x01\\0\\0\\0\\0\\0\\x80\\0A\\x8D\\x03\\x0B\\xC3\\x01\\x02\\0\\0\\0\\0\\0\\x80\\0\\0@\\x01\\0P \\0\\x88P\\0\\0\\0\\b\\0\\\"\\x14\\0U\\\"B\\x97\\b\\x05 \\0\\0\\xA0\\0\\0\\x88Z\\0\\x94\\\\\\0\\x9D\\xD4\\x16\\0\\0\\x1F\\x80\\xFA\\xD0%2\\xD3YYg\\x11\\xDA\\xBF\\xE6\\xF6I\\x15\\f\\xB3P\\xB0\\xB2\\b'L|\\x9D\\x93\\xA3\\xE2\\f\\xEA\\xE1\\xE6\\x885C+\\xA5Io\\xA1go\\x012\\xD7\\x91.\\xEBN\\xE5U\\xBF]5#\\xEE\\x8E\\xC2^\\xBC\\xE2\\x94C?\\xA8\\xF7x\\xADE\\xCD\\xD0\\xF36\\xE8\\x05\\x9C\\xD9\\xC7\\x1DQ\\xB0\\xC4z\\xBCi[7\\x11\\xBD\\xE5q\\xBA\\xE3\\xF2\\x9F ;\\x17\\xEE\\xFE\\x18\\xE7\\xD9Z\\xE2FP7\\x13\\x9D\\b\\x15\\x05\\x04\\x0F\\rONH'&\\xD2(\\x0114\\xB4h\\xC6\\xCCA\\bB\\xB8\\x11\\xD3bq\\xA7\\x9B\\xE5\\x84\\xA4\\xA7\\x85\\0A\\xD0\\x04\\x0B\\x1D\\x10\\0\\0\\0\\x01\\0\\0\\0\\x03\\0\\0\\0\\x10\\0\\0\\0P\\x01\\0\\0P\\x01\\0\\0\\0\\x01\\0\\0@\\0A\\xF0\\x04\\x0B+\\x1C\\0\\0\\0\\x01\\0\\0\\0\\x01\\0\\0\\0\\x1C\\0\\0\\0I\\0n\\0v\\0a\\0l\\0i\\0d\\0 \\0l\\0e\\0n\\0g\\0t\\0h\\0A\\xA0\\x05\\x0B5&\\0\\0\\0\\x01\\0\\0\\0\\x01\\0\\0\\0&\\0\\0\\0~\\0l\\0i\\0b\\0/\\0a\\0r\\0r\\0a\\0y\\0b\\0u\\0f\\0f\\0e\\0r\\0.\\0t\\0s\";\n\nconst _module = new WebAssembly.Module(_buffer.Buffer.from(wasmCode, 'binary'));\n\nfunction newInstance() {\n  return _loader.default.instantiateSync(_module);\n}","\"use strict\";\n\n// Runtime header offsets\nconst ID_OFFSET = -8;\nconst SIZE_OFFSET = -4;\n\n// Runtime ids\nconst ARRAYBUFFER_ID = 0;\nconst STRING_ID = 1;\nconst ARRAYBUFFERVIEW_ID = 2;\n\n// Runtime type information\nconst ARRAYBUFFERVIEW = 1 << 0;\nconst ARRAY = 1 << 1;\nconst SET = 1 << 2;\nconst MAP = 1 << 3;\nconst VAL_ALIGN_OFFSET = 5;\nconst VAL_ALIGN = 1 << VAL_ALIGN_OFFSET;\nconst VAL_SIGNED = 1 << 10;\nconst VAL_FLOAT = 1 << 11;\nconst VAL_NULLABLE = 1 << 12;\nconst VAL_MANAGED = 1 << 13;\nconst KEY_ALIGN_OFFSET = 14;\nconst KEY_ALIGN = 1 << KEY_ALIGN_OFFSET;\nconst KEY_SIGNED = 1 << 19;\nconst KEY_FLOAT = 1 << 20;\nconst KEY_NULLABLE = 1 << 21;\nconst KEY_MANAGED = 1 << 22;\n\n// Array(BufferView) layout\nconst ARRAYBUFFERVIEW_BUFFER_OFFSET = 0;\nconst ARRAYBUFFERVIEW_DATASTART_OFFSET = 4;\nconst ARRAYBUFFERVIEW_DATALENGTH_OFFSET = 8;\nconst ARRAYBUFFERVIEW_SIZE = 12;\nconst ARRAY_LENGTH_OFFSET = 12;\nconst ARRAY_SIZE = 16;\n\nconst BIGINT = typeof BigUint64Array !== \"undefined\";\nconst THIS = Symbol();\nconst CHUNKSIZE = 1024;\n\n/** Gets a string from an U32 and an U16 view on a memory. */\nfunction getStringImpl(buffer, ptr) {\n  const U32 = new Uint32Array(buffer);\n  const U16 = new Uint16Array(buffer);\n  var length = U32[(ptr + SIZE_OFFSET) >>> 2] >>> 1;\n  var offset = ptr >>> 1;\n  if (length <= CHUNKSIZE) return String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n  const parts = [];\n  do {\n    const last = U16[offset + CHUNKSIZE - 1];\n    const size = last >= 0xD800 && last < 0xDC00 ? CHUNKSIZE - 1 : CHUNKSIZE;\n    parts.push(String.fromCharCode.apply(String, U16.subarray(offset, offset += size)));\n    length -= size;\n  } while (length > CHUNKSIZE);\n  return parts.join(\"\") + String.fromCharCode.apply(String, U16.subarray(offset, offset + length));\n}\n\n/** Prepares the base module prior to instantiation. */\nfunction preInstantiate(imports) {\n  const baseModule = {};\n\n  function getString(memory, ptr) {\n    if (!memory) return \"<yet unknown>\";\n    return getStringImpl(memory.buffer, ptr);\n  }\n\n  // add common imports used by stdlib for convenience\n  const env = (imports.env = imports.env || {});\n  env.abort = env.abort || function abort(mesg, file, line, colm) {\n    const memory = baseModule.memory || env.memory; // prefer exported, otherwise try imported\n    throw Error(\"abort: \" + getString(memory, mesg) + \" at \" + getString(memory, file) + \":\" + line + \":\" + colm);\n  }\n  env.trace = env.trace || function trace(mesg, n) {\n    const memory = baseModule.memory || env.memory;\n    console.log(\"trace: \" + getString(memory, mesg) + (n ? \" \" : \"\") + Array.prototype.slice.call(arguments, 2, 2 + n).join(\", \"));\n  }\n  imports.Math = imports.Math || Math;\n  imports.Date = imports.Date || Date;\n\n  return baseModule;\n}\n\n/** Prepares the final module once instantiation is complete. */\nfunction postInstantiate(baseModule, instance) {\n  const rawExports = instance.exports;\n  const memory = rawExports.memory;\n  const table = rawExports.table;\n  const alloc = rawExports[\"__alloc\"];\n  const retain = rawExports[\"__retain\"];\n  const rttiBase = rawExports[\"__rtti_base\"] || ~0; // oob if not present\n\n  /** Gets the runtime type info for the given id. */\n  function getInfo(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2];\n  }\n\n  /** Gets the runtime base id for the given id. */\n  function getBase(id) {\n    const U32 = new Uint32Array(memory.buffer);\n    const count = U32[rttiBase >>> 2];\n    if ((id >>>= 0) >= count) throw Error(\"invalid id: \" + id);\n    return U32[(rttiBase + 4 >>> 2) + id * 2 + 1];\n  }\n\n  /** Gets the runtime alignment of a collection's values. */\n  function getValueAlign(info) {\n    return 31 - Math.clz32((info >>> VAL_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Gets the runtime alignment of a collection's keys. */\n  function getKeyAlign(info) {\n    return 31 - Math.clz32((info >>> KEY_ALIGN_OFFSET) & 31); // -1 if none\n  }\n\n  /** Allocates a new string in the module's memory and returns its retained pointer. */\n  function __allocString(str) {\n    const length = str.length;\n    const ptr = alloc(length << 1, STRING_ID);\n    const U16 = new Uint16Array(memory.buffer);\n    for (var i = 0, p = ptr >>> 1; i < length; ++i) U16[p + i] = str.charCodeAt(i);\n    return ptr;\n  }\n\n  baseModule.__allocString = __allocString;\n\n  /** Reads a string from the module's memory by its pointer. */\n  function __getString(ptr) {\n    const buffer = memory.buffer;\n    const id = new Uint32Array(buffer)[ptr + ID_OFFSET >>> 2];\n    if (id !== STRING_ID) throw Error(\"not a string: \" + ptr);\n    return getStringImpl(buffer, ptr);\n  }\n\n  baseModule.__getString = __getString;\n\n  /** Gets the view matching the specified alignment, signedness and floatness. */\n  function getView(alignLog2, signed, float) {\n    const buffer = memory.buffer;\n    if (float) {\n      switch (alignLog2) {\n        case 2: return new Float32Array(buffer);\n        case 3: return new Float64Array(buffer);\n      }\n    } else {\n      switch (alignLog2) {\n        case 0: return new (signed ? Int8Array : Uint8Array)(buffer);\n        case 1: return new (signed ? Int16Array : Uint16Array)(buffer);\n        case 2: return new (signed ? Int32Array : Uint32Array)(buffer);\n        case 3: return new (signed ? BigInt64Array : BigUint64Array)(buffer);\n      }\n    }\n    throw Error(\"unsupported align: \" + alignLog2);\n  }\n\n  /** Allocates a new array in the module's memory and returns its retained pointer. */\n  function __allocArray(id, values) {\n    const info = getInfo(id);\n    if (!(info & (ARRAYBUFFERVIEW | ARRAY))) throw Error(\"not an array: \" + id + \" @ \" + info);\n    const align = getValueAlign(info);\n    const length = values.length;\n    const buf = alloc(length << align, ARRAYBUFFER_ID);\n    const arr = alloc(info & ARRAY ? ARRAY_SIZE : ARRAYBUFFERVIEW_SIZE, id);\n    const U32 = new Uint32Array(memory.buffer);\n    U32[arr + ARRAYBUFFERVIEW_BUFFER_OFFSET >>> 2] = retain(buf);\n    U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2] = buf;\n    U32[arr + ARRAYBUFFERVIEW_DATALENGTH_OFFSET >>> 2] = length << align;\n    if (info & ARRAY) U32[arr + ARRAY_LENGTH_OFFSET >>> 2] = length;\n    const view = getView(align, info & VAL_SIGNED, info & VAL_FLOAT);\n    if (info & VAL_MANAGED) {\n      for (let i = 0; i < length; ++i) view[(buf >>> align) + i] = retain(values[i]);\n    } else {\n      view.set(values, buf >>> align);\n    }\n    return arr;\n  }\n\n  baseModule.__allocArray = __allocArray;\n\n  /** Gets a live view on an array's values in the module's memory. Infers the array type from RTTI. */\n  function __getArrayView(arr) {\n    const U32 = new Uint32Array(memory.buffer);\n    const id = U32[arr + ID_OFFSET >>> 2];\n    const info = getInfo(id);\n    if (!(info & ARRAYBUFFERVIEW)) throw Error(\"not an array: \" + id);\n    const align = getValueAlign(info);\n    var buf = U32[arr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    const length = info & ARRAY\n      ? U32[arr + ARRAY_LENGTH_OFFSET >>> 2]\n      : U32[buf + SIZE_OFFSET >>> 2] >>> align;\n    return getView(align, info & VAL_SIGNED, info & VAL_FLOAT)\n          .subarray(buf >>>= align, buf + length);\n  }\n\n  baseModule.__getArrayView = __getArrayView;\n\n  /** Copies an array's values from the module's memory. Infers the array type from RTTI. */\n  function __getArray(arr) {\n    const input = __getArrayView(arr);\n    const len = input.length;\n    const out = new Array(len);\n    for (let i = 0; i < len; i++) out[i] = input[i];\n    return out;\n  }\n\n  baseModule.__getArray = __getArray;\n\n  /** Copies an ArrayBuffer's value from the module's memory. */\n  function __getArrayBuffer(ptr) {\n    const buffer = memory.buffer;\n    const length = new Uint32Array(buffer)[ptr + SIZE_OFFSET >>> 2];\n    return buffer.slice(ptr, ptr + length);\n  }\n\n  baseModule.__getArrayBuffer = __getArrayBuffer;\n\n  /** Copies a typed array's values from the module's memory. */\n  function getTypedArray(Type, alignLog2, ptr) {\n    return new Type(getTypedArrayView(Type, alignLog2, ptr));\n  }\n\n  /** Gets a live view on a typed array's values in the module's memory. */\n  function getTypedArrayView(Type, alignLog2, ptr) {\n    const buffer = memory.buffer;\n    const U32 = new Uint32Array(buffer);\n    const bufPtr = U32[ptr + ARRAYBUFFERVIEW_DATASTART_OFFSET >>> 2];\n    return new Type(buffer, bufPtr, U32[bufPtr + SIZE_OFFSET >>> 2] >>> alignLog2);\n  }\n\n  baseModule.__getInt8Array = getTypedArray.bind(null, Int8Array, 0);\n  baseModule.__getInt8ArrayView = getTypedArrayView.bind(null, Int8Array, 0);\n  baseModule.__getUint8Array = getTypedArray.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ArrayView = getTypedArrayView.bind(null, Uint8Array, 0);\n  baseModule.__getUint8ClampedArray = getTypedArray.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getUint8ClampedArrayView = getTypedArrayView.bind(null, Uint8ClampedArray, 0);\n  baseModule.__getInt16Array = getTypedArray.bind(null, Int16Array, 1);\n  baseModule.__getInt16ArrayView = getTypedArrayView.bind(null, Int16Array, 1);\n  baseModule.__getUint16Array = getTypedArray.bind(null, Uint16Array, 1);\n  baseModule.__getUint16ArrayView = getTypedArrayView.bind(null, Uint16Array, 1);\n  baseModule.__getInt32Array = getTypedArray.bind(null, Int32Array, 2);\n  baseModule.__getInt32ArrayView = getTypedArrayView.bind(null, Int32Array, 2);\n  baseModule.__getUint32Array = getTypedArray.bind(null, Uint32Array, 2);\n  baseModule.__getUint32ArrayView = getTypedArrayView.bind(null, Uint32Array, 2);\n  if (BIGINT) {\n    baseModule.__getInt64Array = getTypedArray.bind(null, BigInt64Array, 3);\n    baseModule.__getInt64ArrayView = getTypedArrayView.bind(null, BigInt64Array, 3);\n    baseModule.__getUint64Array = getTypedArray.bind(null, BigUint64Array, 3);\n    baseModule.__getUint64ArrayView = getTypedArrayView.bind(null, BigUint64Array, 3);\n  }\n  baseModule.__getFloat32Array = getTypedArray.bind(null, Float32Array, 2);\n  baseModule.__getFloat32ArrayView = getTypedArrayView.bind(null, Float32Array, 2);\n  baseModule.__getFloat64Array = getTypedArray.bind(null, Float64Array, 3);\n  baseModule.__getFloat64ArrayView = getTypedArrayView.bind(null, Float64Array, 3);\n\n  /** Tests whether an object is an instance of the class represented by the specified base id. */\n  function __instanceof(ptr, baseId) {\n    const U32 = new Uint32Array(memory.buffer);\n    var id = U32[(ptr + ID_OFFSET) >>> 2];\n    if (id <= U32[rttiBase >>> 2]) {\n      do if (id == baseId) return true;\n      while (id = getBase(id));\n    }\n    return false;\n  }\n\n  baseModule.__instanceof = __instanceof;\n\n  // Pull basic exports to baseModule so code in preInstantiate can use them\n  baseModule.memory = baseModule.memory || memory;\n  baseModule.table  = baseModule.table  || table;\n\n  // Demangle exports and provide the usual utility on the prototype\n  return demangle(rawExports, baseModule);\n}\n\nfunction isResponse(o) {\n  return typeof Response !== \"undefined\" && o instanceof Response;\n}\n\n/** Asynchronously instantiates an AssemblyScript module from anything that can be instantiated. */\nasync function instantiate(source, imports) {\n  if (isResponse(source = await source)) return instantiateStreaming(source, imports);\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    await WebAssembly.instantiate(\n      source instanceof WebAssembly.Module\n        ? source\n        : await WebAssembly.compile(source),\n      imports\n    )\n  );\n}\n\nexports.instantiate = instantiate;\n\n/** Synchronously instantiates an AssemblyScript module from a WebAssembly.Module or binary buffer. */\nfunction instantiateSync(source, imports) {\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    new WebAssembly.Instance(\n      source instanceof WebAssembly.Module\n        ? source\n        : new WebAssembly.Module(source),\n      imports\n    )\n  )\n}\n\nexports.instantiateSync = instantiateSync;\n\n/** Asynchronously instantiates an AssemblyScript module from a response, i.e. as obtained by `fetch`. */\nasync function instantiateStreaming(source, imports) {\n  if (!WebAssembly.instantiateStreaming) {\n    return instantiate(\n      isResponse(source = await source)\n        ? source.arrayBuffer()\n        : source,\n      imports\n    );\n  }\n  return postInstantiate(\n    preInstantiate(imports || (imports = {})),\n    (await WebAssembly.instantiateStreaming(source, imports)).instance\n  );\n}\n\nexports.instantiateStreaming = instantiateStreaming;\n\n/** Demangles an AssemblyScript module's exports to a friendly object structure. */\nfunction demangle(exports, baseModule) {\n  var module = baseModule ? Object.create(baseModule) : {};\n  var setArgumentsLength = exports[\"__argumentsLength\"]\n    ? function(length) { exports[\"__argumentsLength\"].value = length; }\n    : exports[\"__setArgumentsLength\"] || exports[\"__setargc\"] || function() {};\n  for (let internalName in exports) {\n    if (!Object.prototype.hasOwnProperty.call(exports, internalName)) continue;\n    const elem = exports[internalName];\n    let parts = internalName.split(\".\");\n    let curr = module;\n    while (parts.length > 1) {\n      let part = parts.shift();\n      if (!Object.prototype.hasOwnProperty.call(curr, part)) curr[part] = {};\n      curr = curr[part];\n    }\n    let name = parts[0];\n    let hash = name.indexOf(\"#\");\n    if (hash >= 0) {\n      let className = name.substring(0, hash);\n      let classElem = curr[className];\n      if (typeof classElem === \"undefined\" || !classElem.prototype) {\n        let ctor = function(...args) {\n          return ctor.wrap(ctor.prototype.constructor(0, ...args));\n        };\n        ctor.prototype = {\n          valueOf: function valueOf() {\n            return this[THIS];\n          }\n        };\n        ctor.wrap = function(thisValue) {\n          return Object.create(ctor.prototype, { [THIS]: { value: thisValue, writable: false } });\n        };\n        if (classElem) Object.getOwnPropertyNames(classElem).forEach(name =>\n          Object.defineProperty(ctor, name, Object.getOwnPropertyDescriptor(classElem, name))\n        );\n        curr[className] = ctor;\n      }\n      name = name.substring(hash + 1);\n      curr = curr[className].prototype;\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          let getter = exports[internalName.replace(\"set:\", \"get:\")];\n          let setter = exports[internalName.replace(\"get:\", \"set:\")];\n          Object.defineProperty(curr, name, {\n            get: function() { return getter(this[THIS]); },\n            set: function(value) { setter(this[THIS], value); },\n            enumerable: true\n          });\n        }\n      } else {\n        if (name === 'constructor') {\n          (curr[name] = (...args) => {\n            setArgumentsLength(args.length);\n            return elem(...args);\n          }).original = elem;\n        } else { // instance method\n          (curr[name] = function(...args) { // !\n            setArgumentsLength(args.length);\n            return elem(this[THIS], ...args);\n          }).original = elem;\n        }\n      }\n    } else {\n      if (/^(get|set):/.test(name)) {\n        if (!Object.prototype.hasOwnProperty.call(curr, name = name.substring(4))) {\n          Object.defineProperty(curr, name, {\n            get: exports[internalName.replace(\"set:\", \"get:\")],\n            set: exports[internalName.replace(\"get:\", \"set:\")],\n            enumerable: true\n          });\n        }\n      } else if (typeof elem === \"function\" && elem !== setArgumentsLength) {\n        (curr[name] = (...args) => {\n          setArgumentsLength(args.length);\n          return elem(...args);\n        }).original = elem;\n      } else {\n        curr[name] = elem;\n      }\n    }\n  }\n  return module;\n}\n\nexports.demangle = demangle;\n","var g;\n\n// This works in non-strict mode\ng = (function() {\n\treturn this;\n})();\n\ntry {\n\t// This works if eval is allowed (see CSP)\n\tg = g || new Function(\"return this\")();\n} catch (e) {\n\t// This works if the window reference is available\n\tif (typeof window === \"object\") g = window;\n}\n\n// g can still be undefined, but nothing to do about it...\n// We return undefined, instead of nothing here, so it's\n// easier to handle this case. if(!global) { ...}\n\nmodule.exports = g;\n","'use strict'\n\nexports.byteLength = byteLength\nexports.toByteArray = toByteArray\nexports.fromByteArray = fromByteArray\n\nvar lookup = []\nvar revLookup = []\nvar Arr = typeof Uint8Array !== 'undefined' ? Uint8Array : Array\n\nvar code = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789+/'\nfor (var i = 0, len = code.length; i < len; ++i) {\n  lookup[i] = code[i]\n  revLookup[code.charCodeAt(i)] = i\n}\n\n// Support decoding URL-safe base64 strings, as Node.js does.\n// See: https://en.wikipedia.org/wiki/Base64#URL_applications\nrevLookup['-'.charCodeAt(0)] = 62\nrevLookup['_'.charCodeAt(0)] = 63\n\nfunction getLens (b64) {\n  var len = b64.length\n\n  if (len % 4 > 0) {\n    throw new Error('Invalid string. Length must be a multiple of 4')\n  }\n\n  // Trim off extra bytes after placeholder bytes are found\n  // See: https://github.com/beatgammit/base64-js/issues/42\n  var validLen = b64.indexOf('=')\n  if (validLen === -1) validLen = len\n\n  var placeHoldersLen = validLen === len\n    ? 0\n    : 4 - (validLen % 4)\n\n  return [validLen, placeHoldersLen]\n}\n\n// base64 is 4/3 + up to two characters of the original data\nfunction byteLength (b64) {\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction _byteLength (b64, validLen, placeHoldersLen) {\n  return ((validLen + placeHoldersLen) * 3 / 4) - placeHoldersLen\n}\n\nfunction toByteArray (b64) {\n  var tmp\n  var lens = getLens(b64)\n  var validLen = lens[0]\n  var placeHoldersLen = lens[1]\n\n  var arr = new Arr(_byteLength(b64, validLen, placeHoldersLen))\n\n  var curByte = 0\n\n  // if there are placeholders, only get up to the last complete 4 chars\n  var len = placeHoldersLen > 0\n    ? validLen - 4\n    : validLen\n\n  var i\n  for (i = 0; i < len; i += 4) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 18) |\n      (revLookup[b64.charCodeAt(i + 1)] << 12) |\n      (revLookup[b64.charCodeAt(i + 2)] << 6) |\n      revLookup[b64.charCodeAt(i + 3)]\n    arr[curByte++] = (tmp >> 16) & 0xFF\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 2) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 2) |\n      (revLookup[b64.charCodeAt(i + 1)] >> 4)\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  if (placeHoldersLen === 1) {\n    tmp =\n      (revLookup[b64.charCodeAt(i)] << 10) |\n      (revLookup[b64.charCodeAt(i + 1)] << 4) |\n      (revLookup[b64.charCodeAt(i + 2)] >> 2)\n    arr[curByte++] = (tmp >> 8) & 0xFF\n    arr[curByte++] = tmp & 0xFF\n  }\n\n  return arr\n}\n\nfunction tripletToBase64 (num) {\n  return lookup[num >> 18 & 0x3F] +\n    lookup[num >> 12 & 0x3F] +\n    lookup[num >> 6 & 0x3F] +\n    lookup[num & 0x3F]\n}\n\nfunction encodeChunk (uint8, start, end) {\n  var tmp\n  var output = []\n  for (var i = start; i < end; i += 3) {\n    tmp =\n      ((uint8[i] << 16) & 0xFF0000) +\n      ((uint8[i + 1] << 8) & 0xFF00) +\n      (uint8[i + 2] & 0xFF)\n    output.push(tripletToBase64(tmp))\n  }\n  return output.join('')\n}\n\nfunction fromByteArray (uint8) {\n  var tmp\n  var len = uint8.length\n  var extraBytes = len % 3 // if we have 1 byte left, pad 2 bytes\n  var parts = []\n  var maxChunkLength = 16383 // must be multiple of 3\n\n  // go through the array every three bytes, we'll deal with trailing stuff later\n  for (var i = 0, len2 = len - extraBytes; i < len2; i += maxChunkLength) {\n    parts.push(encodeChunk(uint8, i, (i + maxChunkLength) > len2 ? len2 : (i + maxChunkLength)))\n  }\n\n  // pad the end with zeros, but make sure to not forget the extra bytes\n  if (extraBytes === 1) {\n    tmp = uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 2] +\n      lookup[(tmp << 4) & 0x3F] +\n      '=='\n    )\n  } else if (extraBytes === 2) {\n    tmp = (uint8[len - 2] << 8) + uint8[len - 1]\n    parts.push(\n      lookup[tmp >> 10] +\n      lookup[(tmp >> 4) & 0x3F] +\n      lookup[(tmp << 2) & 0x3F] +\n      '='\n    )\n  }\n\n  return parts.join('')\n}\n","/*! ieee754. BSD-3-Clause License. Feross Aboukhadijeh <https://feross.org/opensource> */\nexports.read = function (buffer, offset, isLE, mLen, nBytes) {\n  var e, m\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var nBits = -7\n  var i = isLE ? (nBytes - 1) : 0\n  var d = isLE ? -1 : 1\n  var s = buffer[offset + i]\n\n  i += d\n\n  e = s & ((1 << (-nBits)) - 1)\n  s >>= (-nBits)\n  nBits += eLen\n  for (; nBits > 0; e = (e * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  m = e & ((1 << (-nBits)) - 1)\n  e >>= (-nBits)\n  nBits += mLen\n  for (; nBits > 0; m = (m * 256) + buffer[offset + i], i += d, nBits -= 8) {}\n\n  if (e === 0) {\n    e = 1 - eBias\n  } else if (e === eMax) {\n    return m ? NaN : ((s ? -1 : 1) * Infinity)\n  } else {\n    m = m + Math.pow(2, mLen)\n    e = e - eBias\n  }\n  return (s ? -1 : 1) * m * Math.pow(2, e - mLen)\n}\n\nexports.write = function (buffer, value, offset, isLE, mLen, nBytes) {\n  var e, m, c\n  var eLen = (nBytes * 8) - mLen - 1\n  var eMax = (1 << eLen) - 1\n  var eBias = eMax >> 1\n  var rt = (mLen === 23 ? Math.pow(2, -24) - Math.pow(2, -77) : 0)\n  var i = isLE ? 0 : (nBytes - 1)\n  var d = isLE ? 1 : -1\n  var s = value < 0 || (value === 0 && 1 / value < 0) ? 1 : 0\n\n  value = Math.abs(value)\n\n  if (isNaN(value) || value === Infinity) {\n    m = isNaN(value) ? 1 : 0\n    e = eMax\n  } else {\n    e = Math.floor(Math.log(value) / Math.LN2)\n    if (value * (c = Math.pow(2, -e)) < 1) {\n      e--\n      c *= 2\n    }\n    if (e + eBias >= 1) {\n      value += rt / c\n    } else {\n      value += rt * Math.pow(2, 1 - eBias)\n    }\n    if (value * c >= 2) {\n      e++\n      c /= 2\n    }\n\n    if (e + eBias >= eMax) {\n      m = 0\n      e = eMax\n    } else if (e + eBias >= 1) {\n      m = ((value * c) - 1) * Math.pow(2, mLen)\n      e = e + eBias\n    } else {\n      m = value * Math.pow(2, eBias - 1) * Math.pow(2, mLen)\n      e = 0\n    }\n  }\n\n  for (; mLen >= 8; buffer[offset + i] = m & 0xff, i += d, m /= 256, mLen -= 8) {}\n\n  e = (e << mLen) | m\n  eLen += mLen\n  for (; eLen > 0; buffer[offset + i] = e & 0xff, i += d, e /= 256, eLen -= 8) {}\n\n  buffer[offset + i - d] |= s * 128\n}\n","var toString = {}.toString;\n\nmodule.exports = Array.isArray || function (arr) {\n  return toString.call(arr) == '[object Array]';\n};\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.subtreeFillToContents = exports.subtreeFillToLength = exports.subtreeFillToDepth = void 0;\nconst node_1 = require(\"./node\");\nconst zeroNode_1 = require(\"./zeroNode\");\nconst ERR_NAVIGATION = \"Navigation error\";\nconst ERR_TOO_MANY_NODES = \"Too many nodes\";\n// subtree filling\nfunction subtreeFillToDepth(bottom, depth) {\n    let node = bottom;\n    while (depth > 0) {\n        node = new node_1.BranchNode(node, node);\n        depth--;\n    }\n    return node;\n}\nexports.subtreeFillToDepth = subtreeFillToDepth;\nfunction subtreeFillToLength(bottom, depth, length) {\n    const maxLength = 1 << depth;\n    if (length > maxLength)\n        throw new Error(ERR_TOO_MANY_NODES);\n    if (length === maxLength)\n        return subtreeFillToDepth(bottom, depth);\n    if (depth === 0) {\n        if (length === 1)\n            return bottom;\n        else\n            throw new Error(ERR_NAVIGATION);\n    }\n    if (depth === 1) {\n        return new node_1.BranchNode(bottom, length > 1 ? bottom : zeroNode_1.zeroNode(0));\n    }\n    const pivot = maxLength >> 1;\n    if (length <= pivot) {\n        return new node_1.BranchNode(subtreeFillToLength(bottom, depth - 1, length), zeroNode_1.zeroNode(depth - 1));\n    }\n    else {\n        return new node_1.BranchNode(subtreeFillToDepth(bottom, depth - 1), subtreeFillToLength(bottom, depth - 1, length - pivot));\n    }\n}\nexports.subtreeFillToLength = subtreeFillToLength;\nfunction subtreeFillToContents(nodes, depth) {\n    const maxLength = 2 ** depth;\n    if (nodes.length > maxLength)\n        throw new Error(ERR_TOO_MANY_NODES);\n    if (depth === 0) {\n        if (!nodes.length)\n            return zeroNode_1.zeroNode(0);\n        return nodes[0];\n    }\n    if (depth === 1) {\n        if (!nodes.length)\n            return zeroNode_1.zeroNode(1);\n        return new node_1.BranchNode(nodes[0], nodes[1] || zeroNode_1.zeroNode(0));\n    }\n    const pivot = Math.floor(maxLength / 2);\n    if (nodes.length <= pivot) {\n        return new node_1.BranchNode(subtreeFillToContents(nodes, depth - 1), zeroNode_1.zeroNode(depth - 1));\n    }\n    else {\n        return new node_1.BranchNode(subtreeFillToContents(nodes.slice(0, Number(pivot)), depth - 1), subtreeFillToContents(nodes.slice(Number(pivot)), depth - 1));\n    }\n}\nexports.subtreeFillToContents = subtreeFillToContents;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.Tree = void 0;\nconst gindex_1 = require(\"./gindex\");\nconst node_1 = require(\"./node\");\nconst proof_1 = require(\"./proof\");\nconst single_1 = require(\"./proof/single\");\nconst zeroNode_1 = require(\"./zeroNode\");\nconst ERR_INVALID_TREE = \"Invalid tree operation\";\nconst ERR_PARAM_LT_ZERO = \"Param must be >= 0\";\nconst ERR_COUNT_GT_DEPTH = \"Count extends beyond depth limit\";\nclass Tree {\n    constructor(node, hook) {\n        this._node = node;\n        if (hook) {\n            if (typeof WeakRef === \"undefined\") {\n                this.hook = hook;\n            }\n            else {\n                this.hook = new WeakRef(hook);\n            }\n        }\n    }\n    static createFromProof(proof) {\n        return new Tree(proof_1.createNodeFromProof(proof));\n    }\n    get rootNode() {\n        return this._node;\n    }\n    set rootNode(n) {\n        this._node = n;\n        if (this.hook) {\n            // WeakRef should not change status during a program's execution\n            // So, use WeakRef feature detection to assume the type of this.hook\n            // to minimize the memory footprint of Tree\n            if (typeof WeakRef === \"undefined\") {\n                this.hook(this);\n            }\n            else {\n                const hookVar = this.hook.deref();\n                if (hookVar) {\n                    hookVar(this);\n                }\n                else {\n                    // Hook has been garbage collected, no need to keep the hookRef\n                    this.hook = undefined;\n                }\n            }\n        }\n    }\n    get root() {\n        return this.rootNode.root;\n    }\n    getNode(index) {\n        let node = this.rootNode;\n        for (const i of gindex_1.gindexIterator(index)) {\n            if (i) {\n                if (node.isLeaf())\n                    throw new Error(ERR_INVALID_TREE);\n                node = node.right;\n            }\n            else {\n                if (node.isLeaf())\n                    throw new Error(ERR_INVALID_TREE);\n                node = node.left;\n            }\n        }\n        return node;\n    }\n    setter(index, expand = false) {\n        let link = node_1.identity;\n        let node = this.rootNode;\n        const iterator = gindex_1.gindexIterator(index);\n        for (const i of iterator) {\n            if (i) {\n                if (node.isLeaf()) {\n                    if (!expand)\n                        throw new Error(ERR_INVALID_TREE);\n                    else {\n                        const child = zeroNode_1.zeroNode(iterator.remainingBitLength() - 1);\n                        node = new node_1.BranchNode(child, child);\n                    }\n                }\n                link = node_1.compose(node.rebindRight.bind(node), link);\n                node = node.right;\n            }\n            else {\n                if (node.isLeaf()) {\n                    if (!expand)\n                        throw new Error(ERR_INVALID_TREE);\n                    else {\n                        const child = zeroNode_1.zeroNode(iterator.remainingBitLength() - 1);\n                        node = new node_1.BranchNode(child, child);\n                    }\n                }\n                link = node_1.compose(node.rebindLeft.bind(node), link);\n                node = node.left;\n            }\n        }\n        return node_1.compose(node_1.identity, link);\n    }\n    setNode(index, n, expand = false) {\n        this.rootNode = this.setter(index, expand)(n);\n    }\n    getRoot(index) {\n        return this.getNode(index).root;\n    }\n    setRoot(index, root, expand = false) {\n        this.setNode(index, new node_1.LeafNode(root), expand);\n    }\n    getSubtree(index) {\n        return new Tree(this.getNode(index), (v) => this.setNode(index, v.rootNode));\n    }\n    setSubtree(index, v, expand = false) {\n        this.setNode(index, v.rootNode, expand);\n    }\n    clone() {\n        return new Tree(this.rootNode);\n    }\n    getSingleProof(index) {\n        return single_1.createSingleProof(this.rootNode, index)[1];\n    }\n    /**\n     * Fast read-only iteration\n     * In-order traversal of nodes at `depth`\n     * starting from the `startIndex`-indexed node\n     * iterating through `count` nodes\n     */\n    *iterateNodesAtDepth(depth, startIndex, count) {\n        // Strategy:\n        // First nagivate to the starting Gindex node,\n        // At each level record the tuple (current node, the navigation direction) in a list (Left=0, Right=1)\n        // Once we reach the starting Gindex node, the list will be length == depth\n        // Begin emitting nodes: Outer loop:\n        //   Yield the current node\n        //   Inner loop\n        //     pop off the end of the list\n        //     If its (N, Left) (we've nav'd the left subtree, but not the right subtree)\n        //       push (N, Right) and set set node as the n.right\n        //       push (N, Left) and set node as n.left until list length == depth\n        //   Inner loop until the list length == depth\n        // Outer loop until the list is empty or the yield count == count\n        if (startIndex < 0 || count < 0 || depth < 0) {\n            throw new Error(ERR_PARAM_LT_ZERO);\n        }\n        if (BigInt(1) << BigInt(depth) < startIndex + count) {\n            throw new Error(ERR_COUNT_GT_DEPTH);\n        }\n        if (count === 0) {\n            return;\n        }\n        if (depth === 0) {\n            yield this.rootNode;\n            return;\n        }\n        let node = this.rootNode;\n        let currCount = 0;\n        const startGindex = gindex_1.toGindexBitstring(depth, BigInt(startIndex));\n        const nav = [];\n        for (const i of gindex_1.gindexIterator(startGindex)) {\n            nav.push([node, i]);\n            if (i) {\n                if (node.isLeaf())\n                    throw new Error(ERR_INVALID_TREE);\n                node = node.right;\n            }\n            else {\n                if (node.isLeaf())\n                    throw new Error(ERR_INVALID_TREE);\n                node = node.left;\n            }\n        }\n        while (nav.length && currCount < count) {\n            yield node;\n            currCount++;\n            if (currCount === count) {\n                return;\n            }\n            do {\n                const [parentNode, direction] = nav.pop();\n                // if direction was left\n                if (!direction) {\n                    // now navigate right\n                    nav.push([parentNode, 1]);\n                    if (parentNode.isLeaf())\n                        throw new Error(ERR_INVALID_TREE);\n                    node = parentNode.right;\n                    // and then left as far as possible\n                    while (nav.length !== depth) {\n                        nav.push([node, 0]);\n                        if (node.isLeaf())\n                            throw new Error(ERR_INVALID_TREE);\n                        node = node.left;\n                    }\n                }\n            } while (nav.length && nav.length !== depth);\n        }\n    }\n    getProof(input) {\n        return proof_1.createProof(this.rootNode, input);\n    }\n}\nexports.Tree = Tree;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.deserializeTreeOffsetProof = exports.serializeTreeOffsetProof = exports.computeTreeOffsetProofSerializedLength = exports.createNodeFromTreeOffsetProof = exports.createTreeOffsetProof = exports.treeOffsetProofToNode = exports.nodeToTreeOffsetProof = void 0;\nconst node_1 = require(\"../node\");\nconst util_1 = require(\"./util\");\n/**\n * Compute offsets and leaves of a tree-offset proof\n *\n * Recursive function\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n * @param node current node in the tree\n * @param gindex current generalized index in the tree\n * @param proofGindices generalized indices to left include in the proof - must be sorted in-order according to the tree\n */\nfunction nodeToTreeOffsetProof(node, gindex, proofGindices) {\n    if (!proofGindices.length || !proofGindices[0].startsWith(gindex)) {\n        // there are no proof indices left OR the current subtree contains no remaining proof indices\n        return [[], []];\n    }\n    else if (gindex === proofGindices[0]) {\n        // the current node is at the next proof index\n        proofGindices.shift();\n        return [[], [node.root]];\n    }\n    else {\n        // recursively compute offsets, leaves for the left and right subtree\n        const [leftOffsets, leftLeaves] = nodeToTreeOffsetProof(node.left, gindex + \"0\", proofGindices);\n        const [rightOffsets, rightLeaves] = nodeToTreeOffsetProof(node.right, gindex + \"1\", proofGindices);\n        // the offset prepended to the list is # of leaves in the left subtree\n        const pivot = leftLeaves.length;\n        return [[pivot].concat(leftOffsets, rightOffsets), leftLeaves.concat(rightLeaves)];\n    }\n}\nexports.nodeToTreeOffsetProof = nodeToTreeOffsetProof;\n/**\n * Recreate a `Node` given offsets and leaves of a tree-offset proof\n *\n * Recursive definition\n *\n * See https://github.com/protolambda/eth-merkle-trees/blob/master/tree_offsets.md\n */\nfunction treeOffsetProofToNode(offsets, leaves) {\n    if (!leaves.length) {\n        throw new Error(\"Proof must contain gt 0 leaves\");\n    }\n    else if (leaves.length === 1) {\n        return new node_1.LeafNode(leaves[0]);\n    }\n    else {\n        // the offset popped from the list is the # of leaves in the left subtree\n        const pivot = offsets[0];\n        return new node_1.BranchNode(treeOffsetProofToNode(offsets.slice(1, pivot), leaves.slice(0, pivot)), treeOffsetProofToNode(offsets.slice(pivot), leaves.slice(pivot)));\n    }\n}\nexports.treeOffsetProofToNode = treeOffsetProofToNode;\n/**\n * Create a tree-offset proof\n *\n * @param rootNode the root node of the tree\n * @param gindices generalized indices to include in the proof\n */\nfunction createTreeOffsetProof(rootNode, gindices) {\n    return nodeToTreeOffsetProof(rootNode, \"1\", util_1.computeMultiProofBitstrings(gindices.map((g) => g.toString(2))));\n}\nexports.createTreeOffsetProof = createTreeOffsetProof;\n/**\n * Recreate a `Node` given a tree-offset proof\n *\n * @param offsets offsets of a tree-offset proof\n * @param leaves leaves of a tree-offset proof\n */\nfunction createNodeFromTreeOffsetProof(offsets, leaves) {\n    // TODO validation\n    return treeOffsetProofToNode(offsets, leaves);\n}\nexports.createNodeFromTreeOffsetProof = createNodeFromTreeOffsetProof;\nfunction computeTreeOffsetProofSerializedLength(offsets, leaves) {\n    // add 1 for # of leaves\n    return (offsets.length + 1) * 2 + leaves.length * 32;\n}\nexports.computeTreeOffsetProofSerializedLength = computeTreeOffsetProofSerializedLength;\n// Serialized tree offset proof structure:\n// # of leaves - 2 bytes\n// offsets - 2 bytes each\n// leaves - 32 bytes each\nfunction serializeTreeOffsetProof(output, byteOffset, offsets, leaves) {\n    const writer = new DataView(output.buffer, output.byteOffset, output.byteLength);\n    // set # of leaves\n    writer.setUint16(byteOffset, leaves.length, true);\n    // set offsets\n    const offsetsStartIndex = byteOffset + 2;\n    for (let i = 0; i < offsets.length; i++) {\n        writer.setUint16(i * 2 + offsetsStartIndex, offsets[i], true);\n    }\n    // set leaves\n    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n    for (let i = 0; i < leaves.length; i++) {\n        output.set(leaves[i], i * 32 + leavesStartIndex);\n    }\n}\nexports.serializeTreeOffsetProof = serializeTreeOffsetProof;\nfunction deserializeTreeOffsetProof(data, byteOffset) {\n    const reader = new DataView(data.buffer, data.byteOffset, data.byteLength);\n    // get # of leaves\n    const leafCount = reader.getUint16(byteOffset, true);\n    if (data.length < (leafCount - 1) * 2 + leafCount * 32) {\n        throw new Error(\"Unable to deserialize tree offset proof: not enough bytes\");\n    }\n    // get offsets\n    const offsetsStartIndex = byteOffset + 2;\n    const offsets = Array.from({ length: leafCount - 1 }, (_, i) => reader.getUint16(i * 2 + offsetsStartIndex, true));\n    // get leaves\n    const leavesStartIndex = offsetsStartIndex + offsets.length * 2;\n    const leaves = Array.from({ length: leafCount }, (_, i) => data.subarray(i * 32 + leavesStartIndex, (i + 1) * 32 + leavesStartIndex));\n    return [offsets, leaves];\n}\nexports.deserializeTreeOffsetProof = deserializeTreeOffsetProof;\n","\"use strict\";\nObject.defineProperty(exports, \"__esModule\", { value: true });\nexports.computeMultiProofBitstrings = exports.filterParentBitstrings = exports.sortInOrderBitstrings = exports.computeProofBitstrings = exports.computeProofGindices = void 0;\nconst gindex_1 = require(\"../gindex\");\n// Not currently in use, but simpler implementation useful for testing\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofGindices(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g > 1) {\n        path.add(g);\n        branch.add(gindex_1.gindexSibling(g));\n        g = gindex_1.gindexParent(g);\n    }\n    return { path, branch };\n}\nexports.computeProofGindices = computeProofGindices;\n/**\n * Compute both the path and branch indices\n *\n * Path indices are parent indices upwards toward the root\n * Branch indices are witnesses required for a merkle proof\n */\nfunction computeProofBitstrings(gindex) {\n    const path = new Set();\n    const branch = new Set();\n    let g = gindex;\n    while (g.length > 1) {\n        path.add(g);\n        const lastBit = g[g.length - 1];\n        const parent = g.substring(0, g.length - 1);\n        branch.add(parent + (Number(lastBit) ^ 1));\n        g = parent;\n    }\n    return { path, branch };\n}\nexports.computeProofBitstrings = computeProofBitstrings;\n/**\n * Sort generalized indices in-order\n * @param bitLength maximum bit length of generalized indices to sort\n */\nfunction sortInOrderBitstrings(gindices, bitLength) {\n    if (!gindices.length) {\n        return [];\n    }\n    return gindices\n        .map((g) => g.padEnd(bitLength))\n        .sort()\n        .map((g) => g.trim());\n}\nexports.sortInOrderBitstrings = sortInOrderBitstrings;\n/**\n * Filter out parent generalized indices\n */\nfunction filterParentBitstrings(gindices) {\n    const sortedBitstrings = gindices.sort((a, b) => a.length - b.length);\n    const filtered = [];\n    outer: for (let i = 0; i < sortedBitstrings.length; i++) {\n        const bsA = sortedBitstrings[i];\n        for (let j = i + 1; j < sortedBitstrings.length; j++) {\n            const bsB = sortedBitstrings[j];\n            if (bsB.startsWith(bsA)) {\n                continue outer;\n            }\n        }\n        filtered.push(bsA);\n    }\n    return filtered;\n}\nexports.filterParentBitstrings = filterParentBitstrings;\n/**\n * Return the set of generalized indices required for a multiproof\n * This includes all leaves and any necessary witnesses\n * @param gindices leaves to include in proof\n * @returns all generalized indices required for a multiproof (leaves and witnesses), deduplicated and sorted in-order according to the tree\n */\nfunction computeMultiProofBitstrings(gindices) {\n    // Initialize the proof indices with the leaves\n    const proof = new Set(filterParentBitstrings(gindices));\n    const paths = new Set();\n    const branches = new Set();\n    // Collect all path indices and all branch indices\n    let maxBitLength = 1;\n    for (const gindex of proof) {\n        if (gindex.length > maxBitLength)\n            maxBitLength = gindex.length;\n        const { path, branch } = computeProofBitstrings(gindex);\n        path.forEach((g) => paths.add(g));\n        branch.forEach((g) => branches.add(g));\n    }\n    // Remove all branches that are included in the paths\n    paths.forEach((g) => branches.delete(g));\n    // Add all remaining branches to the leaves\n    branches.forEach((g) => proof.add(g));\n    return sortInOrderBitstrings(Array.from(proof), maxBitLength);\n}\nexports.computeMultiProofBitstrings = computeMultiProofBitstrings;\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.merkleize = merkleize;\nexports.mixInLength = mixInLength;\n\nvar _hash = require(\"./hash\");\n\nvar _math = require(\"./math\");\n\nvar _zeros = require(\"./zeros\");\n\n/** @module ssz */\n\n/** @ignore */\nfunction merkleize(chunks, padFor = 0) {\n  const layerCount = (0, _math.bitLength)((0, _math.nextPowerOf2)(padFor || chunks.length) - 1);\n\n  if (chunks.length == 0) {\n    return _zeros.zeroHashes[layerCount];\n  } // Instead of pushing on all padding zero chunks at the leaf level\n  // we push on zero hash chunks at the highest possible level to avoid over-hashing\n\n\n  let layer = 0;\n\n  while (layer < layerCount) {\n    // if the chunks.length is odd\n    // we need to push on the zero-hash of that level to merkleize that level\n    if (chunks.length % 2 == 1) {\n      chunks.push(_zeros.zeroHashes[layer]);\n    }\n\n    for (let i = 0; i < chunks.length; i += 2) {\n      const h = (0, _hash.hash)(chunks[i], chunks[i + 1]);\n      chunks[i / 2] = Buffer.from(h.buffer, h.byteOffset, h.byteLength);\n    }\n\n    chunks.splice(chunks.length / 2, chunks.length / 2);\n    layer++;\n  }\n\n  return chunks[0];\n}\n/** @ignore */\n\n\nfunction mixInLength(root, length) {\n  const lengthBuf = Buffer.alloc(32);\n  lengthBuf.writeUIntLE(length, 0, 6);\n  const h = (0, _hash.hash)(root, lengthBuf);\n  return Buffer.from(h.buffer, h.byteOffset, h.byteLength);\n}\n//# sourceMappingURL=merkleize.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.bitLength = bitLength;\nexports.nextPowerOf2 = nextPowerOf2;\nexports.previousPowerOf2 = previousPowerOf2;\n\n/** @ignore */\nfunction bitLength(n) {\n  const bitstring = n.toString(2);\n\n  if (bitstring === \"0\") {\n    return 0;\n  }\n\n  return bitstring.length;\n}\n/** @ignore */\n\n\nfunction nextPowerOf2(n) {\n  return n <= 0 ? 1 : Math.pow(2, bitLength(n - 1));\n}\n/** @ignore */\n\n\nfunction previousPowerOf2(n) {\n  return n === 0 ? 1 : Math.pow(2, bitLength(n) - 1);\n}\n//# sourceMappingURL=math.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.zeroHashes = void 0;\n\nvar _constants = require(\"./constants\");\n\nvar _hash = require(\"./hash\");\n\n/** @module ssz */\n// create array of \"zero hashes\", successively hashed zero chunks\nconst zeroHashes = [Buffer.alloc(_constants.BYTES_PER_CHUNK)];\nexports.zeroHashes = zeroHashes;\n\nfor (let i = 0; i < 52; i++) {\n  const h = (0, _hash.hash)(zeroHashes[i], zeroHashes[i]);\n  zeroHashes.push(Buffer.from(h.buffer, h.byteOffset, h.byteLength));\n}\n//# sourceMappingURL=zeros.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBitVectorType = isBitVectorType;\nexports.BitVectorType = exports.BITVECTOR_TYPE = void 0;\n\nvar _vector = require(\"./vector\");\n\nvar _basic = require(\"../basic\");\n\nvar _type = require(\"../type\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nvar _constants = require(\"../../util/constants\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst BITVECTOR_TYPE = Symbol.for(\"ssz/BitVectorType\");\nexports.BITVECTOR_TYPE = BITVECTOR_TYPE;\n\nfunction isBitVectorType(type) {\n  return (0, _type.isTypeOf)(type, BITVECTOR_TYPE);\n}\n\nclass BitVectorType extends _vector.BasicVectorType {\n  constructor(options) {\n    super(_objectSpread({\n      elementType: _basic.booleanType\n    }, options));\n\n    this._typeSymbols.add(BITVECTOR_TYPE);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_getLength(value) {\n    return this.length;\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_getByteLength(value) {\n    return Math.ceil(this.length / 8);\n  } // eslint-disable-next-line @typescript-eslint/no-unused-vars\n\n\n  struct_getSerializedLength(value) {\n    return Math.ceil(this.length / 8);\n  }\n\n  getMaxSerializedLength() {\n    return this.struct_getSerializedLength(null);\n  }\n\n  getMinSerializedLength() {\n    return this.struct_getSerializedLength(null);\n  }\n\n  struct_getChunkCount(value) {\n    return Math.ceil(this.struct_getLength(value) / 256);\n  }\n\n  struct_getByte(value, index) {\n    const firstBitIndex = index * 8;\n    const lastBitIndex = Math.min(firstBitIndex + 7, value.length - 1);\n    let bitstring = \"0b\";\n\n    for (let i = lastBitIndex; i >= firstBitIndex; i--) {\n      bitstring += value[i] ? \"1\" : \"0\";\n    }\n\n    return Number(bitstring);\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n\n    if (end - start !== this.size(null)) {\n      throw new Error(\"Invalid bitvector: length not equal to vector length\");\n    }\n\n    const value = [];\n\n    for (let i = start; i < end - 1; i++) {\n      value.push(...(0, _byteArray.getByteBits)(data, i));\n    }\n\n    const lastBitLength = this.length % 8;\n\n    if (!lastBitLength) {\n      // vector takes up the whole byte, no need for checks\n      value.push(...(0, _byteArray.getByteBits)(data, end - 1));\n    } else {\n      const lastBits = (0, _byteArray.getByteBits)(data, end - 1);\n\n      if (lastBits.slice(lastBitLength).some(b => b)) {\n        throw new Error(\"Invalid bitvector: nonzero bits past length\");\n      }\n\n      value.push(...lastBits.slice(0, lastBitLength));\n    }\n\n    return value;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    const byteLength = this.struct_getByteLength(value);\n\n    for (let i = 0; i < byteLength; i++) {\n      output[offset + i] = this.struct_getByte(value, i);\n    }\n\n    return offset + byteLength;\n  }\n\n  struct_getRootAtChunkIndex(value, chunkIndex) {\n    const output = new Uint8Array(_constants.BYTES_PER_CHUNK);\n    const byteLength = Math.min(_constants.BYTES_PER_CHUNK, this.struct_getByteLength(value) - chunkIndex);\n    const byteOffset = chunkIndex * _constants.BYTES_PER_CHUNK;\n\n    for (let i = 0; i < byteLength; i++) {\n      output[i] = this.struct_getByte(value, i + byteOffset);\n    }\n\n    return output;\n  }\n\n  struct_convertFromJson(data) {\n    const bytes = (0, _byteArray.fromHexString)(data);\n    return this.fromBytes(bytes, 0, bytes.length);\n  }\n\n  struct_convertToJson(value) {\n    return (0, _byteArray.toHexString)(this.serialize(value));\n  }\n\n  tree_getByteLength(target) {\n    return Math.ceil(this.tree_getLength(target) / 8);\n  }\n\n  tree_getSerializedLength(target) {\n    return this.tree_getByteLength(target);\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    // mask last byte to ensure it doesn't go over length\n    const lastByte = data[end - 1]; // If the data len fits full bytes this check must be skipped.\n    // Otherwise we must ensure that the extra bits are set to zero.\n\n    const lastByteBitLen = this.length % 8;\n\n    if (lastByteBitLen > 0) {\n      const mask = 0xff << lastByteBitLen & 0xff;\n\n      if ((lastByte & mask) > 0) {\n        throw new Error(\"Invalid deserialized bitvector length\");\n      }\n    }\n\n    return super.tree_deserializeFromBytes(data, start, end);\n  }\n\n  getBitOffset(index) {\n    return index % 8;\n  }\n\n  getChunkOffset(index) {\n    return Math.floor(index % 256 / 8);\n  }\n\n  getChunkIndex(index) {\n    return Math.floor(index / 256);\n  }\n\n  tree_getChunkCount(target) {\n    return Math.ceil(this.tree_getLength(target) / 256);\n  }\n\n  *tree_iterateValues(target) {\n    const length = this.tree_getLength(target);\n    const chunkCount = this.tree_getChunkCount(target);\n    const nodeIterator = target.iterateNodesAtDepth(this.getChunkDepth(), 0, chunkCount);\n    let i = 0;\n\n    for (const node of nodeIterator) {\n      const chunk = node.root;\n\n      for (let j = 0; j < 256 && i < length; i++, j++) {\n        const byte = chunk[this.getChunkOffset(i)];\n        yield !!(byte & 1 << this.getBitOffset(i));\n      }\n    }\n  }\n\n  tree_getValueAtIndex(target, index) {\n    const chunk = this.tree_getRootAtChunkIndex(target, this.getChunkIndex(index));\n    const byte = chunk[this.getChunkOffset(index)];\n    return !!(byte & 1 << this.getBitOffset(index));\n  }\n\n  tree_setProperty(target, property, value) {\n    const chunkGindex = this.getGindexAtChunkIndex(this.getChunkIndex(property));\n    const chunk = new Uint8Array(32);\n    chunk.set(target.getRoot(chunkGindex));\n    const byteOffset = this.getChunkOffset(property);\n\n    if (value) {\n      chunk[byteOffset] |= 1 << this.getBitOffset(property);\n    } else {\n      chunk[byteOffset] &= 0xff ^ 1 << this.getBitOffset(property);\n    }\n\n    target.setRoot(chunkGindex, chunk);\n    return true;\n  }\n\n  getMaxChunkCount() {\n    return Math.ceil(this.length / 256);\n  }\n\n}\n\nexports.BitVectorType = BitVectorType;\n//# sourceMappingURL=bitVector.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isBitListType = isBitListType;\nexports.BitListType = exports.BITLIST_TYPE = void 0;\n\nvar _list = require(\"./list\");\n\nvar _basic = require(\"../basic\");\n\nvar _type = require(\"../type\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nvar _constants = require(\"../../util/constants\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst BITLIST_TYPE = Symbol.for(\"ssz/BitListType\");\nexports.BITLIST_TYPE = BITLIST_TYPE;\n\nfunction isBitListType(type) {\n  return (0, _type.isTypeOf)(type, BITLIST_TYPE);\n}\n\nclass BitListType extends _list.BasicListType {\n  constructor(options) {\n    super(_objectSpread({\n      elementType: _basic.booleanType\n    }, options));\n\n    this._typeSymbols.add(BITLIST_TYPE);\n  }\n\n  struct_getByte(value, index) {\n    const firstBitIndex = index * 8;\n    const lastBitIndex = Math.min(firstBitIndex + 7, value.length - 1);\n    let bitstring = \"0b\";\n\n    for (let i = lastBitIndex; i >= firstBitIndex; i--) {\n      bitstring += value[i] ? \"1\" : \"0\";\n    }\n\n    return Number(bitstring);\n  }\n\n  struct_getLength(value) {\n    return value.length;\n  }\n\n  struct_getByteLength(value) {\n    return Math.ceil(value.length / 8);\n  }\n\n  struct_getSerializedLength(value) {\n    if (value.length % 8 === 0) {\n      return this.struct_getByteLength(value) + 1;\n    } else {\n      return this.struct_getByteLength(value);\n    }\n  }\n\n  getMaxSerializedLength() {\n    return Math.ceil(this.limit / 8) + 1;\n  }\n\n  getMinSerializedLength() {\n    return 1;\n  }\n\n  struct_getChunkCount(value) {\n    return Math.ceil(this.struct_getLength(value) / 256);\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    const value = [];\n\n    const toBool = c => c === \"1\" ? true : false;\n\n    for (let i = start; i < end - 1; i++) {\n      let bitstring = data[i].toString(2);\n      bitstring = \"0\".repeat(8 - bitstring.length) + bitstring;\n      value.push(...Array.prototype.map.call(bitstring, toBool).reverse());\n    }\n\n    const lastByte = data[end - 1];\n\n    if (lastByte === 0) {\n      throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n    }\n\n    if (lastByte === 1) {\n      return value;\n    }\n\n    const lastBits = Array.prototype.map.call(lastByte.toString(2), toBool).reverse();\n    const last1 = lastBits.lastIndexOf(true);\n    value.push(...lastBits.slice(0, last1));\n\n    if (value.length > this.limit) {\n      throw new Error(\"Invalid deserialized bitlist, length greater than limit\");\n    }\n\n    return value;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    const byteLength = this.struct_getByteLength(value);\n\n    for (let i = 0; i < byteLength; i++) {\n      output[offset + i] = this.struct_getByte(value, i);\n    }\n\n    const newOffset = offset + byteLength;\n\n    if (value.length % 8 === 0) {\n      output[newOffset] = 1;\n      return newOffset + 1;\n    } else {\n      output[newOffset - 1] |= 1 << value.length % 8;\n      return newOffset;\n    }\n  }\n\n  struct_getRootAtChunkIndex(value, chunkIndex) {\n    const output = new Uint8Array(_constants.BYTES_PER_CHUNK);\n    const byteLength = Math.min(_constants.BYTES_PER_CHUNK, this.struct_getByteLength(value) - chunkIndex);\n    const byteOffset = chunkIndex * _constants.BYTES_PER_CHUNK;\n\n    for (let i = 0; i < byteLength; i++) {\n      output[i] = this.struct_getByte(value, i + byteOffset);\n    }\n\n    return output;\n  }\n\n  struct_convertFromJson(data) {\n    const bytes = (0, _byteArray.fromHexString)(data);\n    return this.struct_deserializeFromBytes(bytes, 0, bytes.length);\n  }\n\n  struct_convertToJson(value) {\n    return (0, _byteArray.toHexString)(this.serialize(value));\n  }\n\n  tree_getByteLength(target) {\n    return Math.ceil(this.tree_getLength(target) / 8);\n  }\n\n  tree_getSerializedLength(target) {\n    const bitLength = this.tree_getLength(target);\n\n    if (bitLength % 8 === 0) {\n      return this.tree_getByteLength(target) + 1;\n    } else {\n      return this.tree_getByteLength(target);\n    }\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const lastByte = data[end - 1];\n\n    if (lastByte === 0) {\n      throw new Error(\"Invalid deserialized bitlist, padding bit required\");\n    }\n\n    if (lastByte === 1) {\n      const target = super.tree_deserializeFromBytes(data, start, end - 1);\n      const length = (end - start - 1) * 8;\n      this.tree_setLength(target, length);\n      return target;\n    } // the last byte is > 1, so a padding bit will exist in the last byte and need to be removed\n\n\n    const target = super.tree_deserializeFromBytes(data, start, end);\n    const lastGindex = this.getGindexAtChunkIndex(Math.ceil((end - start) / 32) - 1); // copy chunk into new memory\n\n    const lastChunk = new Uint8Array(32);\n    lastChunk.set(target.getRoot(lastGindex));\n    const lastChunkByte = (end - start) % 32 - 1; // mask lastChunkByte\n\n    const lastByteBitLength = lastByte.toString(2).length - 1;\n    const length = (end - start - 1) * 8 + lastByteBitLength;\n    const mask = 0xff >> 8 - lastByteBitLength;\n    lastChunk[lastChunkByte] &= mask;\n    target.setRoot(lastGindex, lastChunk);\n    this.tree_setLength(target, length);\n    return target;\n  }\n\n  tree_serializeToBytes(target, output, offset) {\n    const sizeNoPadding = this.tree_getByteLength(target);\n    const fullChunkCount = Math.floor(sizeNoPadding / 32);\n    const remainder = sizeNoPadding % 32;\n    let i = 0;\n\n    if (fullChunkCount > 0) {\n      for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), 0, fullChunkCount)) {\n        output.set(node.root, offset + i * 32);\n        i++;\n      }\n    }\n\n    if (remainder) {\n      output.set(this.tree_getRootAtChunkIndex(target, fullChunkCount).slice(0, remainder), offset + i * 32);\n    }\n\n    const bitLength = this.tree_getLength(target);\n    const size = this.tree_getSerializedLength(target);\n    const newOffset = offset + size; // set padding bit\n\n    output[newOffset - 1] |= 1 << bitLength % 8;\n    return newOffset;\n  }\n\n  getBitOffset(index) {\n    return index % 8;\n  }\n\n  getChunkOffset(index) {\n    return Math.floor(index % 256 / 8);\n  }\n\n  getChunkIndex(index) {\n    return Math.floor(index / 256);\n  }\n\n  tree_getChunkCount(target) {\n    return Math.ceil(this.tree_getLength(target) / 256);\n  }\n\n  *tree_iterateValues(target) {\n    const length = this.tree_getLength(target);\n    const chunkCount = this.tree_getChunkCount(target);\n    const nodeIterator = target.iterateNodesAtDepth(this.getChunkDepth(), 0, chunkCount);\n    let i = 0;\n\n    for (const node of nodeIterator) {\n      const chunk = node.root;\n\n      for (let j = 0; j < 256 && i < length; i++, j++) {\n        const byte = chunk[this.getChunkOffset(i)];\n        yield !!(byte & 1 << this.getBitOffset(i));\n      }\n    }\n  }\n\n  tree_getValueAtIndex(target, index) {\n    const chunk = this.tree_getRootAtChunkIndex(target, this.getChunkIndex(index));\n    const byte = chunk[this.getChunkOffset(index)];\n    return !!(byte & 1 << this.getBitOffset(index));\n  }\n\n  tree_setValueAtIndex(target, property, value, expand = false) {\n    const chunkGindex = this.getGindexAtChunkIndex(this.getChunkIndex(property));\n    const chunk = new Uint8Array(32);\n    chunk.set(target.getRoot(chunkGindex));\n    const byteOffset = this.getChunkOffset(property);\n\n    if (value) {\n      chunk[byteOffset] |= 1 << this.getBitOffset(property);\n    } else {\n      chunk[byteOffset] &= 0xff ^ 1 << this.getBitOffset(property);\n    }\n\n    target.setRoot(chunkGindex, chunk, expand);\n    return true;\n  }\n\n  getMaxChunkCount() {\n    return Math.ceil(this.limit / 256);\n  }\n\n}\n\nexports.BitListType = BitListType;\n//# sourceMappingURL=bitList.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isRootType = isRootType;\nexports.RootType = exports.ROOT_TYPE = void 0;\n\nvar _byteVector = require(\"./byteVector\");\n\nvar _type = require(\"../type\");\n\nvar _backings = require(\"../../backings\");\n\nvar _byteArray = require(\"../../util/byteArray\");\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst ROOT_TYPE = Symbol.for(\"ssz/RootType\");\nexports.ROOT_TYPE = ROOT_TYPE;\n\nfunction isRootType(type) {\n  return (0, _type.isTypeOf)(type, ROOT_TYPE);\n}\n\nfunction convertRootToUint8Array(value) {\n  if (value instanceof Uint8Array) {\n    return value;\n  } else if ((0, _backings.isTreeBacked)(value)) {\n    return value.tree.root;\n  } else if (Array.isArray(value)) {\n    return new Uint8Array(value);\n  } else {\n    throw new Error(\"Unable to convert root to Uint8Array: not Uint8Array, tree-backed, or Array\");\n  }\n}\n\nclass RootType extends _byteVector.ByteVectorType {\n  constructor(options) {\n    super({\n      length: 32\n    });\n\n    _defineProperty(this, \"_expandedType\", void 0);\n\n    this._expandedType = options.expandedType;\n\n    this._typeSymbols.add(ROOT_TYPE);\n  }\n\n  get expandedType() {\n    if (typeof this._expandedType === \"function\") {\n      this._expandedType = this._expandedType();\n    }\n\n    return this._expandedType;\n  }\n\n  struct_equals(value1, value2) {\n    return (0, _byteArray.byteArrayEquals)(convertRootToUint8Array(value1), convertRootToUint8Array(value2));\n  }\n\n  equals(value1, value2) {\n    return this.struct_equals(value1, value2);\n  }\n\n}\n\nexports.RootType = RootType;\n//# sourceMappingURL=root.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.isContainerType = isContainerType;\nexports.ContainerType = exports.CONTAINER_TYPE = void 0;\n\nvar _abstract = require(\"./abstract\");\n\nvar _type = require(\"../type\");\n\nvar _persistentMerkleTree = require(\"@chainsafe/persistent-merkle-tree\");\n\nvar _errorPath = require(\"../../util/errorPath\");\n\nvar _json = require(\"../../util/json\");\n\nvar _treeValue = require(\"../../backings/tree/treeValue\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst CONTAINER_TYPE = Symbol.for(\"ssz/ContainerType\");\nexports.CONTAINER_TYPE = CONTAINER_TYPE;\n\nfunction isContainerType(type) {\n  return (0, _type.isTypeOf)(type, CONTAINER_TYPE);\n}\n\nclass ContainerType extends _abstract.CompositeType {\n  // ES6 ensures key order is chronological\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  constructor(options) {\n    super();\n\n    _defineProperty(this, \"fields\", void 0);\n\n    this.fields = _objectSpread({}, options.fields);\n\n    this._typeSymbols.add(CONTAINER_TYPE);\n  }\n\n  struct_defaultValue() {\n    const obj = {};\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      obj[fieldName] = fieldType.struct_defaultValue();\n    }\n\n    return obj;\n  }\n\n  struct_getSerializedLength(value) {\n    let s = 0;\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      if (fieldType.hasVariableSerializedLength()) {\n        s += fieldType.struct_getSerializedLength(value[fieldName]) + 4;\n      } else {\n        s += fieldType.struct_getSerializedLength(null);\n      }\n    }\n\n    return s;\n  }\n\n  getMaxSerializedLength() {\n    const fixedSize = Object.values(this.fields).reduce((total, fieldType) => total + (fieldType.hasVariableSerializedLength() ? 4 : fieldType.getMaxSerializedLength()), 0);\n    const maxDynamicSize = Object.values(this.fields).reduce((total, fieldType) => total += fieldType.hasVariableSerializedLength() ? fieldType.getMaxSerializedLength() : 0, 0);\n    return fixedSize + maxDynamicSize;\n  }\n\n  getMinSerializedLength() {\n    const fixedSize = Object.values(this.fields).reduce((total, fieldType) => total + (fieldType.hasVariableSerializedLength() ? 4 : fieldType.getMinSerializedLength()), 0);\n    const minDynamicSize = Object.values(this.fields).reduce((total, fieldType) => total += fieldType.hasVariableSerializedLength() ? fieldType.getMinSerializedLength() : 0, 0);\n    return fixedSize + minDynamicSize;\n  }\n\n  struct_assertValidValue(value) {\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      try {\n        // @ts-ignore\n        fieldType.struct_assertValidValue(value[fieldName]);\n      } catch (e) {\n        throw new Error(\"Invalid field \".concat(fieldName, \": \").concat(e.message));\n      }\n    }\n  }\n\n  struct_equals(value1, value2) {\n    this.struct_assertValidValue(value1);\n    this.struct_assertValidValue(value2);\n    return Object.entries(this.fields).every(([fieldName, fieldType]) => {\n      return fieldType.struct_equals(value1[fieldName], value2[fieldName]);\n    });\n  }\n\n  struct_clone(value) {\n    const newValue = {};\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      newValue[fieldName] = fieldType.struct_clone(value[fieldName]);\n    }\n\n    return newValue;\n  }\n\n  struct_deserializeFromBytes(data, start, end) {\n    this.bytes_validate(data, start, end);\n    let currentIndex = start;\n    let nextIndex = currentIndex;\n    const value = {}; // Since variable-sized values can be interspersed with fixed-sized values, we precalculate\n    // the offset indices so we can more easily deserialize the fields in once pass\n    // first we get the fixed sizes\n\n    const fixedSizes = Object.values(this.fields).map(fieldType => !fieldType.hasVariableSerializedLength() && fieldType.struct_getSerializedLength(null)); // with the fixed sizes, we can read the offsets, and store for our single pass\n\n    const offsets = [];\n    const fixedSection = new DataView(data.buffer, data.byteOffset);\n    const fixedEnd = fixedSizes.reduce((index, size) => {\n      if (size === false) {\n        offsets.push(start + fixedSection.getUint32(index, true));\n        return index + 4;\n      } else {\n        return index + size;\n      }\n    }, start);\n    offsets.push(end);\n\n    if (fixedEnd !== offsets[0]) {\n      throw new Error(\"Not all variable bytes consumed\");\n    }\n\n    let offsetIndex = 0;\n\n    for (const [i, [fieldName, fieldType]] of Object.entries(this.fields).entries()) {\n      try {\n        const fieldSize = fixedSizes[i];\n\n        if (fieldSize === false) {\n          // variable-sized field\n          if (offsets[offsetIndex] > end) {\n            throw new Error(\"Offset out of bounds\");\n          }\n\n          if (offsets[offsetIndex] > offsets[offsetIndex + 1]) {\n            throw new Error(\"Offsets must be increasing\");\n          }\n\n          value[fieldName] = fieldType.struct_deserializeFromBytes(data, offsets[offsetIndex], offsets[offsetIndex + 1]);\n          offsetIndex++;\n          currentIndex += 4;\n        } else {\n          // fixed-sized field\n          nextIndex = currentIndex + fieldSize;\n          value[fieldName] = fieldType.struct_deserializeFromBytes(data, currentIndex, nextIndex);\n          currentIndex = nextIndex;\n        }\n      } catch (e) {\n        throw new _errorPath.SszErrorPath(e, fieldName);\n      }\n    }\n\n    if (offsets.length > 1) {\n      if (offsetIndex !== offsets.length - 1) {\n        throw new Error(\"Not all variable bytes consumed\");\n      }\n\n      if (currentIndex !== offsets[0]) {\n        throw new Error(\"Not all fixed bytes consumed\");\n      }\n    } else {\n      if (currentIndex !== end) {\n        throw new Error(\"Not all fixed bytes consumed\");\n      }\n    }\n\n    return value;\n  }\n\n  struct_serializeToBytes(value, output, offset) {\n    let variableIndex = offset + Object.values(this.fields).reduce((total, fieldType) => total + (fieldType.hasVariableSerializedLength() ? 4 : fieldType.struct_getSerializedLength(null)), 0);\n    const fixedSection = new DataView(output.buffer, output.byteOffset + offset);\n    let fixedIndex = offset;\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      if (fieldType.hasVariableSerializedLength()) {\n        // write offset\n        fixedSection.setUint32(fixedIndex - offset, variableIndex - offset, true);\n        fixedIndex += 4; // write serialized element to variable section\n\n        variableIndex = fieldType.toBytes(value[fieldName], output, variableIndex);\n      } else {\n        fixedIndex = fieldType.toBytes(value[fieldName], output, fixedIndex);\n      }\n    }\n\n    return variableIndex;\n  }\n\n  struct_getRootAtChunkIndex(value, index) {\n    const fieldName = Object.keys(this.fields)[index];\n    const fieldType = this.fields[fieldName];\n    return fieldType.struct_hashTreeRoot(value[fieldName]);\n  }\n\n  struct_convertFromJson(data, options) {\n    if (typeof data !== \"object\") {\n      throw new Error(\"Invalid JSON container: expected Object\");\n    }\n\n    const value = {};\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      const expectedCase = options ? options.case : null;\n      const expectedFieldName = (0, _json.toExpectedCase)(fieldName, expectedCase);\n\n      if (data[expectedFieldName] === undefined) {\n        throw new Error(\"Invalid JSON container field: expected field \".concat(expectedFieldName, \" is undefined\"));\n      }\n\n      value[fieldName] = fieldType.fromJson(data[expectedFieldName], options);\n    }\n\n    return value;\n  }\n\n  struct_convertToJson(value, options) {\n    const data = {};\n    const expectedCase = options ? options.case : null;\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      data[(0, _json.toExpectedCase)(fieldName, expectedCase)] = fieldType.toJson(value[fieldName], options);\n    }\n\n    return data;\n  }\n\n  struct_convertToTree(value) {\n    if ((0, _treeValue.isTreeBacked)(value)) return value.tree.clone();\n    return new _persistentMerkleTree.Tree((0, _persistentMerkleTree.subtreeFillToContents)(Object.entries(this.fields).map(([fieldName, fieldType]) => {\n      if (!(0, _abstract.isCompositeType)(fieldType)) {\n        const chunk = new Uint8Array(32);\n        fieldType.toBytes(value[fieldName], chunk, 0);\n        return new _persistentMerkleTree.LeafNode(chunk);\n      } else {\n        return fieldType.struct_convertToTree(value[fieldName]).rootNode;\n      }\n    }), this.getChunkDepth()));\n  }\n\n  struct_getPropertyNames() {\n    return Object.keys(this.fields);\n  }\n\n  bytes_getVariableOffsets(target) {\n    const types = Object.values(this.fields);\n    const offsets = []; // variable-sized values can be interspersed with fixed-sized values\n    // variable-sized value indices are serialized as offsets, indices deeper in the byte array\n\n    let currentIndex = 0;\n    let nextIndex = 0;\n    const fixedSection = new DataView(target.buffer, target.byteOffset);\n    const fixedOffsets = [];\n    const variableOffsets = [];\n    let variableIndex = 0;\n\n    for (const [i, fieldType] of types.entries()) {\n      if (fieldType.hasVariableSerializedLength()) {\n        const offset = fixedSection.getUint32(currentIndex, true);\n\n        if (offset > target.length) {\n          throw new Error(\"Offset out of bounds\");\n        }\n\n        variableOffsets.push(offset);\n        currentIndex = nextIndex = currentIndex + 4;\n        variableIndex++;\n      } else {\n        nextIndex = currentIndex + fieldType.struct_getSerializedLength(null);\n        fixedOffsets[i] = [currentIndex, nextIndex];\n        currentIndex = nextIndex;\n      }\n    }\n\n    variableOffsets.push(target.length);\n    variableIndex = 0;\n\n    for (const [i, fieldType] of types.entries()) {\n      if (fieldType.hasVariableSerializedLength()) {\n        if (variableOffsets[variableIndex] > variableOffsets[variableIndex + 1]) {\n          throw new Error(\"Offsets must be increasing\");\n        }\n\n        offsets.push([variableOffsets[variableIndex], variableOffsets[variableIndex + 1]]);\n        variableIndex++;\n      } else {\n        offsets.push(fixedOffsets[i]);\n      }\n    }\n\n    return offsets;\n  }\n\n  tree_defaultNode() {\n    if (!this._defaultNode) {\n      this._defaultNode = (0, _persistentMerkleTree.subtreeFillToContents)(Object.values(this.fields).map(fieldType => {\n        if (!(0, _abstract.isCompositeType)(fieldType)) {\n          return (0, _persistentMerkleTree.zeroNode)(0);\n        } else {\n          return fieldType.tree_defaultNode();\n        }\n      }), this.getChunkDepth());\n    }\n\n    return this._defaultNode;\n  }\n\n  tree_convertToStruct(target) {\n    const value = {};\n\n    for (const [i, [fieldName, fieldType]] of Object.entries(this.fields).entries()) {\n      if (!(0, _abstract.isCompositeType)(fieldType)) {\n        const chunk = this.tree_getRootAtChunkIndex(target, i);\n        value[fieldName] = fieldType.struct_deserializeFromBytes(chunk, 0);\n      } else {\n        const subtree = this.tree_getSubtreeAtChunkIndex(target, i);\n        value[fieldName] = fieldType.tree_convertToStruct(subtree);\n      }\n    }\n\n    return value;\n  }\n\n  tree_getSerializedLength(target) {\n    let s = 0;\n\n    for (const [i, fieldType] of Object.values(this.fields).entries()) {\n      if (fieldType.hasVariableSerializedLength()) {\n        s += fieldType.tree_getSerializedLength(this.tree_getSubtreeAtChunkIndex(target, i)) + 4;\n      } else {\n        s += fieldType.struct_getSerializedLength(null);\n      }\n    }\n\n    return s;\n  }\n\n  tree_deserializeFromBytes(data, start, end) {\n    const target = this.tree_defaultValue();\n    const offsets = this.bytes_getVariableOffsets(new Uint8Array(data.buffer, data.byteOffset + start, end - start));\n\n    for (const [i, fieldType] of Object.values(this.fields).entries()) {\n      const [currentOffset, nextOffset] = offsets[i];\n\n      if (!(0, _abstract.isCompositeType)(fieldType)) {\n        // view of the chunk, shared buffer from `data`\n        const dataChunk = new Uint8Array(data.buffer, data.byteOffset + start + currentOffset, nextOffset - currentOffset);\n        const chunk = new Uint8Array(32); // copy chunk into new memory\n\n        chunk.set(dataChunk);\n        this.tree_setRootAtChunkIndex(target, i, chunk);\n      } else {\n        this.tree_setSubtreeAtChunkIndex(target, i, fieldType.tree_deserializeFromBytes(data, start + currentOffset, start + nextOffset));\n      }\n    }\n\n    return target;\n  }\n\n  tree_serializeToBytes(target, output, offset) {\n    let variableIndex = offset + Object.values(this.fields).reduce((total, fieldType) => total + (fieldType.hasVariableSerializedLength() ? 4 : fieldType.struct_getSerializedLength(null)), 0);\n    const fixedSection = new DataView(output.buffer, output.byteOffset + offset);\n    let fixedIndex = offset;\n    let i = 0;\n    const fieldTypes = Object.values(this.fields);\n\n    for (const node of target.iterateNodesAtDepth(this.getChunkDepth(), i, fieldTypes.length)) {\n      const fieldType = fieldTypes[i];\n\n      if (!(0, _abstract.isCompositeType)(fieldType)) {\n        const s = fieldType.struct_getSerializedLength();\n        output.set(node.root.slice(0, s), fixedIndex);\n        fixedIndex += s;\n      } else if (fieldType.hasVariableSerializedLength()) {\n        // write offset\n        fixedSection.setUint32(fixedIndex - offset, variableIndex - offset, true);\n        fixedIndex += 4; // write serialized element to variable section\n\n        variableIndex = fieldType.tree_serializeToBytes(new _persistentMerkleTree.Tree(node), output, variableIndex);\n      } else {\n        fixedIndex = fieldType.tree_serializeToBytes(new _persistentMerkleTree.Tree(node), output, fixedIndex);\n      }\n\n      i++;\n    }\n\n    return variableIndex;\n  }\n\n  getPropertyGindex(prop) {\n    const chunkIndex = Object.keys(this.fields).findIndex(fieldName => fieldName === prop);\n\n    if (chunkIndex === -1) {\n      throw new Error(\"Invalid container field name: \".concat(String(prop)));\n    }\n\n    return this.getGindexAtChunkIndex(chunkIndex);\n  }\n\n  getPropertyType(prop) {\n    const type = this.fields[prop];\n\n    if (!type) {\n      throw new Error(\"Invalid container field name: \".concat(String(prop)));\n    }\n\n    return type;\n  }\n\n  tree_getPropertyNames() {\n    return Object.keys(this.fields);\n  }\n\n  tree_getProperty(target, prop) {\n    const chunkIndex = Object.keys(this.fields).findIndex(fieldName => fieldName === prop);\n\n    if (chunkIndex === -1) {\n      return undefined;\n    }\n\n    const fieldType = this.fields[prop];\n\n    if (!(0, _abstract.isCompositeType)(fieldType)) {\n      const chunk = this.tree_getRootAtChunkIndex(target, chunkIndex);\n      return fieldType.struct_deserializeFromBytes(chunk, 0);\n    } else {\n      return this.tree_getSubtreeAtChunkIndex(target, chunkIndex);\n    }\n  }\n\n  tree_setProperty(target, property, value) {\n    const chunkIndex = Object.keys(this.fields).findIndex(fieldName => fieldName === property);\n\n    if (chunkIndex === -1) {\n      throw new Error(\"Invalid container field name\");\n    }\n\n    const chunkGindex = this.getGindexAtChunkIndex(chunkIndex);\n    const fieldType = this.fields[property];\n\n    if (!(0, _abstract.isCompositeType)(fieldType)) {\n      const chunk = new Uint8Array(32);\n      fieldType.struct_serializeToBytes(value, chunk, 0);\n      target.setRoot(chunkGindex, chunk);\n      return true;\n    } else {\n      target.setSubtree(chunkGindex, value);\n      return true;\n    }\n  }\n\n  tree_deleteProperty(target, prop) {\n    const chunkIndex = Object.keys(this.fields).findIndex(fieldName => fieldName === prop);\n\n    if (chunkIndex === -1) {\n      throw new Error(\"Invalid container field name\");\n    }\n\n    const fieldType = this.fields[prop];\n\n    if (!(0, _abstract.isCompositeType)(fieldType)) {\n      return this.tree_setProperty(target, prop, fieldType.struct_defaultValue());\n    } else {\n      return this.tree_setProperty(target, prop, fieldType.tree_defaultValue());\n    }\n  }\n\n  *tree_iterateValues(target) {\n    const gindexIterator = (0, _persistentMerkleTree.iterateAtDepth)(this.getChunkDepth(), BigInt(0), BigInt(this.getMaxChunkCount()))[Symbol.iterator]();\n\n    for (const propType of Object.values(this.fields)) {\n      const {\n        value,\n        done\n      } = gindexIterator.next();\n\n      if (done) {\n        return;\n      } else {\n        if (!(0, _abstract.isCompositeType)(propType)) {\n          yield propType.struct_deserializeFromBytes(value.root, 0);\n        } else {\n          yield target.getSubtree(value);\n        }\n      }\n    }\n  }\n\n  *tree_readonlyIterateValues(target) {\n    const chunkIterator = target.iterateNodesAtDepth(this.getChunkDepth(), 0, this.getMaxChunkCount());\n\n    for (const propType of Object.values(this.fields)) {\n      const {\n        value,\n        done\n      } = chunkIterator.next();\n\n      if (done) {\n        return;\n      } else {\n        if (!(0, _abstract.isCompositeType)(propType)) {\n          yield propType.struct_deserializeFromBytes(value.root, 0);\n        } else {\n          yield new _persistentMerkleTree.Tree(value);\n        }\n      }\n    }\n  }\n\n  hasVariableSerializedLength() {\n    return Object.values(this.fields).some(fieldType => fieldType.hasVariableSerializedLength());\n  }\n\n  getMaxChunkCount() {\n    return Object.keys(this.fields).length;\n  }\n\n  tree_getLeafGindices(target, root = BigInt(1)) {\n    const gindices = [];\n\n    for (const [fieldName, fieldType] of Object.entries(this.fields)) {\n      const fieldGindex = this.getPropertyGindex(fieldName);\n      const extendedFieldGindex = (0, _persistentMerkleTree.concatGindices)([root, fieldGindex]);\n\n      if (!(0, _abstract.isCompositeType)(fieldType)) {\n        gindices.push(extendedFieldGindex);\n      } else {\n        if (fieldType.hasVariableSerializedLength()) {\n          if (!target) {\n            throw new Error(\"variable type requires tree argument to get leaves\");\n          }\n\n          gindices.push(...fieldType.tree_getLeafGindices(target.getSubtree(fieldGindex), extendedFieldGindex));\n        } else {\n          gindices.push(...fieldType.tree_getLeafGindices(undefined, extendedFieldGindex));\n        }\n      }\n    }\n\n    return gindices;\n  }\n\n}\n\nexports.ContainerType = ContainerType;\n//# sourceMappingURL=container.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.toExpectedCase = toExpectedCase;\n\nvar _case = _interopRequireDefault(require(\"case\"));\n\nfunction _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { default: obj }; }\n\nfunction toExpectedCase(value, expectedCase = \"camel\") {\n  switch (expectedCase) {\n    case \"camel\":\n      return _case.default.camel(value);\n\n    case \"snake\":\n      return _case.default.snake(value);\n\n    default:\n      return value;\n  }\n}\n//# sourceMappingURL=json.js.map","/*! Case - v1.6.2 - 2020-03-24\n* Copyright (c) 2020 Nathan Bubna; Licensed MIT, GPL */\n(function() {\n    \"use strict\";\n    var unicodes = function(s, prefix) {\n        prefix = prefix || '';\n        return s.replace(/(^|-)/g, '$1\\\\u'+prefix).replace(/,/g, '\\\\u'+prefix);\n    },\n    basicSymbols = unicodes('20-26,28-2F,3A-40,5B-60,7B-7E,A0-BF,D7,F7', '00'),\n    baseLowerCase = 'a-z'+unicodes('DF-F6,F8-FF', '00'),\n    baseUpperCase = 'A-Z'+unicodes('C0-D6,D8-DE', '00'),\n    improperInTitle = 'A|An|And|As|At|But|By|En|For|If|In|Of|On|Or|The|To|Vs?\\\\.?|Via',\n    regexps = function(symbols, lowers, uppers, impropers) {\n        symbols = symbols || basicSymbols;\n        lowers = lowers || baseLowerCase;\n        uppers = uppers || baseUpperCase;\n        impropers = impropers || improperInTitle;\n        return {\n            capitalize: new RegExp('(^|['+symbols+'])(['+lowers+'])', 'g'),\n            pascal: new RegExp('(^|['+symbols+'])+(['+lowers+uppers+'])', 'g'),\n            fill: new RegExp('['+symbols+']+(.|$)','g'),\n            sentence: new RegExp('(^\\\\s*|[\\\\?\\\\!\\\\.]+\"?\\\\s+\"?|,\\\\s+\")(['+lowers+'])', 'g'),\n            improper: new RegExp('\\\\b('+impropers+')\\\\b', 'g'),\n            relax: new RegExp('([^'+uppers+'])(['+uppers+']*)(['+uppers+'])(?=[^'+uppers+']|$)', 'g'),\n            upper: new RegExp('^[^'+lowers+']+$'),\n            hole: /[^\\s]\\s[^\\s]/,\n            apostrophe: /'/g,\n            room: new RegExp('['+symbols+']')\n        };\n    },\n    re = regexps(),\n    _ = {\n        re: re,\n        unicodes: unicodes,\n        regexps: regexps,\n        types: [],\n        up: String.prototype.toUpperCase,\n        low: String.prototype.toLowerCase,\n        cap: function(s) {\n            return _.up.call(s.charAt(0))+s.slice(1);\n        },\n        decap: function(s) {\n            return _.low.call(s.charAt(0))+s.slice(1);\n        },\n        deapostrophe: function(s) {\n            return s.replace(re.apostrophe, '');\n        },\n        fill: function(s, fill, deapostrophe) {\n            if (fill != null) {\n                s = s.replace(re.fill, function(m, next) {\n                    return next ? fill + next : '';\n                });\n            }\n            if (deapostrophe) {\n                s = _.deapostrophe(s);\n            }\n            return s;\n        },\n        prep: function(s, fill, pascal, upper) {\n            s = s == null ? '' : s + '';// force to string\n            if (!upper && re.upper.test(s)) {\n                s = _.low.call(s);\n            }\n            if (!fill && !re.hole.test(s)) {\n                var holey = _.fill(s, ' ');\n                if (re.hole.test(holey)) {\n                    s = holey;\n                }\n            }\n            if (!pascal && !re.room.test(s)) {\n                s = s.replace(re.relax, _.relax);\n            }\n            return s;\n        },\n        relax: function(m, before, acronym, caps) {\n            return before + ' ' + (acronym ? acronym+' ' : '') + caps;\n        }\n    },\n    Case = {\n        _: _,\n        of: function(s) {\n            for (var i=0,m=_.types.length; i<m; i++) {\n                if (Case[_.types[i]].apply(Case, arguments) === s){ return _.types[i]; }\n            }\n        },\n        flip: function(s) {\n            return s.replace(/\\w/g, function(l) {\n                return (l == _.up.call(l) ? _.low : _.up).call(l);\n            });\n        },\n        random: function(s) {\n            return s.replace(/\\w/g, function(l) {\n                return (Math.round(Math.random()) ? _.up : _.low).call(l);\n            });\n        },\n        type: function(type, fn) {\n            Case[type] = fn;\n            _.types.push(type);\n        }\n    },\n    types = {\n        lower: function(s, fill, deapostrophe) {\n            return _.fill(_.low.call(_.prep(s, fill)), fill, deapostrophe);\n        },\n        snake: function(s) {\n            return Case.lower(s, '_', true);\n        },\n        constant: function(s) {\n            return Case.upper(s, '_', true);\n        },\n        camel: function(s) {\n            return _.decap(Case.pascal(s));\n        },\n        kebab: function(s) {\n            return Case.lower(s, '-', true);\n        },\n        upper: function(s, fill, deapostrophe) {\n            return _.fill(_.up.call(_.prep(s, fill, false, true)), fill, deapostrophe);\n        },\n        capital: function(s, fill, deapostrophe) {\n            return _.fill(_.prep(s).replace(re.capitalize, function(m, border, letter) {\n                return border+_.up.call(letter);\n            }), fill, deapostrophe);\n        },\n        header: function(s) {\n            return Case.capital(s, '-', true);\n        },\n        pascal: function(s) {\n            return _.fill(_.prep(s, false, true).replace(re.pascal, function(m, border, letter) {\n                return _.up.call(letter);\n            }), '', true);\n        },\n        title: function(s) {\n            return Case.capital(s).replace(re.improper, function(small, p, i, s) {\n                return i > 0 && i < s.lastIndexOf(' ') ? _.low.call(small) : small;\n            });\n        },\n        sentence: function(s, names, abbreviations) {\n            s = Case.lower(s).replace(re.sentence, function(m, prelude, letter) {\n                return prelude + _.up.call(letter);\n            });\n            if (names) {\n                names.forEach(function(name) {\n                    s = s.replace(new RegExp('\\\\b'+Case.lower(name)+'\\\\b', \"g\"), _.cap);\n                });\n            }\n            if (abbreviations) {\n                abbreviations.forEach(function(abbr) {\n                    s = s.replace(new RegExp('(\\\\b'+Case.lower(abbr)+'\\\\. +)(\\\\w)'), function(m, abbrAndSpace, letter) {\n                        return abbrAndSpace + _.low.call(letter);\n                    });\n                });\n            }\n            return s;\n        }\n    };\n\n    // TODO: Remove \"squish\" in a future breaking release.\n    types.squish = types.pascal;\n    \n    // Allow import default\n    Case.default = Case;\n\n    for (var type in types) {\n        Case.type(type, types[type]);\n    }\n    // export Case (AMD, commonjs, or global)\n    var define = typeof define === \"function\" ? define : function(){};\n    define(typeof module === \"object\" && module.exports ? module.exports = Case : this.Case = Case);\n\n}).call(this);\n","\"use strict\";\n//# sourceMappingURL=interface.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.Phase0Preset = void 0;\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\n/* eslint-disable @typescript-eslint/naming-convention */\nconst Number64 = new _ssz.NumberUintType({\n  byteLength: 8\n});\nconst BigInt64 = new _ssz.BigIntUintType({\n  byteLength: 8\n});\nconst Phase0Preset = new _ssz.ContainerType({\n  fields: {\n    // Misc\n    MAX_COMMITTEES_PER_SLOT: Number64,\n    TARGET_COMMITTEE_SIZE: Number64,\n    MAX_VALIDATORS_PER_COMMITTEE: Number64,\n    SHUFFLE_ROUND_COUNT: Number64,\n    HYSTERESIS_QUOTIENT: Number64,\n    HYSTERESIS_DOWNWARD_MULTIPLIER: Number64,\n    HYSTERESIS_UPWARD_MULTIPLIER: Number64,\n    // Fork choice\n    SAFE_SLOTS_TO_UPDATE_JUSTIFIED: Number64,\n    // Gwei Values\n    MIN_DEPOSIT_AMOUNT: BigInt64,\n    MAX_EFFECTIVE_BALANCE: BigInt64,\n    EFFECTIVE_BALANCE_INCREMENT: BigInt64,\n    // Time parameters\n    MIN_ATTESTATION_INCLUSION_DELAY: Number64,\n    SLOTS_PER_EPOCH: Number64,\n    MIN_SEED_LOOKAHEAD: Number64,\n    MAX_SEED_LOOKAHEAD: Number64,\n    EPOCHS_PER_ETH1_VOTING_PERIOD: Number64,\n    SLOTS_PER_HISTORICAL_ROOT: Number64,\n    MIN_EPOCHS_TO_INACTIVITY_PENALTY: Number64,\n    // State vector lengths\n    EPOCHS_PER_HISTORICAL_VECTOR: Number64,\n    EPOCHS_PER_SLASHINGS_VECTOR: Number64,\n    HISTORICAL_ROOTS_LIMIT: Number64,\n    VALIDATOR_REGISTRY_LIMIT: Number64,\n    // Reward and penalty quotients\n    BASE_REWARD_FACTOR: BigInt64,\n    WHISTLEBLOWER_REWARD_QUOTIENT: BigInt64,\n    PROPOSER_REWARD_QUOTIENT: BigInt64,\n    INACTIVITY_PENALTY_QUOTIENT: BigInt64,\n    MIN_SLASHING_PENALTY_QUOTIENT: BigInt64,\n    PROPORTIONAL_SLASHING_MULTIPLIER: BigInt64,\n    // Max operations per block\n    MAX_PROPOSER_SLASHINGS: Number64,\n    MAX_ATTESTER_SLASHINGS: Number64,\n    MAX_ATTESTATIONS: Number64,\n    MAX_DEPOSITS: Number64,\n    MAX_VOLUNTARY_EXITS: Number64\n  }\n});\nexports.Phase0Preset = Phase0Preset;\n//# sourceMappingURL=ssz.js.map","\"use strict\";\n//# sourceMappingURL=interface.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.AltairPreset = void 0;\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\n/* eslint-disable @typescript-eslint/naming-convention */\nconst Number64 = new _ssz.NumberUintType({\n  byteLength: 8\n});\nconst BigInt64 = new _ssz.BigIntUintType({\n  byteLength: 8\n});\nconst AltairPreset = new _ssz.ContainerType({\n  fields: {\n    SYNC_COMMITTEE_SIZE: Number64,\n    EPOCHS_PER_SYNC_COMMITTEE_PERIOD: Number64,\n    INACTIVITY_PENALTY_QUOTIENT_ALTAIR: BigInt64,\n    MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR: BigInt64,\n    PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR: BigInt64\n  }\n});\nexports.AltairPreset = AltairPreset;\n//# sourceMappingURL=ssz.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR = exports.MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR = exports.INACTIVITY_PENALTY_QUOTIENT_ALTAIR = exports.EPOCHS_PER_SYNC_COMMITTEE_PERIOD = exports.SYNC_COMMITTEE_SIZE = exports.MAX_VOLUNTARY_EXITS = exports.MAX_DEPOSITS = exports.MAX_ATTESTATIONS = exports.MAX_ATTESTER_SLASHINGS = exports.MAX_PROPOSER_SLASHINGS = exports.PROPORTIONAL_SLASHING_MULTIPLIER = exports.MIN_SLASHING_PENALTY_QUOTIENT = exports.INACTIVITY_PENALTY_QUOTIENT = exports.PROPOSER_REWARD_QUOTIENT = exports.WHISTLEBLOWER_REWARD_QUOTIENT = exports.BASE_REWARD_FACTOR = exports.VALIDATOR_REGISTRY_LIMIT = exports.HISTORICAL_ROOTS_LIMIT = exports.EPOCHS_PER_SLASHINGS_VECTOR = exports.EPOCHS_PER_HISTORICAL_VECTOR = exports.MIN_EPOCHS_TO_INACTIVITY_PENALTY = exports.SLOTS_PER_HISTORICAL_ROOT = exports.EPOCHS_PER_ETH1_VOTING_PERIOD = exports.MAX_SEED_LOOKAHEAD = exports.MIN_SEED_LOOKAHEAD = exports.SLOTS_PER_EPOCH = exports.MIN_ATTESTATION_INCLUSION_DELAY = exports.EFFECTIVE_BALANCE_INCREMENT = exports.MAX_EFFECTIVE_BALANCE = exports.MIN_DEPOSIT_AMOUNT = exports.SAFE_SLOTS_TO_UPDATE_JUSTIFIED = exports.HYSTERESIS_UPWARD_MULTIPLIER = exports.HYSTERESIS_DOWNWARD_MULTIPLIER = exports.HYSTERESIS_QUOTIENT = exports.SHUFFLE_ROUND_COUNT = exports.MAX_VALIDATORS_PER_COMMITTEE = exports.TARGET_COMMITTEE_SIZE = exports.MAX_COMMITTEES_PER_SLOT = exports.ACTIVE_PRESET = void 0;\n\nvar _preset = require(\"./preset\");\n\nvar _mainnet = require(\"./presets/mainnet\");\n\nvar _minimal = require(\"./presets/minimal\");\n\n// load in an \"active\" preset\nlet ACTIVE_PRESET;\nexports.ACTIVE_PRESET = ACTIVE_PRESET;\nlet preset;\n\nswitch (process.env.LODESTAR_PRESET) {\n  case _preset.PresetName.minimal:\n    exports.ACTIVE_PRESET = ACTIVE_PRESET = _preset.PresetName.minimal;\n    preset = _minimal.preset;\n    break;\n\n  case _preset.PresetName.mainnet:\n  default:\n    exports.ACTIVE_PRESET = ACTIVE_PRESET = _preset.PresetName.mainnet;\n    preset = _mainnet.preset;\n    break;\n}\n\nconst {\n  MAX_COMMITTEES_PER_SLOT,\n  TARGET_COMMITTEE_SIZE,\n  MAX_VALIDATORS_PER_COMMITTEE,\n  SHUFFLE_ROUND_COUNT,\n  HYSTERESIS_QUOTIENT,\n  HYSTERESIS_DOWNWARD_MULTIPLIER,\n  HYSTERESIS_UPWARD_MULTIPLIER,\n  SAFE_SLOTS_TO_UPDATE_JUSTIFIED,\n  MIN_DEPOSIT_AMOUNT,\n  MAX_EFFECTIVE_BALANCE,\n  EFFECTIVE_BALANCE_INCREMENT,\n  MIN_ATTESTATION_INCLUSION_DELAY,\n  SLOTS_PER_EPOCH,\n  MIN_SEED_LOOKAHEAD,\n  MAX_SEED_LOOKAHEAD,\n  EPOCHS_PER_ETH1_VOTING_PERIOD,\n  SLOTS_PER_HISTORICAL_ROOT,\n  MIN_EPOCHS_TO_INACTIVITY_PENALTY,\n  EPOCHS_PER_HISTORICAL_VECTOR,\n  EPOCHS_PER_SLASHINGS_VECTOR,\n  HISTORICAL_ROOTS_LIMIT,\n  VALIDATOR_REGISTRY_LIMIT,\n  BASE_REWARD_FACTOR,\n  WHISTLEBLOWER_REWARD_QUOTIENT,\n  PROPOSER_REWARD_QUOTIENT,\n  INACTIVITY_PENALTY_QUOTIENT,\n  MIN_SLASHING_PENALTY_QUOTIENT,\n  PROPORTIONAL_SLASHING_MULTIPLIER,\n  MAX_PROPOSER_SLASHINGS,\n  MAX_ATTESTER_SLASHINGS,\n  MAX_ATTESTATIONS,\n  MAX_DEPOSITS,\n  MAX_VOLUNTARY_EXITS,\n  SYNC_COMMITTEE_SIZE,\n  EPOCHS_PER_SYNC_COMMITTEE_PERIOD,\n  INACTIVITY_PENALTY_QUOTIENT_ALTAIR,\n  MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR,\n  PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR\n} = preset;\nexports.PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR = PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR;\nexports.MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR = MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR;\nexports.INACTIVITY_PENALTY_QUOTIENT_ALTAIR = INACTIVITY_PENALTY_QUOTIENT_ALTAIR;\nexports.EPOCHS_PER_SYNC_COMMITTEE_PERIOD = EPOCHS_PER_SYNC_COMMITTEE_PERIOD;\nexports.SYNC_COMMITTEE_SIZE = SYNC_COMMITTEE_SIZE;\nexports.MAX_VOLUNTARY_EXITS = MAX_VOLUNTARY_EXITS;\nexports.MAX_DEPOSITS = MAX_DEPOSITS;\nexports.MAX_ATTESTATIONS = MAX_ATTESTATIONS;\nexports.MAX_ATTESTER_SLASHINGS = MAX_ATTESTER_SLASHINGS;\nexports.MAX_PROPOSER_SLASHINGS = MAX_PROPOSER_SLASHINGS;\nexports.PROPORTIONAL_SLASHING_MULTIPLIER = PROPORTIONAL_SLASHING_MULTIPLIER;\nexports.MIN_SLASHING_PENALTY_QUOTIENT = MIN_SLASHING_PENALTY_QUOTIENT;\nexports.INACTIVITY_PENALTY_QUOTIENT = INACTIVITY_PENALTY_QUOTIENT;\nexports.PROPOSER_REWARD_QUOTIENT = PROPOSER_REWARD_QUOTIENT;\nexports.WHISTLEBLOWER_REWARD_QUOTIENT = WHISTLEBLOWER_REWARD_QUOTIENT;\nexports.BASE_REWARD_FACTOR = BASE_REWARD_FACTOR;\nexports.VALIDATOR_REGISTRY_LIMIT = VALIDATOR_REGISTRY_LIMIT;\nexports.HISTORICAL_ROOTS_LIMIT = HISTORICAL_ROOTS_LIMIT;\nexports.EPOCHS_PER_SLASHINGS_VECTOR = EPOCHS_PER_SLASHINGS_VECTOR;\nexports.EPOCHS_PER_HISTORICAL_VECTOR = EPOCHS_PER_HISTORICAL_VECTOR;\nexports.MIN_EPOCHS_TO_INACTIVITY_PENALTY = MIN_EPOCHS_TO_INACTIVITY_PENALTY;\nexports.SLOTS_PER_HISTORICAL_ROOT = SLOTS_PER_HISTORICAL_ROOT;\nexports.EPOCHS_PER_ETH1_VOTING_PERIOD = EPOCHS_PER_ETH1_VOTING_PERIOD;\nexports.MAX_SEED_LOOKAHEAD = MAX_SEED_LOOKAHEAD;\nexports.MIN_SEED_LOOKAHEAD = MIN_SEED_LOOKAHEAD;\nexports.SLOTS_PER_EPOCH = SLOTS_PER_EPOCH;\nexports.MIN_ATTESTATION_INCLUSION_DELAY = MIN_ATTESTATION_INCLUSION_DELAY;\nexports.EFFECTIVE_BALANCE_INCREMENT = EFFECTIVE_BALANCE_INCREMENT;\nexports.MAX_EFFECTIVE_BALANCE = MAX_EFFECTIVE_BALANCE;\nexports.MIN_DEPOSIT_AMOUNT = MIN_DEPOSIT_AMOUNT;\nexports.SAFE_SLOTS_TO_UPDATE_JUSTIFIED = SAFE_SLOTS_TO_UPDATE_JUSTIFIED;\nexports.HYSTERESIS_UPWARD_MULTIPLIER = HYSTERESIS_UPWARD_MULTIPLIER;\nexports.HYSTERESIS_DOWNWARD_MULTIPLIER = HYSTERESIS_DOWNWARD_MULTIPLIER;\nexports.HYSTERESIS_QUOTIENT = HYSTERESIS_QUOTIENT;\nexports.SHUFFLE_ROUND_COUNT = SHUFFLE_ROUND_COUNT;\nexports.MAX_VALIDATORS_PER_COMMITTEE = MAX_VALIDATORS_PER_COMMITTEE;\nexports.TARGET_COMMITTEE_SIZE = TARGET_COMMITTEE_SIZE;\nexports.MAX_COMMITTEES_PER_SLOT = MAX_COMMITTEES_PER_SLOT;\n//# sourceMappingURL=activePreset.js.map","// shim for using process in browser\nvar process = module.exports = {};\n\n// cached from whatever global is present so that test runners that stub it\n// don't break things.  But we need to wrap it in a try catch in case it is\n// wrapped in strict mode code which doesn't define any globals.  It's inside a\n// function because try/catches deoptimize in certain engines.\n\nvar cachedSetTimeout;\nvar cachedClearTimeout;\n\nfunction defaultSetTimout() {\n    throw new Error('setTimeout has not been defined');\n}\nfunction defaultClearTimeout () {\n    throw new Error('clearTimeout has not been defined');\n}\n(function () {\n    try {\n        if (typeof setTimeout === 'function') {\n            cachedSetTimeout = setTimeout;\n        } else {\n            cachedSetTimeout = defaultSetTimout;\n        }\n    } catch (e) {\n        cachedSetTimeout = defaultSetTimout;\n    }\n    try {\n        if (typeof clearTimeout === 'function') {\n            cachedClearTimeout = clearTimeout;\n        } else {\n            cachedClearTimeout = defaultClearTimeout;\n        }\n    } catch (e) {\n        cachedClearTimeout = defaultClearTimeout;\n    }\n} ())\nfunction runTimeout(fun) {\n    if (cachedSetTimeout === setTimeout) {\n        //normal enviroments in sane situations\n        return setTimeout(fun, 0);\n    }\n    // if setTimeout wasn't available but was latter defined\n    if ((cachedSetTimeout === defaultSetTimout || !cachedSetTimeout) && setTimeout) {\n        cachedSetTimeout = setTimeout;\n        return setTimeout(fun, 0);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedSetTimeout(fun, 0);\n    } catch(e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't trust the global object when called normally\n            return cachedSetTimeout.call(null, fun, 0);\n        } catch(e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error\n            return cachedSetTimeout.call(this, fun, 0);\n        }\n    }\n\n\n}\nfunction runClearTimeout(marker) {\n    if (cachedClearTimeout === clearTimeout) {\n        //normal enviroments in sane situations\n        return clearTimeout(marker);\n    }\n    // if clearTimeout wasn't available but was latter defined\n    if ((cachedClearTimeout === defaultClearTimeout || !cachedClearTimeout) && clearTimeout) {\n        cachedClearTimeout = clearTimeout;\n        return clearTimeout(marker);\n    }\n    try {\n        // when when somebody has screwed with setTimeout but no I.E. maddness\n        return cachedClearTimeout(marker);\n    } catch (e){\n        try {\n            // When we are in I.E. but the script has been evaled so I.E. doesn't  trust the global object when called normally\n            return cachedClearTimeout.call(null, marker);\n        } catch (e){\n            // same as above but when it's a version of I.E. that must have the global object for 'this', hopfully our context correct otherwise it will throw a global error.\n            // Some versions of I.E. have different rules for clearTimeout vs setTimeout\n            return cachedClearTimeout.call(this, marker);\n        }\n    }\n\n\n\n}\nvar queue = [];\nvar draining = false;\nvar currentQueue;\nvar queueIndex = -1;\n\nfunction cleanUpNextTick() {\n    if (!draining || !currentQueue) {\n        return;\n    }\n    draining = false;\n    if (currentQueue.length) {\n        queue = currentQueue.concat(queue);\n    } else {\n        queueIndex = -1;\n    }\n    if (queue.length) {\n        drainQueue();\n    }\n}\n\nfunction drainQueue() {\n    if (draining) {\n        return;\n    }\n    var timeout = runTimeout(cleanUpNextTick);\n    draining = true;\n\n    var len = queue.length;\n    while(len) {\n        currentQueue = queue;\n        queue = [];\n        while (++queueIndex < len) {\n            if (currentQueue) {\n                currentQueue[queueIndex].run();\n            }\n        }\n        queueIndex = -1;\n        len = queue.length;\n    }\n    currentQueue = null;\n    draining = false;\n    runClearTimeout(timeout);\n}\n\nprocess.nextTick = function (fun) {\n    var args = new Array(arguments.length - 1);\n    if (arguments.length > 1) {\n        for (var i = 1; i < arguments.length; i++) {\n            args[i - 1] = arguments[i];\n        }\n    }\n    queue.push(new Item(fun, args));\n    if (queue.length === 1 && !draining) {\n        runTimeout(drainQueue);\n    }\n};\n\n// v8 likes predictible objects\nfunction Item(fun, array) {\n    this.fun = fun;\n    this.array = array;\n}\nItem.prototype.run = function () {\n    this.fun.apply(null, this.array);\n};\nprocess.title = 'browser';\nprocess.browser = true;\nprocess.env = {};\nprocess.argv = [];\nprocess.version = ''; // empty string to avoid regexp issues\nprocess.versions = {};\n\nfunction noop() {}\n\nprocess.on = noop;\nprocess.addListener = noop;\nprocess.once = noop;\nprocess.off = noop;\nprocess.removeListener = noop;\nprocess.removeAllListeners = noop;\nprocess.emit = noop;\nprocess.prependListener = noop;\nprocess.prependOnceListener = noop;\n\nprocess.listeners = function (name) { return [] }\n\nprocess.binding = function (name) {\n    throw new Error('process.binding is not supported');\n};\n\nprocess.cwd = function () { return '/' };\nprocess.chdir = function (dir) {\n    throw new Error('process.chdir is not supported');\n};\nprocess.umask = function() { return 0; };\n","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preset = exports.commit = void 0;\n\nvar _phase = require(\"./phase0\");\n\nvar _altair = require(\"./altair\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst commit = \"v1.1.0-alpha.7\";\nexports.commit = commit;\n\nconst preset = _objectSpread(_objectSpread({}, _phase.phase0), _altair.altair);\n\nexports.preset = preset;\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phase0 = void 0;\n\n/* eslint-disable @typescript-eslint/naming-convention */\n// Mainnet preset\nconst phase0 = {\n  // Misc\n  // ---------------------------------------------------------------\n  // 2**6 (= 64)\n  MAX_COMMITTEES_PER_SLOT: 64,\n  // 2**7 (= 128)\n  TARGET_COMMITTEE_SIZE: 128,\n  // 2**11 (= 2,048)\n  MAX_VALIDATORS_PER_COMMITTEE: 2048,\n  // See issue 563\n  SHUFFLE_ROUND_COUNT: 90,\n  // 4\n  HYSTERESIS_QUOTIENT: 4,\n  // 1 (minus 0.25)\n  HYSTERESIS_DOWNWARD_MULTIPLIER: 1,\n  // 5 (plus 1.25)\n  HYSTERESIS_UPWARD_MULTIPLIER: 5,\n  // Fork Choice\n  // ---------------------------------------------------------------\n  // 2**3 (= 8)\n  SAFE_SLOTS_TO_UPDATE_JUSTIFIED: 8,\n  // Gwei values\n  // ---------------------------------------------------------------\n  // 2**0 * 10**9 (= 1,000,000,000) Gwei\n  MIN_DEPOSIT_AMOUNT: BigInt(1000000000),\n  // 2**5 * 10**9 (= 32,000,000,000) Gwei\n  MAX_EFFECTIVE_BALANCE: BigInt(32000000000),\n  // 2**0 * 10**9 (= 1,000,000,000) Gwei\n  EFFECTIVE_BALANCE_INCREMENT: BigInt(1000000000),\n  // Time parameters\n  // ---------------------------------------------------------------\n  // 2**0 (= 1) slots 12 seconds\n  MIN_ATTESTATION_INCLUSION_DELAY: 1,\n  // 2**5 (= 32) slots 6.4 minutes\n  SLOTS_PER_EPOCH: 32,\n  // 2**0 (= 1) epochs 6.4 minutes\n  MIN_SEED_LOOKAHEAD: 1,\n  // 2**2 (= 4) epochs 25.6 minutes\n  MAX_SEED_LOOKAHEAD: 4,\n  // 2**6 (= 64) epochs ~6.8 hours\n  EPOCHS_PER_ETH1_VOTING_PERIOD: 64,\n  // 2**13 (= 8,192) slots ~13 hours\n  SLOTS_PER_HISTORICAL_ROOT: 8192,\n  // 2**2 (= 4) epochs 25.6 minutes\n  MIN_EPOCHS_TO_INACTIVITY_PENALTY: 4,\n  // State vector lengths\n  // ---------------------------------------------------------------\n  // 2**16 (= 65,536) epochs ~0.8 years\n  EPOCHS_PER_HISTORICAL_VECTOR: 65536,\n  // 2**13 (= 8,192) epochs ~36 days\n  EPOCHS_PER_SLASHINGS_VECTOR: 8192,\n  // 2**24 (= 16,777,216) historical roots, ~26,131 years\n  HISTORICAL_ROOTS_LIMIT: 16777216,\n  // 2**40 (= 1,099,511,627,776) validator spots\n  VALIDATOR_REGISTRY_LIMIT: 1099511627776,\n  // Reward and penalty quotients\n  // ---------------------------------------------------------------\n  // 2**6 (= 64)\n  BASE_REWARD_FACTOR: BigInt(64),\n  // 2**9 (= 512)\n  WHISTLEBLOWER_REWARD_QUOTIENT: BigInt(512),\n  // 2**3 (= 8)\n  PROPOSER_REWARD_QUOTIENT: BigInt(8),\n  // 2**26 (= 67,108,864)\n  INACTIVITY_PENALTY_QUOTIENT: BigInt(67108864),\n  // 2**7 (= 128) (lower safety margin at Phase 0 genesis)\n  MIN_SLASHING_PENALTY_QUOTIENT: BigInt(128),\n  PROPORTIONAL_SLASHING_MULTIPLIER: BigInt(1),\n  // Max operations per block\n  // ---------------------------------------------------------------\n  // 2**4 (= 16)\n  MAX_PROPOSER_SLASHINGS: 16,\n  // 2**1 (= 2)\n  MAX_ATTESTER_SLASHINGS: 2,\n  // 2**7 (= 128)\n  MAX_ATTESTATIONS: 128,\n  // 2**4 (= 16)\n  MAX_DEPOSITS: 16,\n  // 2**4 (= 16)\n  MAX_VOLUNTARY_EXITS: 16\n};\nexports.phase0 = phase0;\n//# sourceMappingURL=phase0.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.altair = void 0;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nconst altair = {\n  SYNC_COMMITTEE_SIZE: 512,\n  EPOCHS_PER_SYNC_COMMITTEE_PERIOD: 256,\n  INACTIVITY_PENALTY_QUOTIENT_ALTAIR: BigInt(50331648),\n  MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR: BigInt(64),\n  PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR: BigInt(2)\n};\nexports.altair = altair;\n//# sourceMappingURL=altair.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.preset = exports.commit = void 0;\n\nvar _phase = require(\"./phase0\");\n\nvar _altair = require(\"./altair\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst commit = \"v1.1.0-alpha.7\";\nexports.commit = commit;\n\nconst preset = _objectSpread(_objectSpread({}, _phase.phase0), _altair.altair);\n\nexports.preset = preset;\n//# sourceMappingURL=index.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.phase0 = void 0;\n\n/* eslint-disable @typescript-eslint/naming-convention */\n// Minimal preset\nconst phase0 = {\n  // Misc\n  // ---------------------------------------------------------------\n  // [customized] Just 4 committees for slot for testing purposes\n  MAX_COMMITTEES_PER_SLOT: 4,\n  // [customized] unsecure, but fast\n  TARGET_COMMITTEE_SIZE: 4,\n  // 2**11 (= 2,048)\n  MAX_VALIDATORS_PER_COMMITTEE: 2048,\n  // [customized] Faster, but unsecure.\n  SHUFFLE_ROUND_COUNT: 10,\n  // 4\n  HYSTERESIS_QUOTIENT: 4,\n  // 1 (minus 0.25)\n  HYSTERESIS_DOWNWARD_MULTIPLIER: 1,\n  // 5 (plus 1.25)\n  HYSTERESIS_UPWARD_MULTIPLIER: 5,\n  // Fork Choice\n  // ---------------------------------------------------------------\n  // 2**1 (= 1)\n  SAFE_SLOTS_TO_UPDATE_JUSTIFIED: 2,\n  // Gwei values\n  // ---------------------------------------------------------------\n  // 2**0 * 10**9 (= 1,000,000,000) Gwei\n  MIN_DEPOSIT_AMOUNT: BigInt(1000000000),\n  // 2**5 * 10**9 (= 32,000,000,000) Gwei\n  MAX_EFFECTIVE_BALANCE: BigInt(32000000000),\n  // 2**0 * 10**9 (= 1,000,000,000) Gwei\n  EFFECTIVE_BALANCE_INCREMENT: BigInt(1000000000),\n  // Time parameters\n  // ---------------------------------------------------------------\n  // 2**0 (= 1) slots 6 seconds\n  MIN_ATTESTATION_INCLUSION_DELAY: 1,\n  // [customized] fast epochs\n  SLOTS_PER_EPOCH: 8,\n  // 2**0 (= 1) epochs\n  MIN_SEED_LOOKAHEAD: 1,\n  // 2**2 (= 4) epochs\n  MAX_SEED_LOOKAHEAD: 4,\n  // [customized] higher frequency new deposits from eth1 for testing\n  EPOCHS_PER_ETH1_VOTING_PERIOD: 4,\n  // [customized] smaller state\n  SLOTS_PER_HISTORICAL_ROOT: 64,\n\n  /*\n  // 2**8 (= 256) epochs\n  MIN_VALIDATOR_WITHDRAWABILITY_DELAY: 256,\n  // [customized] higher frequency of committee turnover and faster time to acceptable voluntary exit\n  SHARD_COMMITTEE_PERIOD: 64,\n  */\n  // 2**2 (= 4) epochs\n  MIN_EPOCHS_TO_INACTIVITY_PENALTY: 4,\n  // State vector lengths\n  // ---------------------------------------------------------------\n  // [customized] smaller state\n  EPOCHS_PER_HISTORICAL_VECTOR: 64,\n  // [customized] smaller state\n  EPOCHS_PER_SLASHINGS_VECTOR: 64,\n  // 2**24 (= 16,777,216) historical roots\n  HISTORICAL_ROOTS_LIMIT: 16777216,\n  // 2**40 (= 1,099,511,627,776) validator spots\n  VALIDATOR_REGISTRY_LIMIT: 1099511627776,\n  // Reward and penalty quotients\n  // ---------------------------------------------------------------\n  // 2**6 (= 64)\n  BASE_REWARD_FACTOR: BigInt(64),\n  // 2**9 (= 512)\n  WHISTLEBLOWER_REWARD_QUOTIENT: BigInt(512),\n  // 2**3 (= 8)\n  PROPOSER_REWARD_QUOTIENT: BigInt(8),\n  // [customized] 2**25 (= 33,554,432)\n  INACTIVITY_PENALTY_QUOTIENT: BigInt(33554432),\n  // [customized] 2**6 (= 64)\n  MIN_SLASHING_PENALTY_QUOTIENT: BigInt(64),\n  // [customized] 2 (lower safety margin than Phase 0 genesis but different than mainnet config for testing)\n  PROPORTIONAL_SLASHING_MULTIPLIER: BigInt(2),\n  // Max operations per block\n  // ---------------------------------------------------------------\n  // 2**4 (= 16)\n  MAX_PROPOSER_SLASHINGS: 16,\n  // 2**1 (= 2)\n  MAX_ATTESTER_SLASHINGS: 2,\n  // 2**7 (= 128)\n  MAX_ATTESTATIONS: 128,\n  // 2**4 (= 16)\n  MAX_DEPOSITS: 16,\n  // 2**4 (= 16)\n  MAX_VOLUNTARY_EXITS: 16\n};\nexports.phase0 = phase0;\n//# sourceMappingURL=phase0.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.altair = void 0;\n\n/* eslint-disable @typescript-eslint/naming-convention */\nconst altair = {\n  SYNC_COMMITTEE_SIZE: 32,\n  EPOCHS_PER_SYNC_COMMITTEE_PERIOD: 8,\n  INACTIVITY_PENALTY_QUOTIENT_ALTAIR: BigInt(50331648),\n  MIN_SLASHING_PENALTY_QUOTIENT_ALTAIR: BigInt(64),\n  PROPORTIONAL_SLASHING_MULTIPLIER_ALTAIR: BigInt(2)\n};\nexports.altair = altair;\n//# sourceMappingURL=altair.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.ForkName = void 0;\n\n/**\n * Forks in order of occurance\n */\nlet ForkName;\nexports.ForkName = ForkName;\n\n(function (ForkName) {\n  ForkName[\"phase0\"] = \"phase0\";\n  ForkName[\"altair\"] = \"altair\";\n})(ForkName || (exports.ForkName = ForkName = {}));\n//# sourceMappingURL=forkName.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\n\nvar _sync = require(\"./sync\");\n\nObject.keys(_sync).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _sync[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _sync[key];\n    }\n  });\n});\n\nvar _committee = require(\"./committee\");\n\nObject.keys(_committee).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _committee[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _committee[key];\n    }\n  });\n});\n\nvar _beacon = require(\"./beacon\");\n\nObject.keys(_beacon).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _beacon[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _beacon[key];\n    }\n  });\n});\n\nvar _types = require(\"../../primitive/types\");\n\nObject.keys(_types).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _types[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _types[key];\n    }\n  });\n});\n\nvar _misc = require(\"../../phase0/types/misc\");\n\nObject.keys(_misc).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _misc[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _misc[key];\n    }\n  });\n});\n\nvar _operations = require(\"../../phase0/types/operations\");\n\nObject.keys(_operations).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _operations[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _operations[key];\n    }\n  });\n});\n\nvar _validator = require(\"../../phase0/types/validator\");\n\nObject.keys(_validator).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _validator[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _validator[key];\n    }\n  });\n});\n\nvar _wire = require(\"./wire\");\n\nObject.keys(_wire).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _wire[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _wire[key];\n    }\n  });\n});\n\nvar _api = require(\"../../phase0/types/api\");\n\nObject.keys(_api).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (key in exports && exports[key] === _api[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _api[key];\n    }\n  });\n});\n//# sourceMappingURL=index.js.map","\"use strict\";\n//# sourceMappingURL=sync.js.map","\"use strict\";\n//# sourceMappingURL=committee.js.map","\"use strict\";\n//# sourceMappingURL=beacon.js.map","\"use strict\";\n//# sourceMappingURL=wire.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.LightClientStore = exports.LightClientUpdate = exports.LightClientSnapshot = exports.BeaconState = exports.SignedBeaconBlock = exports.BeaconBlock = exports.BeaconBlockBody = exports.HistoricalBatch = exports.HistoricalStateRoots = exports.HistoricalBlockRoots = exports.SyncAggregate = exports.SyncCommitteeBits = exports.SyncAggregatorSelectionData = exports.SignedContributionAndProof = exports.ContributionAndProof = exports.SyncCommitteeContribution = exports.SyncCommitteeMessage = exports.SyncCommittee = exports.Metadata = exports.SyncSubnets = void 0;\n\nvar _lodestarParams = require(\"@chainsafe/lodestar-params\");\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\nvar _phase = require(\"../phase0\");\n\nvar _primitive = require(\"../primitive\");\n\nvar _lazyVar = require(\"../utils/lazyVar\");\n\nfunction ownKeys(object, enumerableOnly) { var keys = Object.keys(object); if (Object.getOwnPropertySymbols) { var symbols = Object.getOwnPropertySymbols(object); if (enumerableOnly) symbols = symbols.filter(function (sym) { return Object.getOwnPropertyDescriptor(object, sym).enumerable; }); keys.push.apply(keys, symbols); } return keys; }\n\nfunction _objectSpread(target) { for (var i = 1; i < arguments.length; i++) { var source = arguments[i] != null ? arguments[i] : {}; if (i % 2) { ownKeys(Object(source), true).forEach(function (key) { _defineProperty(target, key, source[key]); }); } else if (Object.getOwnPropertyDescriptors) { Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)); } else { ownKeys(Object(source)).forEach(function (key) { Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key)); }); } } return target; }\n\nfunction _defineProperty(obj, key, value) { if (key in obj) { Object.defineProperty(obj, key, { value: value, enumerable: true, configurable: true, writable: true }); } else { obj[key] = value; } return obj; }\n\nconst {\n  Bytes32,\n  Number64,\n  Uint64,\n  Slot,\n  SubCommitteeIndex,\n  ValidatorIndex,\n  Gwei,\n  Root,\n  Version,\n  BLSPubkey,\n  BLSSignature,\n  ParticipationFlags\n} = _primitive.ssz; // So the expandedRoots can be referenced, and break the circular dependency\n\nconst typesRef = new _lazyVar.LazyVariable();\nconst SyncSubnets = new _ssz.BitVectorType({\n  length: _lodestarParams.SYNC_COMMITTEE_SUBNET_COUNT\n});\nexports.SyncSubnets = SyncSubnets;\nconst Metadata = new _ssz.ContainerType({\n  fields: {\n    seqNumber: Uint64,\n    attnets: _phase.ssz.AttestationSubnets,\n    syncnets: SyncSubnets\n  }\n});\nexports.Metadata = Metadata;\nconst SyncCommittee = new _ssz.ContainerType({\n  fields: {\n    pubkeys: new _ssz.VectorType({\n      elementType: BLSPubkey,\n      length: _lodestarParams.SYNC_COMMITTEE_SIZE\n    }),\n    aggregatePubkey: BLSPubkey\n  }\n});\nexports.SyncCommittee = SyncCommittee;\nconst SyncCommitteeMessage = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    beaconBlockRoot: Root,\n    validatorIndex: ValidatorIndex,\n    signature: BLSSignature\n  }\n});\nexports.SyncCommitteeMessage = SyncCommitteeMessage;\nconst SyncCommitteeContribution = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    beaconBlockRoot: Root,\n    subCommitteeIndex: SubCommitteeIndex,\n    aggregationBits: new _ssz.BitVectorType({\n      length: _lodestarParams.SYNC_COMMITTEE_SIZE / _lodestarParams.SYNC_COMMITTEE_SUBNET_COUNT\n    }),\n    signature: BLSSignature\n  }\n});\nexports.SyncCommitteeContribution = SyncCommitteeContribution;\nconst ContributionAndProof = new _ssz.ContainerType({\n  fields: {\n    aggregatorIndex: ValidatorIndex,\n    contribution: SyncCommitteeContribution,\n    selectionProof: BLSSignature\n  }\n});\nexports.ContributionAndProof = ContributionAndProof;\nconst SignedContributionAndProof = new _ssz.ContainerType({\n  fields: {\n    message: ContributionAndProof,\n    signature: BLSSignature\n  }\n});\nexports.SignedContributionAndProof = SignedContributionAndProof;\nconst SyncAggregatorSelectionData = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    subCommitteeIndex: SubCommitteeIndex\n  }\n});\nexports.SyncAggregatorSelectionData = SyncAggregatorSelectionData;\nconst SyncCommitteeBits = new _ssz.BitVectorType({\n  length: _lodestarParams.SYNC_COMMITTEE_SIZE\n});\nexports.SyncCommitteeBits = SyncCommitteeBits;\nconst SyncAggregate = new _ssz.ContainerType({\n  fields: {\n    syncCommitteeBits: SyncCommitteeBits,\n    syncCommitteeSignature: BLSSignature\n  }\n}); // Re-declare with the new expanded type\n\nexports.SyncAggregate = SyncAggregate;\nconst HistoricalBlockRoots = new _ssz.VectorType({\n  elementType: new _ssz.RootType({\n    expandedType: () => typesRef.get().BeaconBlock\n  }),\n  length: _lodestarParams.SLOTS_PER_HISTORICAL_ROOT\n});\nexports.HistoricalBlockRoots = HistoricalBlockRoots;\nconst HistoricalStateRoots = new _ssz.VectorType({\n  elementType: new _ssz.RootType({\n    expandedType: () => typesRef.get().BeaconState\n  }),\n  length: _lodestarParams.SLOTS_PER_HISTORICAL_ROOT\n});\nexports.HistoricalStateRoots = HistoricalStateRoots;\nconst HistoricalBatch = new _ssz.ContainerType({\n  fields: {\n    blockRoots: HistoricalBlockRoots,\n    stateRoots: HistoricalStateRoots\n  }\n});\nexports.HistoricalBatch = HistoricalBatch;\nconst BeaconBlockBody = new _ssz.ContainerType({\n  fields: _objectSpread(_objectSpread({}, _phase.ssz.BeaconBlockBody.fields), {}, {\n    syncAggregate: SyncAggregate\n  })\n});\nexports.BeaconBlockBody = BeaconBlockBody;\nconst BeaconBlock = new _ssz.ContainerType({\n  fields: {\n    slot: Slot,\n    proposerIndex: ValidatorIndex,\n    // Reclare expandedType() with altair block and altair state\n    parentRoot: new _ssz.RootType({\n      expandedType: () => typesRef.get().BeaconBlock\n    }),\n    stateRoot: new _ssz.RootType({\n      expandedType: () => typesRef.get().BeaconState\n    }),\n    body: BeaconBlockBody\n  }\n});\nexports.BeaconBlock = BeaconBlock;\nconst SignedBeaconBlock = new _ssz.ContainerType({\n  fields: {\n    message: BeaconBlock,\n    signature: BLSSignature\n  }\n}); //we don't reuse phase0.BeaconState fields since we need to replace some keys\n//and we cannot keep order doing that\n\nexports.SignedBeaconBlock = SignedBeaconBlock;\nconst BeaconState = new _ssz.ContainerType({\n  fields: {\n    genesisTime: Number64,\n    genesisValidatorsRoot: Root,\n    slot: Slot,\n    fork: _phase.ssz.Fork,\n    // History\n    latestBlockHeader: _phase.ssz.BeaconBlockHeader,\n    blockRoots: HistoricalBlockRoots,\n    stateRoots: HistoricalStateRoots,\n    historicalRoots: new _ssz.ListType({\n      elementType: new _ssz.RootType({\n        expandedType: HistoricalBatch\n      }),\n      limit: _lodestarParams.HISTORICAL_ROOTS_LIMIT\n    }),\n    // Eth1\n    eth1Data: _phase.ssz.Eth1Data,\n    eth1DataVotes: new _ssz.ListType({\n      elementType: _phase.ssz.Eth1Data,\n      limit: _lodestarParams.EPOCHS_PER_ETH1_VOTING_PERIOD * _lodestarParams.SLOTS_PER_EPOCH\n    }),\n    eth1DepositIndex: Number64,\n    // Registry\n    validators: new _ssz.ListType({\n      elementType: _phase.ssz.Validator,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    balances: new _ssz.ListType({\n      elementType: Gwei,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    randaoMixes: new _ssz.VectorType({\n      elementType: Bytes32,\n      length: _lodestarParams.EPOCHS_PER_HISTORICAL_VECTOR\n    }),\n    // Slashings\n    slashings: new _ssz.VectorType({\n      elementType: Gwei,\n      length: _lodestarParams.EPOCHS_PER_SLASHINGS_VECTOR\n    }),\n    // Participation\n    previousEpochParticipation: new _ssz.ListType({\n      elementType: ParticipationFlags,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    currentEpochParticipation: new _ssz.ListType({\n      elementType: ParticipationFlags,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    // Finality\n    justificationBits: new _ssz.BitVectorType({\n      length: _lodestarParams.JUSTIFICATION_BITS_LENGTH\n    }),\n    previousJustifiedCheckpoint: _phase.ssz.Checkpoint,\n    currentJustifiedCheckpoint: _phase.ssz.Checkpoint,\n    finalizedCheckpoint: _phase.ssz.Checkpoint,\n    // Inactivity\n    inactivityScores: new _ssz.ListType({\n      elementType: Number64,\n      limit: _lodestarParams.VALIDATOR_REGISTRY_LIMIT\n    }),\n    // Sync\n    currentSyncCommittee: SyncCommittee,\n    nextSyncCommittee: SyncCommittee\n  }\n});\nexports.BeaconState = BeaconState;\nconst LightClientSnapshot = new _ssz.ContainerType({\n  fields: {\n    header: _phase.ssz.BeaconBlockHeader,\n    nextSyncCommittee: SyncCommittee,\n    currentSyncCommittee: SyncCommittee\n  }\n});\nexports.LightClientSnapshot = LightClientSnapshot;\nconst LightClientUpdate = new _ssz.ContainerType({\n  fields: {\n    header: _phase.ssz.BeaconBlockHeader,\n    nextSyncCommittee: SyncCommittee,\n    nextSyncCommitteeBranch: new _ssz.VectorType({\n      elementType: Bytes32,\n      length: _lodestarParams.NEXT_SYNC_COMMITTEE_INDEX_FLOORLOG2\n    }),\n    finalityHeader: _phase.ssz.BeaconBlockHeader,\n    finalityBranch: new _ssz.VectorType({\n      elementType: Bytes32,\n      length: _lodestarParams.FINALIZED_ROOT_INDEX_FLOORLOG2\n    }),\n    syncCommitteeBits: new _ssz.BitVectorType({\n      length: _lodestarParams.SYNC_COMMITTEE_SIZE\n    }),\n    syncCommitteeSignature: BLSSignature,\n    forkVersion: Version\n  }\n});\nexports.LightClientUpdate = LightClientUpdate;\nconst LightClientStore = new _ssz.ContainerType({\n  fields: {\n    snapshot: LightClientSnapshot,\n    validUpdates: new _ssz.ListType({\n      elementType: LightClientUpdate,\n      limit: _lodestarParams.EPOCHS_PER_SYNC_COMMITTEE_PERIOD * _lodestarParams.SLOTS_PER_EPOCH\n    })\n  }\n}); // MUST set typesRef here, otherwise expandedType() calls will throw\n\nexports.LightClientStore = LightClientStore;\ntypesRef.set({\n  BeaconBlock,\n  BeaconState\n});\n//# sourceMappingURL=sszTypes.js.map","\"use strict\";\n//# sourceMappingURL=types.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.allForks = void 0;\n\nvar _phase = require(\"../phase0\");\n\nvar _altair = require(\"../altair\");\n\n/* eslint-disable @typescript-eslint/naming-convention */\n\n/**\n * Index the ssz types that differ by fork\n * A record of AllForksSSZTypes indexed by fork\n */\nconst allForks = {\n  phase0: {\n    BeaconBlockBody: _phase.ssz.BeaconBlockBody,\n    BeaconBlock: _phase.ssz.BeaconBlock,\n    SignedBeaconBlock: _phase.ssz.SignedBeaconBlock,\n    BeaconState: _phase.ssz.BeaconState,\n    Metadata: _phase.ssz.Metadata\n  },\n  altair: {\n    BeaconBlockBody: _altair.ssz.BeaconBlockBody,\n    BeaconBlock: _altair.ssz.BeaconBlock,\n    SignedBeaconBlock: _altair.ssz.SignedBeaconBlock,\n    BeaconState: _altair.ssz.BeaconState,\n    Metadata: _altair.ssz.Metadata\n  }\n};\nexports.allForks = allForks;\n//# sourceMappingURL=sszTypes.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nvar _exportNames = {\n  allForks: true,\n  phase0: true,\n  altair: true\n};\nObject.defineProperty(exports, \"phase0\", {\n  enumerable: true,\n  get: function () {\n    return _phase.ssz;\n  }\n});\nObject.defineProperty(exports, \"altair\", {\n  enumerable: true,\n  get: function () {\n    return _altair.ssz;\n  }\n});\nexports.allForks = void 0;\n\nvar _sszTypes = require(\"./primitive/sszTypes\");\n\nObject.keys(_sszTypes).forEach(function (key) {\n  if (key === \"default\" || key === \"__esModule\") return;\n  if (Object.prototype.hasOwnProperty.call(_exportNames, key)) return;\n  if (key in exports && exports[key] === _sszTypes[key]) return;\n  Object.defineProperty(exports, key, {\n    enumerable: true,\n    get: function () {\n      return _sszTypes[key];\n    }\n  });\n});\n\nvar _phase = require(\"./phase0\");\n\nvar _altair = require(\"./altair\");\n\nvar _allForks = require(\"./allForks\");\n\nconst allForks = _allForks.ssz.allForks;\nexports.allForks = allForks;\n//# sourceMappingURL=sszTypes.js.map","\"use strict\";\n\nObject.defineProperty(exports, \"__esModule\", {\n  value: true\n});\nexports.StringType = void 0;\n\nvar _ssz = require(\"@chainsafe/ssz\");\n\n/* eslint-disable @typescript-eslint/naming-convention */\nclass StringType extends _ssz.BasicType {\n  // eslint-disable-next-line @typescript-eslint/no-unused-vars\n  struct_getSerializedLength(data) {\n    throw new Error(\"unsupported ssz operation\");\n  }\n\n  struct_convertToJson(value) {\n    return value;\n  }\n\n  struct_convertFromJson(data) {\n    return data;\n  }\n\n  struct_assertValidValue(data) {\n    throw new Error(\"unsupported ssz operation\");\n  }\n\n  serialize() {\n    throw new Error(\"unsupported ssz type for serialization\");\n  }\n\n  struct_serializeToBytes() {\n    throw new Error(\"unsupported ssz type for serialization\");\n  }\n\n  struct_deserializeFromBytes() {\n    throw new Error(\"unsupported ssz operation\");\n  }\n\n  struct_defaultValue() {\n    return \"something\";\n  }\n\n}\n\nexports.StringType = StringType;\n//# sourceMappingURL=StringType.js.map","import {Type} from \"@chainsafe/ssz\";\nimport {ssz} from \"@chainsafe/lodestar-types\";\n\nconst {phase0, altair, allForks, ...primitive} = ssz;\n\nexport const forks = {\n  phase0: {...phase0, ...primitive} as Record<string, Type<unknown>>,\n  altair: {...phase0, ...altair, ...primitive} as Record<string, Type<unknown>>,\n}\n\nexport type ForkName = keyof typeof forks;\n\nexport function typeNames<T>(types: Record<string, Type<T>>): string[] {\n  return Object.keys(types).sort();\n}","import {forks} from \"../util/types\";\nimport {\n  BasicType,\n  CompositeType,\n  isBooleanType,\n  isListType,\n  isVectorType,\n  isBitListType,\n  isBitVectorType,\n  isContainerType,\n  isByteVectorType,\n  isNumberUintType,\n  isBigIntUintType,\n} from \"@chainsafe/ssz\";\n\n\nfunction randomNumber(length: number): number {\n  return Math.random() * length | 0;\n}\n\nfunction randomNumberUint(byteLength: number): number {\n  return randomNumber(byteLength);\n}\n\nfunction randomBigUint(byteLength: number): bigint {\n  return BigInt(randomNumber(byteLength));\n}\n\nfunction randomBoolean(): boolean {\n  return Math.random() > 0.5;\n}\n\nfunction randomBooleanArray(length: number): Array<boolean> {\n  return Array.from({length}, () => randomBoolean());\n}\n\nfunction randomByteVector(length: number): Uint8Array {\n  const array = new Uint8Array(length);\n  self.crypto.getRandomValues(array);\n  return array;\n}\n\nfunction createRandomValue(type: BasicType<unknown> | CompositeType<object>): \nboolean | number | bigint | Uint8Array | Array<boolean> | object | undefined {\n  if(isNumberUintType(type)) {\n    return randomNumberUint(type.byteLength);\n  }\n  else if(isBigIntUintType(type)) {\n    return randomBigUint(type.byteLength);\n  }\n  else if(isBooleanType(type)) {\n    return randomBoolean();\n  }\n  else if(isBitVectorType(type)) {\n    return randomBooleanArray(type.length);\n  }\n  else if(isByteVectorType(type)) {\n    return randomByteVector(type.length);\n  }\n  else if(isBitListType(type)) {\n    const listLength = Math.min(Math.floor(Math.random() * 16), type.limit);\n    return randomBooleanArray(listLength);\n  }\n  else if(isListType(type)) {\n    const listLength = Math.min(Math.floor(Math.random() * 16), type.limit);\n    return Array.from({length: listLength}, () => createRandomValue(type.elementType));\n  }\n  else if(isVectorType(type)) {\n    return Array.from({length: type.length}, () => createRandomValue(type.elementType));\n  }\n  else if(isContainerType(type)) {\n    const obj = {};\n    Object.entries(type.fields).forEach(([fieldName, fieldType]) => {\n      obj[fieldName] = createRandomValue(fieldType);\n    });\n    return obj;\n  }\n}\n\nfunction getSSZType(data: {sszTypeName: string; forkName: string; input: object}): \nBasicType<unknown> | CompositeType<object> {\n  return forks[data.forkName][data.sszTypeName];\n}\n\nexport function createRandomValueWorker(data: {sszTypeName: string; forkName: string; input: object}): \nboolean | number | bigint | Uint8Array | Array<boolean> | object | undefined {\n  const sszType = getSSZType(data);\n  const value = createRandomValue(sszType);\n  return value;\n}\n\nexport function serialize(data: {sszTypeName: string; forkName: string; input: object}): object {\n  const type = getSSZType(data);\n  const serialized = type.serialize(data.input);\n  const root = type.hashTreeRoot(data.input);\n  return {serialized, root};\n}\n"],"sourceRoot":""}